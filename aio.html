<!DOCTYPE html>
<!-- START: inst/pkgdown/templates/layout.html --><!-- Generated by pkgdown: do not edit by hand --><html lang="en" data-bs-theme="auto">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<title>Introduction to Geospatial Raster and Vector Data with Python: All in One View</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<script src="assets/themetoggle.js"></script><link rel="stylesheet" type="text/css" href="assets/styles.css">
<script src="assets/scripts.js" type="text/javascript"></script><!-- mathjax --><script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      config: ["MMLorHTML.js"],
      jax: ["input/TeX","input/MathML","output/HTML-CSS","output/NativeMML", "output/PreviewHTML"],
      extensions: ["tex2jax.js","mml2jax.js","MathMenu.js","MathZoom.js", "fast-preview.js", "AssistiveMML.js", "a11y/accessibility-menu.js"],
      TeX: {
        extensions: ["AMSmath.js","AMSsymbols.js","noErrors.js","noUndefined.js"]
      },
      tex2jax: {
        inlineMath: [['\\(', '\\)']],
        displayMath: [ ['$$','$$'], ['\\[', '\\]'] ],
        processEscapes: true
      }
    });
    </script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><!-- Responsive Favicon for The Carpentries --><link rel="apple-touch-icon" sizes="180x180" href="favicons/incubator/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="favicons/incubator/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="favicons/incubator/favicon-16x16.png">
<link rel="manifest" href="favicons/incubator/site.webmanifest">
<link rel="mask-icon" href="favicons/incubator/safari-pinned-tab.svg" color="#5bbad5">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="white">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="black">
</head>
<body>
    <header id="top" class="navbar navbar-expand-md top-nav incubator"><svg xmlns="http://www.w3.org/2000/svg" class="d-none"><symbol id="check2" viewbox="0 0 16 16"><path d="M13.854 3.646a.5.5 0 0 1 0 .708l-7 7a.5.5 0 0 1-.708 0l-3.5-3.5a.5.5 0 1 1 .708-.708L6.5 10.293l6.646-6.647a.5.5 0 0 1 .708 0z"></path></symbol><symbol id="circle-half" viewbox="0 0 16 16"><path d="M8 15A7 7 0 1 0 8 1v14zm0 1A8 8 0 1 1 8 0a8 8 0 0 1 0 16z"></path></symbol><symbol id="moon-stars-fill" viewbox="0 0 16 16"><path d="M6 .278a.768.768 0 0 1 .08.858 7.208 7.208 0 0 0-.878 3.46c0 4.021 3.278 7.277 7.318 7.277.527 0 1.04-.055 1.533-.16a.787.787 0 0 1 .81.316.733.733 0 0 1-.031.893A8.349 8.349 0 0 1 8.344 16C3.734 16 0 12.286 0 7.71 0 4.266 2.114 1.312 5.124.06A.752.752 0 0 1 6 .278z"></path><path d="M10.794 3.148a.217.217 0 0 1 .412 0l.387 1.162c.173.518.579.924 1.097 1.097l1.162.387a.217.217 0 0 1 0 .412l-1.162.387a1.734 1.734 0 0 0-1.097 1.097l-.387 1.162a.217.217 0 0 1-.412 0l-.387-1.162A1.734 1.734 0 0 0 9.31 6.593l-1.162-.387a.217.217 0 0 1 0-.412l1.162-.387a1.734 1.734 0 0 0 1.097-1.097l.387-1.162zM13.863.099a.145.145 0 0 1 .274 0l.258.774c.115.346.386.617.732.732l.774.258a.145.145 0 0 1 0 .274l-.774.258a1.156 1.156 0 0 0-.732.732l-.258.774a.145.145 0 0 1-.274 0l-.258-.774a1.156 1.156 0 0 0-.732-.732l-.774-.258a.145.145 0 0 1 0-.274l.774-.258c.346-.115.617-.386.732-.732L13.863.1z"></path></symbol><symbol id="sun-fill" viewbox="0 0 16 16"><path d="M8 12a4 4 0 1 0 0-8 4 4 0 0 0 0 8zM8 0a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 0zm0 13a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 13zm8-5a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2a.5.5 0 0 1 .5.5zM3 8a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2A.5.5 0 0 1 3 8zm10.657-5.657a.5.5 0 0 1 0 .707l-1.414 1.415a.5.5 0 1 1-.707-.708l1.414-1.414a.5.5 0 0 1 .707 0zm-9.193 9.193a.5.5 0 0 1 0 .707L3.05 13.657a.5.5 0 0 1-.707-.707l1.414-1.414a.5.5 0 0 1 .707 0zm9.193 2.121a.5.5 0 0 1-.707 0l-1.414-1.414a.5.5 0 0 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .707zM4.464 4.465a.5.5 0 0 1-.707 0L2.343 3.05a.5.5 0 1 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .708z"></path></symbol></svg><a class="visually-hidden-focusable skip-link" href="#main-content">Skip to main content</a>
  <div class="container-fluid top-nav-container">
    <div class="col-md-8">
      <div class="large-logo">
        <img id="incubator-logo" alt="Carpentries Incubator" src="assets/images/incubator-logo.svg"><span class="badge text-bg-info">
          <abbr title="This lesson is in the beta phase, which means that it is ready for teaching by instructors outside of the original author team.">
            <a href="https://docs.carpentries.org/resources/curriculum/lesson-life-cycle.html" class="external-link alert-link">
              <i aria-hidden="true" class="icon" data-feather="alert-circle" style="border-radius: 5px"></i>
              Beta
            </a>
            <span class="visually-hidden">This lesson is in the beta phase, which means that it is ready for teaching by instructors outside of the original author team.</span>
          </abbr>
        </span>

      </div>
    </div>
    <div class="selector-container">
      <div id="theme-selector">
        <li class="nav-item dropdown" id="theme-button-list">
          <button class="btn btn-link nav-link px-0 px-lg-2 dropdown-toggle d-flex align-items-center" id="bd-theme" type="button" aria-expanded="false" data-bs-toggle="dropdown" data-bs-display="static" aria-label="Toggle theme (auto)">
            <svg class="bi my-1 theme-icon-active"><use href="#circle-half"></use></svg><i data-feather="chevron-down"></i>
          </button>
          <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="bd-theme-text">
<li>
              <button type="button" class="btn dropdown-item d-flex align-items-center" data-bs-theme-value="light" aria-pressed="false">
                <svg class="bi me-2 theme-icon"><use href="#sun-fill"></use></svg>
                Light
                <svg class="bi ms-auto d-none"><use href="#check2"></use></svg></button>
            </li>
            <li>
              <button type="button" class="btn dropdown-item d-flex align-items-center" data-bs-theme-value="dark" aria-pressed="false">
                <svg class="bi me-2 theme-icon"><use href="#moon-stars-fill"></use></svg>
                Dark
                <svg class="bi ms-auto d-none"><use href="#check2"></use></svg></button>
            </li>
            <li>
              <button type="button" class="btn dropdown-item d-flex align-items-center active" data-bs-theme-value="auto" aria-pressed="true">
                <svg class="bi me-2 theme-icon"><use href="#circle-half"></use></svg>
                Auto
                <svg class="bi ms-auto d-none"><use href="#check2"></use></svg></button>
            </li>
          </ul>
</li>
      </div>

      <div class="dropdown" id="instructor-dropdown">
        <button class="btn btn-secondary dropdown-toggle bordered-button" type="button" id="dropdownMenu1" data-bs-toggle="dropdown" aria-expanded="false">
          <i aria-hidden="true" class="icon" data-feather="eye"></i> Learner View <i data-feather="chevron-down"></i>
        </button>
        <ul class="dropdown-menu" aria-labelledby="dropdownMenu1">
<li><button class="dropdown-item" type="button" onclick="window.location.href='instructor/aio.html';">Instructor View</button></li>
        </ul>
</div>
    </div>
  </div>
  <hr></header><nav class="navbar navbar-expand-xl bottom-nav incubator" aria-label="Main Navigation"><div class="container-fluid nav-container">
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle Navigation">
      <span class="navbar-toggler-icon"></span>
      <span class="menu-title">Menu</span>
    </button>
    <div class="nav-logo">
      <img class="small-logo" alt="Carpentries Incubator" src="assets/images/incubator-logo-sm.svg">
</div>
    <div class="lesson-title-md">
      Introduction to Geospatial Raster and Vector Data with Python
    </div>
    <div class="search-icon-sm">
      <!-- TODO: do not show until we have search
        <i role="img" aria-label="Search the All In One page" data-feather="search"></i>
      -->
    </div>
    <div class="desktop-nav">
      <ul class="navbar-nav me-auto mb-2 mb-lg-0">
<li class="nav-item">
          <span class="lesson-title">
            Introduction to Geospatial Raster and Vector Data with Python
          </span>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="key-points.html">Key Points</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="reference.html#glossary">Glossary</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="profiles.html">Learner Profiles</a>
        </li>
        <li class="nav-item dropdown">
          <button class="nav-link dropdown-toggle" id="navbarDropdown" data-bs-toggle="dropdown" aria-expanded="false">
            More <i data-feather="chevron-down"></i>
          </button>
          <ul class="dropdown-menu" aria-labelledby="navbarDropdown"></ul>
</li>
      </ul>
</div>
    <!--
    <form class="d-flex col-md-2 search-form">
      <fieldset disabled>
      <input class="form-control me-2 searchbox" type="search" placeholder="" aria-label="">
        <button class="btn btn-outline-success tablet-search-button"  type="submit">
          <i class="search-icon" data-feather="search" role="img" aria-label="Search the All In One page"></i>
        </button>
      </fieldset>
    </form>
    -->
    <a id="search-button" class="btn btn-primary" href="aio.html" role="button" aria-label="Search the All In One page">Search the All In One page</a>
  </div>
<!--/div.container-fluid -->
</nav><div class="col-md-12 mobile-title">
  Introduction to Geospatial Raster and Vector Data with Python
</div>

<aside class="col-md-12 lesson-progress"><div style="width: %" class="percentage">
    %
  </div>
  <div class="progress incubator">
    <div class="progress-bar incubator" role="progressbar" style="width: %" aria-valuenow="" aria-label="Lesson Progress" aria-valuemin="0" aria-valuemax="100">
    </div>
  </div>
</aside><div class="container">
      <div class="row">
        <!-- START: inst/pkgdown/templates/navbar.html -->
<div id="sidebar-col" class="col-lg-4">
  <div id="sidebar" class="sidebar">
      <nav aria-labelledby="flush-headingEleven"><button role="button" aria-label="close menu" alt="close menu" aria-expanded="true" aria-controls="sidebar" class="collapse-toggle" data-collapse="Collapse " data-episodes="Episodes ">
          <i class="search-icon" data-feather="x" role="img"></i>
        </button>
        <div class="sidebar-inner">
          <div class="row mobile-row" id="theme-row-mobile">
            <div class="col" id="theme-selector">
              <li class="nav-item dropdown" id="theme-button-list">
                <button class="btn btn-link nav-link px-0 px-lg-2 dropdown-toggle d-flex align-items-center" id="bd-theme" type="button" aria-expanded="false" data-bs-toggle="dropdown" data-bs-display="static" aria-label="Toggle theme (auto)">
                  <svg class="bi my-1 theme-icon-active"><use href="#circle-half"></use></svg><span class="d-lg-none ms-1" id="bd-theme-text">Toggle Theme</span>
                </button>
                <ul class="dropdown-menu dropdown-menu-right" aria-labelledby="bd-theme-text">
<li>
                    <button type="button" class="btn dropdown-item d-flex align-items-center" data-bs-theme-value="light" aria-pressed="false">
                      <svg class="bi me-2 theme-icon"><use href="#sun-fill"></use></svg>
                      Light
                      <svg class="bi ms-auto d-none"><use href="#check2"></use></svg></button>
                  </li>
                  <li>
                    <button type="button" class="btn dropdown-item d-flex align-items-center" data-bs-theme-value="dark" aria-pressed="false">
                      <svg class="bi me-2 theme-icon"><use href="#moon-stars-fill"></use></svg>
                      Dark
                      <svg class="bi ms-auto d-none"><use href="#check2"></use></svg></button>
                  </li>
                  <li>
                    <button type="button" class="btn dropdown-item d-flex align-items-center active" data-bs-theme-value="auto" aria-pressed="true">
                      <svg class="bi me-2 theme-icon"><use href="#circle-half"></use></svg>
                      Auto
                      <svg class="bi ms-auto d-none"><use href="#check2"></use></svg></button>
                  </li>
                </ul>
</li>
            </div>
          </div>
          <div class="row mobile-row">
            <div class="col">
              <div class="sidenav-view-selector">
                <div class="accordion accordion-flush" id="accordionFlush9">
                  <div class="accordion-item">
                    <h2 class="accordion-header" id="flush-headingNine">
                      <button class="accordion-button collapsed" id="instructor" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseNine" aria-expanded="false" aria-controls="flush-collapseNine">
                        <i id="eye" aria-hidden="true" class="icon" data-feather="eye"></i> Learner View
                      </button>
                    </h2>
                    <div id="flush-collapseNine" class="accordion-collapse collapse" aria-labelledby="flush-headingNine" data-bs-parent="#accordionFlush2">
                      <div class="accordion-body">
                        <a href="instructor/aio.html">Instructor View</a>
                      </div>
                    </div>
                  </div>
<!--/div.accordion-item-->
                </div>
<!--/div.accordion-flush-->
              </div>
<!--div.sidenav-view-selector -->
            </div>
<!--/div.col -->

            <hr>
</div>
<!--/div.mobile-row -->

          <div class="accordion accordion-flush" id="accordionFlush11">
            <div class="accordion-item">

              <button id="chapters" class="accordion-button show" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseEleven" aria-expanded="false" aria-controls="flush-collapseEleven">
                <h2 class="accordion-header chapters" id="flush-headingEleven">
                  EPISODES
                </h2>
              </button>
              <div id="flush-collapseEleven" class="accordion-collapse show collapse" aria-labelledby="flush-headingEleven" data-bs-parent="#accordionFlush11">

                <div class="accordion-body">
                  <div class="accordion accordion-flush" id="accordionFlush1">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading1">
        <a href="index.html">Summary and Setup</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush2">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading2">
        <a href="01-intro-raster-data.html">1. Introduction to Raster Data</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush3">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading3">
        <a href="02-intro-vector-data.html">2. Introduction to Vector Data</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush4">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading4">
        <a href="03-crs.html">3. Coordinate Reference Systems</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush5">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading5">
        <a href="04-geo-landscape.html">4. The Geospatial Landscape</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush6">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading6">
        <a href="05-access-data.html">5. Access satellite imagery using Python</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush7">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading7">
        <a href="06-raster-intro.html">6. Read and visualize raster data</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush8">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading8">
        <a href="07-vector-data-in-python.html">7. Vector data in Python</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush9">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading9">
        <a href="08-crop-raster-data.html">8. Crop raster data with rioxarray and geopandas</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush10">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading10">
        <a href="09-raster-calculations.html">9. Raster Calculations in Python</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush11">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading11">
        <a href="10-zonal-statistics.html">10. Calculating Zonal Statistics on Rasters</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush12">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading12">
        <a href="11-parallel-raster-computations.html">11. Parallel raster computations using Dask</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush13">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading13">
        <a href="12-data-cube.html">12. Data cubes with ODC-STAC</a>
    </div>
<!--/div.accordion-header-->

  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

                </div>
              </div>
            </div>

            <hr class="half-width">
<div class="accordion accordion-flush lesson-resources" id="accordionFlush12">
              <div class="accordion-item">
                <h2 class="accordion-header" id="flush-headingTwelve">
                  <button class="accordion-button collapsed" id="lesson-resources" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseTwelve" aria-expanded="false" aria-controls="flush-collapseTwelve">
                    RESOURCES
                  </button>
                </h2>
                <div id="flush-collapseTwelve" class="accordion-collapse collapse" aria-labelledby="flush-headingTwelve" data-bs-parent="#accordionFlush12">
                  <div class="accordion-body">
                    <ul>
<li>
                        <a href="key-points.html">Key Points</a>
                      </li>
                      <li>
                        <a href="reference.html#glossary">Glossary</a>
                      </li>
                      <li>
                        <a href="profiles.html">Learner Profiles</a>
                      </li>

                    </ul>
</div>
                </div>
              </div>
            </div>
            <hr class="half-width lesson-resources">
<a href="aio.html">See all in one page</a>


            <hr class="d-none d-sm-block d-md-none">
<div class="d-grid gap-1">

            </div>
          </div>
<!-- /div.accordion -->
        </div>
<!-- /div.sidebar-inner -->
      </nav>
</div>
<!-- /div.sidebar -->
  </div>
<!-- /div.sidebar-col -->
<!-- END:   inst/pkgdown/templates/navbar.html-->

        <!-- START: inst/pkgdown/templates/content-extra.html -->
  <div class="col-xl-8 col-lg-12 primary-content">
    <main id="main-content" class="main-content"><div class="container lesson-content">
        
        
<section id="aio-01-intro-raster-data"><p>Content from <a href="01-intro-raster-data.html">Introduction to Raster Data</a></p>
<hr>
<p>Last updated on 2025-05-20 |

        <a href="https://github.com/carpentries-incubator/geospatial-python/edit/main/episodes/01-intro-raster-data.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>What format should I use to represent my data?</li>
<li>What are the main data types used for representing geospatial
data?</li>
<li>What are the main attributes of raster data?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Describe the difference between raster and vector data.</li>
<li>Describe the strengths and weaknesses of storing data in raster
format.</li>
<li>Distinguish between continuous and categorical raster data and
identify types of datasets that would be stored in each format.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<section><h2 class="section-heading" id="introduction">Introduction<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h2>
<hr class="half-width">
<p>This episode introduces the two primary types of data models that are
used to digitally represent the Earth surface: raster and vector. After
briefly introducing these data models, this episode focuses on the
raster representation, describing some major features and types of
raster data. This workshop will focus on how to work with both raster
and vector data sets, therefore it is essential that we understand the
basic structures of these types of data and the types of phenomena that
they can represent.</p>
</section><section><h2 class="section-heading" id="data-structures-raster-and-vector">Data Structures: Raster and Vector<a class="anchor" aria-label="anchor" href="#data-structures-raster-and-vector"></a>
</h2>
<hr class="half-width">
<p>The two primary data models that are used to represent the Earth
surface digitally are the raster and vector. <strong>Raster
data</strong> is stored as a grid of values which are rendered on a map
as pixels (also known as cells) where each pixel (or cell) represents a
value of the Earth surface. Examples of raster data are satellite images
or aerial photographs. Data stored according to the <strong>vector
data</strong> model are represented by points, lines, or polygons.
Examples of vector representation are points of interest, buildings
(often represented as building footprints) or roads.</p>
<p>Representing phenomena as vector data allows you to add attribute
information to them. For instance, a polygon of a house can contain
multiple attributes containing information about the address like the
street name, zip code, city, and number. More explanations about vector
data will be discussed in the <a href="02-intro-vector-data.html">next
episode</a>.</p>
<p>When working with spatial information, you will experience that many
phenomena can be represented as vector data and raster data. A house,
for instance, can be represented by a set of cells in a raster having
all the same value or by a polygon as vector containing attribute
information (figure 1). It depends on the purpose for which the data is
collected and intended to be used which data model it is stored in. But
as a rule of thumb, you can apply that discrete phenomena like
buildings, roads, trees, signs are represented as vector data, whereas
continuous phenomena like temperature, wind speed, elevation are
represented as raster data. Yet, one of the things a spatial data
analyst often has to do is to transform data from vector to raster or
the other way around. Keep in mind that this can cause problems in the
data quality.</p>
<div class="section level3">
<h3 id="raster-data">Raster Data<a class="anchor" aria-label="anchor" href="#raster-data"></a>
</h3>
<p>Raster data is any pixelated (or gridded) data where each pixel has a
value and is associated with a specific geographic location. The value
of a pixel can be continuous (e.g., elevation, temperature) or
categorical (e.g., land-use type). If this sounds familiar, it is
because this data structure is very common: it’s how we represent any
digital image. A geospatial raster is only different from a digital
photo in that it is accompanied by spatial information that connects the
data to a particular location. This includes the raster’s extent and
cell size, the number of rows and columns, and its Coordinate Reference
System (CRS), which will be explained in <a href="03-crs.html">episode
3</a> of this workshop.</p>
<figure><img src="fig/E01/raster_concept.png" alt="raster concept" class="figure mx-auto d-block"><div class="figcaption">Raster Concept (Source: National Ecological
Observatory Network (NEON))</div>
</figure><p>Some examples of continuous rasters include:</p>
<ol style="list-style-type: decimal">
<li>Precipitation maps.</li>
<li>Elevation maps.</li>
</ol>
<p>A map of elevation for <em>Harvard Forest</em> derived from the <a href="https://www.neonscience.org/data-collection/airborne-remote-sensing" class="external-link">NEON
AOP LiDAR sensor</a> is below. Elevation is represented as a continuous
numeric variable in this map. The legend shows the continuous range of
values in the data from around 300 to 420 meters.</p>
<figure><img src="fig/E01/continuous-elevation-HARV-plot-01.png" alt="elevation Harvard forest" class="figure mx-auto d-block"><div class="figcaption">Continuous Elevation Map: HARV Field Site</div>
</figure><p>Some rasters contain categorical data where each pixel represents a
discrete class such as a landcover type (e.g., “forest” or “grassland”)
rather than a continuous value such as elevation or temperature. Some
examples of classified maps include:</p>
<ol style="list-style-type: decimal">
<li>Landcover / land-use maps.</li>
<li>Elevation maps classified as low, medium, and high elevation.</li>
</ol>
<figure><img src="fig/E01/USA_landcover_classification.png" alt="USA landcover classification" class="figure mx-auto d-block"><div class="figcaption">USA landcover classification</div>
</figure><p>The map above shows the contiguous United States with landcover as
categorical data. Each color is a different landcover category. (Source:
Homer, C.G., et al., 2015, Completion of the 2011 National Land Cover
Database for the conterminous United States-Representing a decade of
land cover change information. Photogrammetric Engineering and Remote
Sensing, v. 81, no. 5, p. 345-354)</p>
<div id="advantages-and-disadvantages" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="advantages-and-disadvantages" class="callout-inner">
<h3 class="callout-title">Advantages and Disadvantages</h3>
<div class="callout-content">
<p>With your neighbor, brainstorm potential advantages and disadvantages
of storing data in raster format. Add your ideas to the Etherpad. The
Instructor will discuss and add any points that weren’t brought up in
the small group discussions.</p>
</div>
</div>
</div>
<div id="accordionSolution1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution1" aria-expanded="false" aria-controls="collapseSolution1">
  <h4 class="accordion-header" id="headingSolution1"> Show me the solution </h4>
</button>
<div id="collapseSolution1" class="accordion-collapse collapse" aria-labelledby="headingSolution1" data-bs-parent="#accordionSolution1">
<div class="accordion-body">
<p>Raster data has some important advantages:</p>
<ul>
<li>representation of continuous surfaces</li>
<li>potentially very high levels of detail</li>
<li>data is ‘unweighted’ across its extent - the geometry doesn’t
implicitly highlight features</li>
<li>cell-by-cell calculations can be very fast and efficient</li>
</ul>
<p>The downsides of raster data are:</p>
<ul>
<li>very large file sizes as cell size gets smaller</li>
<li>currently popular formats don’t embed metadata well (more on this
later!)</li>
<li>can be difficult to represent complex information</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="section level3">
<h3 id="important-attributes-of-raster-data">Important Attributes of Raster Data<a class="anchor" aria-label="anchor" href="#important-attributes-of-raster-data"></a>
</h3>
<div class="section level4">
<h4 id="extent">Extent<a class="anchor" aria-label="anchor" href="#extent"></a>
</h4>
<p>The spatial extent is the geographic area that the raster data
covers. The spatial extent of an object represents the geographic edge
or location that is the furthest north, south, east and west. In other
words, extent represents the overall geographic coverage of the spatial
object.</p>
<figure><img src="fig/E01/spatial_extent.png" alt="spatial extent objects" class="figure mx-auto d-block"><div class="figcaption">Spatial extent image (Image Source: National
Ecological Observatory Network (NEON))</div>
</figure><div id="extent-challenge" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="extent-challenge" class="callout-inner">
<h3 class="callout-title">Extent Challenge</h3>
<div class="callout-content">
<p>In the image above, the dashed boxes around each set of objects seems
to imply that the three objects have the same extent. Is this accurate?
If not, which object(s) have a different extent?</p>
</div>
</div>
</div>
<div id="accordionSolution2" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution2" aria-expanded="false" aria-controls="collapseSolution2">
  <h4 class="accordion-header" id="headingSolution2"> Show me the solution </h4>
</button>
<div id="collapseSolution2" class="accordion-collapse collapse" aria-labelledby="headingSolution2" data-bs-parent="#accordionSolution2">
<div class="accordion-body">
<p>The lines and polygon objects have the same extent. The extent for
the points object is smaller in the vertical direction than the other
two because there are no points on the line at y = 8.</p>
</div>
</div>
</div>
</div>
</div>
<div class="section level4">
<h4 id="resolution">Resolution<a class="anchor" aria-label="anchor" href="#resolution"></a>
</h4>
<p>A resolution of a raster represents the area on the ground that each
pixel of the raster covers. The image below illustrates the effect of
changes in resolution.</p>
<figure><img src="fig/E01/raster_resolution.png" alt="resolution image" class="figure mx-auto d-block"><div class="figcaption">Resolution image (Source: National Ecological
Observatory Network (NEON))</div>
</figure>
</div>
</div>
<div class="section level3">
<h3 id="raster-data-format-for-this-workshop">Raster Data Format for this Workshop<a class="anchor" aria-label="anchor" href="#raster-data-format-for-this-workshop"></a>
</h3>
<p>Raster data can come in many different formats. For this workshop, we
will use one of the most common formats for raster data, i.e. the
GeoTIFF format, which has the extension <code>.tif</code>. A
<code>.tif</code> file stores metadata or attributes about the file as
embedded <code>tif tags</code>. For instance, your camera might store a
tag that describes the make and model of the camera or the date the
photo was taken when it saves a <code>.tif</code>. A GeoTIFF is a
standard <code>.tif</code> image format with additional spatial
(georeferencing) information embedded in the file as tags. These tags
include the following raster metadata:</p>
<ol style="list-style-type: decimal">
<li>Extent</li>
<li>Resolution</li>
<li>Coordinate Reference System (CRS) - we will introduce this concept
in <a href="03-crs.html">a later episode</a>
</li>
<li>Values that represent missing data (<code>NoDataValue</code>) - we
will introduce this concept in <a href="06-raster-intro.html">a later
episode</a>.</li>
</ol>
<p>We will discuss these attributes in more detail in <a href="06-raster-intro.html">a later episode</a>. In that episode, we
will also learn how to use Python to extract raster attributes from a
GeoTIFF file.</p>
<div id="more-resources-on-the-.tif-format" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div id="more-resources-on-the-.tif-format" class="callout-inner">
<h3 class="callout-title">More Resources on the <code>.tif</code>
format</h3>
<div class="callout-content">
<ul>
<li><a href="https://en.wikipedia.org/wiki/GeoTIFF" class="external-link">GeoTIFF on
Wikipedia</a></li>
<li><a href="https://trac.osgeo.org/geotiff/" class="external-link">OSGEO TIFF
documentation</a></li>
</ul>
</div>
</div>
</div>
</div>
<div class="section level3">
<h3 id="multi-band-raster-data">Multi-band Raster Data<a class="anchor" aria-label="anchor" href="#multi-band-raster-data"></a>
</h3>
<p>A raster can contain one or more bands. One type of multi-band raster
dataset that is familiar to many of us is a color image. A basic color
image often consists of three bands: red, green, and blue (RGB). Each
band represents light reflected from the red, green or blue portions of
the electromagnetic spectrum. The pixel brightness for each band, when
composited creates the colors that we see in an image.</p>
<figure><img src="fig/E01/RGBSTack_1.jpg" alt="multi-band raster" class="figure mx-auto d-block"><div class="figcaption">RGB multi-band raster image (Source: National
Ecological Observatory Network (NEON).)</div>
</figure><p>We can plot each band of a multi-band image individually.</p>
<p>Or we can composite all three bands together to make a color
image.</p>
<p>In a multi-band dataset, the rasters will always have the same
extent, resolution, and CRS.</p>
<div id="other-types-of-multi-band-raster-data" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div id="other-types-of-multi-band-raster-data" class="callout-inner">
<h3 class="callout-title">Other Types of Multi-band Raster Data</h3>
<div class="callout-content">
<p>Multi-band raster data might also contain: 1. <strong>Time
series:</strong> the same variable, over the same area, over time. 2.
<strong>Multi or hyperspectral imagery:</strong> image rasters that have
4 or more (multi-spectral) or more than 10-15 (hyperspectral) bands. We
won’t be working with this type of data in this workshop, but you can
check out the NEON Data Skills <a href="https://www.neonscience.org/hsi-hdf5-r" class="external-link">Imaging Spectroscopy HDF5
in R</a> tutorial if you’re interested in working with hyperspectral
data cubes.</p>
</div>
</div>
</div>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Key Points</h3>
<div class="callout-content">
<ul>
<li>Raster data is pixelated data where each pixel is associated with a
specific location.</li>
<li>Raster data always has an extent and a resolution.</li>
<li>The extent is the geographical area covered by a raster.</li>
<li>The resolution is the area covered by each pixel of a raster.</li>
</ul>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</div>
</section></section><section id="aio-02-intro-vector-data"><p>Content from <a href="02-intro-vector-data.html">Introduction to Vector Data</a></p>
<hr>
<p>Last updated on 2025-05-20 |

        <a href="https://github.com/carpentries-incubator/geospatial-python/edit/main/episodes/02-intro-vector-data.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>What are the main attributes of vector data?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Describe the strengths and weaknesses of storing data in vector
format.</li>
<li>Describe the three types of vectors and identify types of data that
would be stored in each.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<section><h2 class="section-heading" id="about-vector-data">About Vector Data<a class="anchor" aria-label="anchor" href="#about-vector-data"></a>
</h2>
<hr class="half-width">
<p>Vector data structures represent specific features on the Earth’s
surface, and assign attributes to those features. Vectors are composed
of discrete geometric locations (x, y values) known as vertices that
define the shape of the spatial object. The organization of the vertices
determines the type of vector that we are working with: point, line or
polygon.</p>
<figure><img src="fig/E02/pnt_line_poly.png" alt="vector data types" class="figure mx-auto d-block"><div class="figcaption">Types of vector objects (Image Source: National
Ecological Observatory Network (NEON))</div>
</figure><ul>
<li><p><strong>Points:</strong> Each point is defined by a single x, y
coordinate. There can be many points in a vector point file. Examples of
point data include: sampling locations, the location of individual
trees, or the location of survey plots.</p></li>
<li><p><strong>Lines:</strong> Lines are composed of many (at least 2)
points that are connected. For instance, a road or a stream may be
represented by a line. This line is composed of a series of segments,
each “bend” in the road or stream represents a vertex that has a defined
x, y location.</p></li>
<li><p><strong>Polygons:</strong> A polygon consists of 3 or more
vertices that are connected and closed. The outlines of survey plot
boundaries, lakes, oceans, and states or countries are often represented
by polygons. Note, that polygons can also contain one or multiple holes,
for instance a plot boundary with a lake in it. These polygons are
considered <em>complex</em> or <em>donut</em> polygons.</p></li>
</ul>
<div id="data-tip" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div id="data-tip" class="callout-inner">
<h3 class="callout-title">Data Tip</h3>
<div class="callout-content">
<p>Sometimes, boundary layers such as states and countries, are stored
as lines rather than polygons. However, these boundaries, when
represented as a line, will not create a closed object with a defined
area that can be filled.</p>
</div>
</div>
</div>
<div id="identify-vector-types" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="identify-vector-types" class="callout-inner">
<h3 class="callout-title">Identify Vector Types</h3>
<div class="callout-content">
<p>The plot below includes examples of two of the three types of vector
objects. Use the definitions above to identify which features are
represented by which vector type.</p>
<figure><img src="fig/E02/vector_types_examples.png" alt="vector type examples" class="figure mx-auto d-block"><div class="figcaption">Vector Type Examples</div>
</figure>
</div>
</div>
</div>
<div id="accordionSolution1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution1" aria-expanded="false" aria-controls="collapseSolution1">
  <h4 class="accordion-header" id="headingSolution1"> Show me the solution </h4>
</button>
<div id="collapseSolution1" class="accordion-collapse collapse" aria-labelledby="headingSolution1" data-bs-parent="#accordionSolution1">
<div class="accordion-body">
<p>State boundaries are shown as polygons. The Fisher Tower location is
represented by a purple point. There are no line features shown. Note,
that at a different scale the Fischer Tower coudl also have been
represented as a polygon. Keep in mind that the purpose for which the
dataset is created and aimed to be used for determines which vector type
it uses.</p>
</div>
</div>
</div>
</div>
<p>Vector data has some important advantages:</p>
<ul>
<li>The geometry itself contains information about what the dataset
creator thought was important</li>
<li>The geometry structures hold information in themselves - why choose
point over polygon, for instance?</li>
<li>Each geometry feature can carry multiple attributes instead of just
one, e.g. a database of cities can have attributes for name, country,
population, etc</li>
<li>Data storage can, depending on the scale, be very efficient compared
to rasters</li>
<li>When working with network analysis, for instance to calculate the
shortest route between A and B, topologically correct lines are
essential. This is not possible through raster data.</li>
</ul>
<p>The downsides of vector data include:</p>
<ul>
<li>Potential bias in datasets - what didn’t get recorded? Often vector
data are interpreted datasets like topographical maps and have been
collected by someone else, for another purpose.</li>
<li>Calculations involving multiple vector layers need to do math on the
geometry as well as the attributes, which potentially can be slow
compared to raster calculations.</li>
</ul>
<p>Vector datasets are in use in many industries besides geospatial
fields. For instance, computer graphics are largely vector-based,
although the data structures in use tend to join points using arcs and
complex curves rather than straight lines. Computer-aided design (CAD)
is also vector- based. The difference is that geospatial datasets are
accompanied by information tying their features to real-world
locations.</p>
</section><section><h2 class="section-heading" id="vector-data-format-for-this-workshop">Vector Data Format for this Workshop<a class="anchor" aria-label="anchor" href="#vector-data-format-for-this-workshop"></a>
</h2>
<hr class="half-width">
<p>Like raster data, vector data can also come in many different
formats. For this workshop, we will use the GeoPackage format.
GeoPackage is developed by the <a href="https://www.ogc.org/" class="external-link">Open
Geospatial Consortium</a> and is <em>is an open, standards-based,
platform-independent, portable, self-describing, compact format for
transferring geospatial information</em> (source: <a href="https://www.geopackage.org/" class="external-link">https://www.geopackage.org/</a>). A
GeoPackage file, with extension <strong>.gpkg</strong>, is a single file
that contains the geometries of features, their attributes and
information about the coordinate reference system (CRS) used.</p>
<p>Another vector format that you will probably come accross quite often
is a Shapefile. Although we will not be using this format in this lesson
we do believe it is useful to understand how the Shapefile format works.
Shapefile is a multi-file format, with each shapefile consisting of
multiple files in the same directory, of which <code>.shp</code>,
<code>.shx</code>, and <code>.dbf</code> files are mandatory. Other
non-mandatory but very important files are <code>.prj</code> and
<code>shp.xml</code> files.</p>
<ul>
<li>The <code>.shp</code> file stores the feature geometry itself</li>
<li>
<code>.shx</code> is a positional index of the feature geometry to
allow quickly searching forwards and backwards the geographic
coordinates of each vertex in the vector</li>
<li>
<code>.dbf</code> contains the tabular attributes for each
shape.</li>
<li>
<code>.prj</code> file indicates the Coordinate reference system
(CRS)</li>
<li>
<code>.shp.xml</code> contains the Shapefile metadata.</li>
</ul>
<p>Together, the Shapefile includes the following information:</p>
<ul>
<li>
<strong>Extent</strong> - the spatial extent of the shapefile
(i.e. geographic area that the shapefile covers). The spatial extent for
a shapefile represents the combined extent for all spatial objects in
the shapefile.</li>
<li>
<strong>Object type</strong> - whether the shapefile includes
points, lines, or polygons.</li>
<li><strong>Coordinate reference system (CRS)</strong></li>
<li>
<strong>Other attributes</strong> - for example, a line shapefile
that contains the locations of streams, might contain the name of each
stream.</li>
</ul>
<p>Because the structure of points, lines, and polygons are different,
each individual shapefile can only contain one vector type (all points,
all lines or all polygons). You will not find a mixture of point, line
and polygon objects in a single shapefile.</p>
<div id="more-resources-on-shapefiles" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div id="more-resources-on-shapefiles" class="callout-inner">
<h3 class="callout-title">More Resources on Shapefiles</h3>
<div class="callout-content">
<p>More about shapefiles can be found on <a href="https://en.wikipedia.org/wiki/Shapefile" class="external-link">Wikipedia.</a> Shapefiles
are often publicly available from government services, such as <a href="https://gadm.org/download_country.html" class="external-link">this page containing all
administrative boundaries for countries in the world</a> or <a href="https://download.geofabrik.de/" class="external-link">topographical vector data from
Open Street Maps</a>.</p>
</div>
</div>
</div>
<div id="why-not-both" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div id="why-not-both" class="callout-inner">
<h3 class="callout-title">Why not both?</h3>
<div class="callout-content">
<p>Very few formats can contain both raster and vector data - in fact,
most are even more restrictive than that. Vector datasets are usually
locked to one geometry type, e.g. points only. Raster datasets can
usually only encode one data type, for example you can’t have a
multiband GeoTIFF where one layer is integer data and another is
floating-point. There are sound reasons for this - format standards are
easier to define and maintain, and so is metadata. The effects of
particular data manipulations are more predictable if you are confident
that all of your input data has the same characteristics.</p>
</div>
</div>
</div>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Key Points</h3>
<div class="callout-content">
<ul>
<li>Vector data structures represent specific features on the Earth’s
surface along with attributes of those features.</li>
<li>Vector data is often interpreted data and collected for a different
purpose than you would want to use it for.</li>
<li>Vector objects are either points, lines, or polygons.</li>
</ul>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</section></section><section id="aio-03-crs"><p>Content from <a href="03-crs.html">Coordinate Reference Systems</a></p>
<hr>
<p>Last updated on 2025-05-20 |

        <a href="https://github.com/carpentries-incubator/geospatial-python/edit/main/episodes/03-crs.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>What is a coordinate reference system and how do I interpret
one?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Name some common schemes for describing coordinate reference
systems.</li>
<li>Interpret a PROJ4 coordinate reference system description.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<section><h2 class="section-heading" id="coordinate-reference-systems">Coordinate Reference Systems<a class="anchor" aria-label="anchor" href="#coordinate-reference-systems"></a>
</h2>
<hr class="half-width">
<p>A data structure cannot be considered geospatial unless it is
accompanied by coordinate reference system (CRS) information, in a
format that geospatial applications can use to display and manipulate
the data correctly. CRS information connects data to the Earth’s surface
using a mathematical model.</p>
<div id="crs-vs-srs" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div id="crs-vs-srs" class="callout-inner">
<h3 class="callout-title">CRS vs SRS</h3>
<div class="callout-content">
<p>CRS (coordinate reference system) and SRS (spatial reference system)
are synonyms and are commonly interchanged. We will use only CRS
throughout this workshop.</p>
</div>
</div>
</div>
<p>The CRS associated with a dataset tells your mapping software where
the raster is located in geographic space. It also tells the mapping
software what method should be used to flatten or project the raster in
geographic space.</p>
<p>The image below (figure 3.1) shows maps of the United States in
different projections. Notice the differences in shape associated with
each projection. These differences are a direct result of the
calculations used to flatten the data onto a 2-dimensional map.</p>
<figure><img src="https://media.opennews.org/cache/06/37/0637aa2541b31f526ad44f7cb2db7b6c.jpg" alt="US difference projections" class="figure mx-auto d-block"><div class="figcaption">Figure 3.1: Maps of the United States in
different projections (Source: opennews.org)</div>
</figure><p>There are lots of great resources that describe coordinate reference
systems and projections in greater detail. For the purposes of this
workshop, what is important to understand is that data from the same
location but saved in different projections will not line up. Thus, it
is important when working with spatial data to identify the coordinate
reference system applied to the data and retain it throughout data
processing and analysis.</p>
</section><section><h2 class="section-heading" id="components-of-a-crs">Components of a CRS<a class="anchor" aria-label="anchor" href="#components-of-a-crs"></a>
</h2>
<hr class="half-width">
<p>CRS information has three components:</p>
<ul>
<li><p><strong>Datum:</strong> A model of the shape of the earth. It has
angular units (i.e. degrees) and defines the starting point (i.e. where
is [0,0]?) so the angles reference a meaningful spot on the earth.
Common global datums are WGS84 and NAD83. Datums can also be local - fit
to a particular area of the globe, but ill-fitting outside the area of
intended use. For instance local cadastre, land registry and mapping
agencies require a high quality for their datasets, which can be
obtained using a local system. In this lesson, we will use the <a href="https://www.linz.govt.nz/data/geodetic-system/datums-projections-and-heights/geodetic-datums/world-geodetic-system-1984-wgs84" class="external-link">WGS84
datum</a>. The datum is often also refered to as the Geographical
Coordinate System.</p></li>
<li><p><strong>Projection:</strong> A mathematical transformation of the
angular measurements on a round earth to a flat surface (i.e. paper or a
computer screen). The units associated with a given projection are
usually linear (feet, meters, etc.). In this workshop, we will see data
in two different projections. Note that the projection is also often
referred to as Projected Coordinate System.</p></li>
<li><p><strong>Additional Parameters:</strong> Additional parameters are
often necessary to create the full coordinate reference system. One
common additional parameter is a definition of the center of the map.
The number of required additional parameters depends on what is needed
by each specific projection.</p></li>
</ul>
<div id="orange-peel-analogy" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<div id="orange-peel-analogy" class="callout-inner">
<h3 class="callout-title">Orange Peel Analogy</h3>
<div class="callout-content">
<p>A common analogy employed to teach projections is the orange peel
analogy. If you imagine that the Earth is an orange, how you peel it and
then flatten the peel is similar to how projections get made.</p>
<ul>
<li>A datum is the choice of fruit to use. Is the Earth an orange, a
lemon, a lime, a grapefruit?</li>
</ul>
<figure><img src="fig/E03/citrus.jpg" alt="datum fruit example" class="figure mx-auto d-block"><div class="figcaption">Datum Fruit Example (<a href="https://github.com/MicheleTobias/R-Projections-Workshop" class="external-link">Image
source</a>)</div>
</figure><p>A projection is how you peel your orange and then flatten the
peel.</p>
<figure><img src="fig/E03/orange-peel-earth.jpg" alt="projection citrus peel" class="figure mx-auto d-block"><div class="figcaption">Projection Citrus Peel Example (Image from Prof
Drika Geografia, Projeções Cartográficas)</div>
</figure><ul>
<li>An additional parameter could include a definition of the location
of the stem of the fruit. What other parameters could be included in
this analogy?</li>
</ul>
</div>
</div>
</div>
</section><section><h2 class="section-heading" id="which-projection-should-i-use">Which projection should I use?<a class="anchor" aria-label="anchor" href="#which-projection-should-i-use"></a>
</h2>
<hr class="half-width">
<p>A well know projection is the <a href="https://en.wikipedia.org/wiki/Mercator_projection" class="external-link">Mercator
projection</a> introduced by the Flemisch cartographer Gerardus Mercator
in the 16th Century. This is a so-called cilindrical projection, meaning
that a virtual cilinder is placed around the globe to flatten it. This
type of projections are relatively accurate near to the equator, but
towards the poles blows things up (more info on cylindrical projections
<a href="https://gisgeography.com/cylindrical-projection/" class="external-link">here</a>. The
main advantage of the Mercator projection is that it is very suitable
for navigation purposes since it always shows North as <em>up</em> and
South and as <em>down</em> - in the 17th century this projection was
essential for sailors to navigate the oceans.</p>
<p>To decide if a projection is right for your data, answer these
questions:</p>
<ul>
<li>What is the area of minimal distortion?</li>
<li>What aspect of the data does it preserve?</li>
</ul>
<p><a href="https://foote.geography.uconn.edu/gcraft/notes/mapproj/mapproj_f.html" class="external-link">Peter
Dana from the University of Colorado at Boulder</a> and the <a href="https://kartoweb.itc.nl/geometrics/Map%20projections/mappro.html" class="external-link">Department
of Geo-Information Processing</a> have a good discussion of these
aspects of projections. Online tools like <a href="https://projectionwizard.org/" class="external-link">Projection Wizard</a> can also help
you discover projections that might be a good fit for your data.</p>
<div id="data-tip" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div id="data-tip" class="callout-inner">
<h3 class="callout-title">Data Tip</h3>
<div class="callout-content">
<p>Take the time to identify a projection that is suited for your
project. You don’t have to stick to the ones that are popular.</p>
</div>
</div>
</div>
</section><section><h2 class="section-heading" id="describing-coordinate-reference-systems">Describing Coordinate Reference Systems<a class="anchor" aria-label="anchor" href="#describing-coordinate-reference-systems"></a>
</h2>
<hr class="half-width">
<p>There are several common systems in use for storing and transmitting
CRS information, as well as translating among different CRSs. These
systems generally comply with ISO 19111. Common systems for describing
CRSs include EPSG, OGC WKT, and PROJ strings.</p>
<div class="section level3">
<h3 id="epsg">EPSG<a class="anchor" aria-label="anchor" href="#epsg"></a>
</h3>
<p>The <a href="https://epsg.org/home.html" class="external-link">EPSG system</a> is a
database of CRS information maintained by the International Association
of Oil and Gas Producers. The dataset contains both CRS definitions and
information on how to safely convert data from one CRS to another. Using
EPSG is easy as every CRS has an integer identifier, e.g. WGS84 is
EPSG:4326. The downside is that you can only use the CRSs defined by
EPSG and cannot customise them (some datasets do not have EPSG codes).
<a href="https://epsg.io/" class="external-link">epsg.io</a> is an excellent website for
finding suitable projections by location or for finding information
about a particular EPSG code.</p>
</div>
<div class="section level3">
<h3 id="well-known-text">Well-Known Text<a class="anchor" aria-label="anchor" href="#well-known-text"></a>
</h3>
<p>The Open Geospatial Consortium WKT standard is used by a number of
important geospatial apps and software libraries. WKT is a nested list
of geodetic parameters. The structure of the information is <a href="https://www.opengeospatial.org/standards/wkt-crs" class="external-link">defined on their
website</a>. WKT is valuable in that the CRS information is more
transparent than in EPSG, but can be more difficult to read and compare
than PROJ since it is meant to necessarily represent more complex CRS
information. Additionally, the WKT standard is implemented
inconsistently across various software platforms, and the spec itself
has <a href="https://gdal.org/tutorials/wktproblems.html" class="external-link">some known
issues</a>.</p>
</div>
<div class="section level3">
<h3 id="proj">PROJ<a class="anchor" aria-label="anchor" href="#proj"></a>
</h3>
<p><a href="https://proj4.org/" class="external-link">PROJ</a> is an open-source library for
storing, representing and transforming CRS information. PROJ strings
continue to be used, but the format <a href="https://proj.org/faq.html#what-is-the-best-format-for-describing-coordinate-reference-systems" class="external-link">is
deprecated by the PROJ C maintainers</a> due to inaccuracies when
converting to the WKT format. The data and python libraries we will be
working with in this workshop use different underlying representations
of CRSs under the hood for reprojecting. CRS information can still be
represented with EPSG, WKT, or PROJ strings without consequence, but
<strong>it is best to only use PROJ strings as a format for viewing CRS
information, not for reprojecting data</strong>.</p>
<p>PROJ represents CRS information as a text string of key-value pairs,
which makes it easy to read and interpret.</p>
<p>A PROJ4 string includes the following information:</p>
<ul>
<li>
<strong>proj:</strong> the projection of the data</li>
<li>
<strong>zone:</strong> the zone of the data (this is specific to the
UTM projection)</li>
<li>
<strong>datum:</strong> the datum used</li>
<li>
<strong>units:</strong> the units for the coordinates of the
data</li>
<li>
<strong>ellps:</strong> the ellipsoid (how the earth’s roundness is
calculated) for the data</li>
</ul>
<p>Note that the zone is unique to the UTM projection. Not all CRSs will
have a zone.</p>
<figure><img src="fig/E03/Utm-zones-USA.svg" alt="UTM zones across the CONUS" class="figure mx-auto d-block"><div class="figcaption">The UTM zones across the continental United
States (Chrismurf at English Wikipedia, via <a href="https://en.wikipedia.org/wiki/Universal_Transverse_Mercator_coordinate_system#/media/File:Utm-zones-USA.svg" class="external-link">Wikimedia
Commons</a> (CC-BY))</div>
</figure><div id="reading-a-proj4-string" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="reading-a-proj4-string" class="callout-inner">
<h3 class="callout-title">Reading a PROJ4 String</h3>
<div class="callout-content">
<p>Here is a PROJ4 string for one of the datasets we will use in this
workshop:</p>
<p><code>+proj=utm +zone=18 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0</code></p>
<ul>
<li>What projection, zone, datum, and ellipsoid are used for this
data?</li>
<li>What are the units of the data?</li>
<li>Using the map above, what part of the United States was this data
collected from?</li>
</ul>
</div>
</div>
</div>
<div id="accordionSolution1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution1" aria-expanded="false" aria-controls="collapseSolution1">
  <h4 class="accordion-header" id="headingSolution1"> Show me the solution </h4>
</button>
<div id="collapseSolution1" class="accordion-collapse collapse" data-bs-parent="#accordionSolution1" aria-labelledby="headingSolution1">
<div class="accordion-body">
<ul>
<li>Projection is UTM, zone 18, datum is WGS84, ellipsoid is WGS84.</li>
<li>The data is in meters.</li>
<li>The data comes from the eastern US seaboard.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
</section><section><h2 class="section-heading" id="format-interoperability">Format interoperability<a class="anchor" aria-label="anchor" href="#format-interoperability"></a>
</h2>
<hr class="half-width">
<p>Many existing file formats were invented by GIS software developers,
often in a closed-source environment. This led to the large number of
formats on offer today, and considerable problems transferring data
between software environments. The <a href="https://www.gdal.org/" class="external-link">Geospatial Data Abstraction Library</a>
(GDAL) is an open-source answer to this issue.</p>
<p>GDAL is a set of software tools that translate between almost any
geospatial format in common use today (and some not so common ones).
GDAL also contains tools for editing and manipulating both raster and
vector files, including reprojecting data to different CRSs. GDAL can be
used as a standalone command-line tool, or built in to other GIS
software. Several open-source GIS programs use GDAL for all file
import/export operations.</p>
</section><section><h2 class="section-heading" id="metadata">Metadata<a class="anchor" aria-label="anchor" href="#metadata"></a>
</h2>
<hr class="half-width">
<p>Spatial data is useless without metadata. Essential metadata includes
the CRS information, but proper spatial metadata encompasses more than
that. History and provenance of a dataset (how it was made), who is in
charge of maintaining it, and appropriate (and inappropriate!) use cases
should also be documented in metadata. This information should accompany
a spatial dataset wherever it goes. In practice this can be difficult,
as many spatial data formats don’t have a built-in place to hold this
kind of information. Metadata often has to be stored in a companion
file, and generated and maintained manually.</p>
<div id="more-resources-on-crs" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div id="more-resources-on-crs" class="callout-inner">
<h3 class="callout-title">More Resources on CRS</h3>
<div class="callout-content">
<ul>
<li>
<a href="https://spatialreference.org/ref/epsg/" class="external-link">spatialreference.org</a> -
A comprehensive online library of CRS information.</li>
<li><a href="https://docs.qgis.org/2.18/en/docs/gentle_gis_introduction/coordinate_reference_systems.html" class="external-link">QGIS
Documentation - CRS Overview.</a></li>
<li><a href="https://source.opennews.org/en-US/learning/choosing-right-map-projection/" class="external-link">Choosing
the Right Map Projection.</a></li>
<li>
<a href="https://www.youtube.com/embed/KUF_Ckv8HbE" class="external-link">Video</a>
highlighting how map projections can make continents seems
proportionally larger or smaller than they actually are.</li>
<li>
<a href="https://www.thetruesize.com/" class="external-link">The True size</a> An
intuitive webmap that allows you to compare the actual size of countries
by dragging them to another place in the webmercator projection.</li>
</ul>
</div>
</div>
</div>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Key Points</h3>
<div class="callout-content">
<ul>
<li>All geospatial datasets (raster and vector) are associated with a
specific coordinate reference system.</li>
<li>A coordinate reference system includes datum, projection, and
additional parameters specific to the dataset.</li>
<li>All maps are distorted because of the projection.</li>
</ul>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</section></section><section id="aio-04-geo-landscape"><p>Content from <a href="04-geo-landscape.html">The Geospatial Landscape</a></p>
<hr>
<p>Last updated on 2025-05-20 |

        <a href="https://github.com/carpentries-incubator/geospatial-python/edit/main/episodes/04-geo-landscape.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>What programs and applications are available for working with
geospatial data?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Describe the difference between various approaches to geospatial
computing, and their relative strengths and weaknesses.</li>
<li>Name some commonly used GIS applications.</li>
<li>Name some commonly used Python packages that can access and process
spatial data.</li>
<li>Describe pros and cons for working with geospatial data using a
command-line versus a graphical user interface.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<section><h2 class="section-heading" id="standalone-software-packages">Standalone Software Packages<a class="anchor" aria-label="anchor" href="#standalone-software-packages"></a>
</h2>
<hr class="half-width">
<p>Most traditional GIS work is carried out in standalone applications
that aim to provide end-to-end geospatial solutions. These applications
are available under a wide range of licenses and price points. Some of
the most common are listed below.</p>
<div class="section level3">
<h3 id="open-source-software">Open-source software<a class="anchor" aria-label="anchor" href="#open-source-software"></a>
</h3>
<p>The <a href="https://www.osgeo.org/" class="external-link">Open Source Geospatial
Foundation (OSGEO)</a> supports several actively managed GIS
platforms:</p>
<ul>
<li>
<a href="https://www.qgis.org/en/site/" class="external-link">QGIS</a> is a professional
GIS application that is built on top of and proud to be itself Free and
Open Source Software (FOSS). QGIS is written in Python and C++, has a
python console interface, allows to develop plugins and has several
interfaces written in R including <a href="https://cran.r-project.org/package=RQGIS" class="external-link">RQGIS</a>.</li>
<li>
<a href="https://grass.osgeo.org/" class="external-link">GRASS GIS</a>, commonly referred
to as GRASS (Geographic Resources Analysis Support System), is a
FOSS-GIS software suite used for geospatial data management and
analysis, image processing, graphics and maps production, spatial
modeling, and visualization. GRASS GIS is currently used in academic and
commercial settings around the world, as well as by many governmental
agencies and environmental consulting companies. It is a founding member
of the Open Source Geospatial Foundation (OSGeo). GRASS GIS can be
installed along with and made accessible within QGIS 3.</li>
<li>
<a href="https://www.gdal.org/" class="external-link">GDAL</a> is a multiplatform set of
tools for translating between geospatial data formats. It can also
handle reprojection and a variety of geoprocessing tasks. GDAL is built
in to many applications both FOSS and commercial, including GRASS and
QGIS.</li>
<li>
<a href="https://www.saga-gis.org/en/index.html" class="external-link">SAGA-GIS</a>, or
System for Automated Geoscientific Analyses, is a FOSS-GIS application
developed by a small team of researchers from the Dept. of Physical
Geography, Göttingen, and the Dept. of Physical Geography, Hamburg. SAGA
has been designed for an easy and effective implementation of spatial
algorithms, offers a comprehensive, growing set of geoscientific
methods, provides an easily approachable user interface with many
visualisation options, and runs under Windows and Linux operating
systems. Like GRASS GIS, it can also be installed and made accessible in
QGIS3.</li>
<li>
<a href="https://postgis.net/" class="external-link">PostGIS</a> is a geospatial extension
to the PostGreSQL relational database and is especially suited to work
with large vector datasets.</li>
<li>
<a href="https://geodms.nl/" class="external-link">GeoDMS</a> is a powerful Open Source
GIS software which allows for fast calculations and calculations with
large datasets. Furthermore it allows for complex scenario
analyses.</li>
</ul>
</div>
<div class="section level3">
<h3 id="commercial-software">Commercial software<a class="anchor" aria-label="anchor" href="#commercial-software"></a>
</h3>
<ul>
<li>
<a href="https://www.esri.com/en-us/home" class="external-link">ESRI (Environmental
Systems Research Institute)</a> is an international supplier of
geographic information system (GIS) software, web GIS and geodatabase
management applications. ESRI provides several licenced platforms for
performing GIS, including <a href="https://www.arcgis.com/home/index.html" class="external-link">ArcGIS</a>, <a href="https://www.esri.com/software/arcgis/arcgisonline" class="external-link">ArcGIS
Online</a>, and <a href="https://server.arcgis.com/en/portal/" class="external-link">Portal
for ArcGIS</a> a standalone version of ArGIS Online which you host
locally. ESRI welcomes development on their platforms through their <a href="https://developers.arcgis.com/" class="external-link">DevLabs</a>. ArcGIS software can
be installed using <a href="https://github.com/Esri/arcgis-cookbook" class="external-link">Chef Cookbooks from
Github</a>. In addition, ESRI offers the <a href="https://pro.arcgis.com/en/pro-app/latest/arcpy/get-started/what-is-arcpy-.htm" class="external-link">ArcPy
Python library</a> as part of an ArcGIS Pro licence, allowing to
translate operations in the ArcGIS Pro GUI to Python scripts.</li>
<li>Pitney Bowes produce <a href="https://www.pitneybowes.com/us/location-intelligence/geographic-information-systems/mapinfo-pro.html" class="external-link">MapInfo
Professional</a>, which was one of the earliest desktop GIS programs on
the market.</li>
<li>
<a href="https://www.hexagongeospatial.com/products/products" class="external-link">Hexagon
Geospatial Power Portfolio</a> includes many geospatial tools including
ERDAS Imagine, powerful software for remote sensing.</li>
<li>
<a href="https://www.manifold.net/" class="external-link">Manifold</a> is a desktop GIS
that emphasizes speed through the use of parallel and GPU
processing.</li>
</ul>
</div>
<div class="section level3">
<h3 id="online-cloud-computing">Online + Cloud computing<a class="anchor" aria-label="anchor" href="#online-cloud-computing"></a>
</h3>
<ul>
<li>
<a href="https://pangeo.io/" class="external-link">PANGEO</a> is a community organization
dedicated to open and reproducible data science with python. They focus
on the Pangeo software ecosystem for working with big data in the
geosciences.</li>
<li>Google developed <a href="https://earthengine.google.com/" class="external-link">Google
Earth Engine</a> which combines a multi-petabyte catalog of satellite
imagery and geospatial datasets with planetary-scale analysis
capabilities and makes it available for scientists, researchers, and
developers to detect changes, map trends, and quantify differences on
the Earth’s surface. <a href="https://developers.google.com/earth-engine/" class="external-link">Earth Engine API</a>
runs in both Python and JavaScript.</li>
<li>
<a href="https://www.arcgis.com/features/features.html" class="external-link">ArcGIS
Online</a> provides access to thousands of maps and base layers.</li>
</ul>
<p>Private companies have released SDK platforms for large scale GIS
analysis:</p>
<ul>
<li>
<a href="https://kepler.gl/#/" class="external-link">Kepler.gl</a> is Uber’s toolkit for
handling large datasets (i.e. Uber’s data archive).</li>
<li>
<a href="https://boundlessgeo.com/" class="external-link">Boundless Geospatial</a> is
built upon OSGEO software for enterprise solutions.</li>
</ul>
<p>Publicly funded open-source platforms for large scale GIS
analysis:</p>
<ul>
<li>
<a href="https://pangeo.io/" class="external-link">PANGEO</a> for the Earth Sciences. This
community organization also supports python libraries like xarray, iris,
dask, jupyter, and many other packages.</li>
<li>
<a href="https://sepal.io/" class="external-link">Sepal.io</a> by <a href="https://www.openforis.org/" class="external-link">FAO Open Foris</a> utilizing EOS
satellite imagery and cloud resources for global forest monitoring.</li>
</ul>
</div>
</section><section><h2 class="section-heading" id="gui-vs-cli">GUI vs CLI<a class="anchor" aria-label="anchor" href="#gui-vs-cli"></a>
</h2>
<hr class="half-width">
<p>The earliest computer systems operated without a graphical user
interface (GUI), relying only on the command-line interface (CLI). Since
mapping and spatial analysis are strongly visual tasks, GIS applications
benefited greatly from the emergence of GUIs and quickly came to rely
heavily on them. Most modern GIS applications have very complex GUIs,
with all common tools and procedures accessed via buttons and menus.</p>
<p>Benefits of using a GUI include:</p>
<ul>
<li>Tools are all laid out in front of you</li>
<li>Complex commands are easy to build</li>
<li>Don’t need to learn a coding language</li>
<li>Cartography and visualisation is more intuitive and flexible</li>
</ul>
<p>Downsides of using a GUI include:</p>
<ul>
<li>Low reproducibility - you can record your actions and replay, but
this is limited to the functionalities of the software</li>
<li>Batch-processing is possible, but limited to the funstionalities of
the software and hard to be integrated with other workflows</li>
<li>Limited ability to customise functions or write your own</li>
<li>Intimidating interface for new users - so many buttons!</li>
</ul>
<p>In scientific computing, the lack of reproducibility in
point-and-click software has come to be viewed as a critical weakness.
As such, scripted CLI-style workflows are becoming popular, which leads
us to another approach to doing GIS — via a programming language.
Therefore this is the approach we will be using throughout this
workshop.</p>
</section><section><h2 class="section-heading" id="gis-in-programming-languages">GIS in programming languages<a class="anchor" aria-label="anchor" href="#gis-in-programming-languages"></a>
</h2>
<hr class="half-width">
<p>A number of powerful geospatial processing libraries exist for
general-purpose programming languages like Java and C++. However, the
learning curve for these languages is steep and the effort required is
excessive for users who only need a subset of their functionality.</p>
<p>Higher-level scripting languages like Python and R are considered
easier to learn and use. Both now have their own packages that wrap up
those geospatial processing libraries and make them easy to access and
use safely. A key example is the Java Topology Suite (JTS), which is
implemented in C++ as GEOS. GEOS is accessible in Python via the
<code>shapely</code> package (and <code>geopandas</code>, which makes
use of <code>shapely</code>) and in R via <code>sf</code>. R and Python
also have interface packages for GDAL, and for specific GIS apps.</p>
<p>This last point is a huge advantage for GIS-by-programming; these
interface packages give you the ability to access functions unique to
particular programs, but have your entire workflow recorded in a central
document - a document that can be re-run at will. Below are lists of
some of the key spatial packages for Python, which we will be using in
the remainder of this workshop.</p>
<ul>
<li>
<code>geopandas</code> and <code>geocube</code> for working with
vector data</li>
<li>
<code>rasterio</code> and <code>rioxarray</code> for working with
raster data</li>
</ul>
<p>These packages along with the <code>matplotlib</code> package are all
we need for spatial data visualisation. Python also has many fundamental
scientific packages that are relevant in the geospatial domain. Below is
a list of particularly fundamental packages. <code>numpy</code>,
<code>scipy</code>, and <code>scikit-image</code> are all excellent
options for working with rasters, as arrays.</p>
<p>An overview of these and other Python spatial packages can be <a href="https://medium.com/@chrieke/essential-geospatial-python-libraries-5d82fcc38731" class="external-link">accessed
here</a>.</p>
<p>As a programming language, Python can be a CLI tool. However, using
Python together with an <a href="https://www.codecademy.com/articles/what-is-an-ide" class="external-link">Integrated
Development Environment</a> (IDE) application allows some GUI features
to become part of your workflow. IDEs allow the best of both worlds.
They provide a place to visually examine data and other software
objects, interact with your file system, and draw plots and maps, but
your activities are still command-driven: recordable and reproducible.
There are several IDEs available for Python. <a href="https://jupyter.org/" class="external-link">JupyterLab</a> is well-developed and the
most widely used option for data science in Python. <a href="https://code.visualstudio.com/docs/python/python-tutorial" class="external-link">VSCode</a>
and <a href="https://www.spyder-ide.org/" class="external-link">Spyder</a> are other popular
options for data science.</p>
<p>Traditional GIS apps are also moving back towards providing a
scripting environment for users, further blurring the CLI/GUI divide.
ESRI have adopted Python into their software by introducing <a href="https://developers.arcgis.com/documentation/arcgis-add-ins-and-automation/arcpy/" class="external-link">ArcPy</a>,
and QGIS is both Python and R-friendly.</p>
</section><section><h2 class="section-heading" id="gis-file-types">GIS File Types<a class="anchor" aria-label="anchor" href="#gis-file-types"></a>
</h2>
<hr class="half-width">
<p>There are a variety of file types that are used in GIS analysis.
Depending on the program you choose to use some file types can be used
while others are not readable. Below is a brief table describing some of
the most common vector and raster file types.</p>
<div class="section level3">
<h3 id="vector">Vector<a class="anchor" aria-label="anchor" href="#vector"></a>
</h3>
<table class="table">
<colgroup>
<col width="30%">
<col width="33%">
<col width="36%">
</colgroup>
<thead><tr class="header">
<th>File Type</th>
<th>Extensions</th>
<th>Description</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>Esri Shapefile</td>
<td>.SHP .DBF .SHX</td>
<td>The most common geospatial file type. This has become the industry
standard. The three required files are: SHP is the feature geometry. SHX
is the shape index position. DBF is the attribute data.</td>
</tr>
<tr class="even">
<td>GeoPackage</td>
<td>.gpkg</td>
<td>As an alternative to Shapefile, this open file format is gaining
terrain and it consists of one file containing all necessary attribute
information.</td>
</tr>
<tr class="odd">
<td>Geographic JavaScript Object Notation (GeoJSON)</td>
<td>.GEOJSON .JSON</td>
<td>Used for web-based mapping and uses JavaScript Object Notation to
store the coordinates as text.</td>
</tr>
<tr class="even">
<td>Google Keyhole Markup Language (KML)</td>
<td>.KML .KMZ</td>
<td>KML stands for Keyhole Markup Language. This GIS format is XML-based
and is primarily used for Google Earth.</td>
</tr>
<tr class="odd">
<td>GPX or GPS Exchange Format</td>
<td>.gpx</td>
<td>XML schema designed as a common GPS data format for software
applications. This format is often used for tracking activities
e.g. hiking, cycling, running etc.</td>
</tr>
<tr class="even">
<td>OpenStreetMap</td>
<td>.OSM</td>
<td>OSM files are the native file for OpenStreetMap which had become the
largest crowdsourcing GIS data project in the world. These files are a
collection of vector features from crowd-sourced contributions from the
open community.</td>
</tr>
</tbody>
</table>
</div>
<div class="section level3">
<h3 id="raster">Raster<a class="anchor" aria-label="anchor" href="#raster"></a>
</h3>
<table class="table">
<colgroup>
<col width="30%">
<col width="33%">
<col width="36%">
</colgroup>
<thead><tr class="header">
<th>File Type</th>
<th>Extensions</th>
<th>Description</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>ERDAS Imagine</td>
<td>.IMG</td>
<td>ERDAS Imagine IMG files is a proprietary file format developed by
Hexagon Geospatial. IMG files are commonly used for raster data to store
single and multiple bands of satellite data.Each raster layer as part of
an IMG file contains information about its data values. For example,
this includes projection, statistics, attributes, pyramids and whether
or not it’s a continuous or discrete type of raster.</td>
</tr>
<tr class="even">
<td>GeoTIFF</td>
<td>.TIF .TIFF .OVR</td>
<td>The GeoTIFF has become an industry image standard file for GIS and
satellite remote sensing applications. GeoTIFFs may be accompanied by
other files:TFW is the world file that is required to give your raster
geolocation.XML optionally accompany GeoTIFFs and are your metadata.AUX
auxiliary files store projections and other information.OVR pyramid
files improves performance for raster display.</td>
</tr>
<tr class="odd">
<td>Cloud Optimized GeoTIFF (COG)</td>
<td>.TIF .TIFF</td>
<td>Based on the GeoTIFF standard, COGs incorporate tiling and overviews
to support HTTP range requests where users can query and load subsets of
the image without having to transfer the entire file.</td>
</tr>
</tbody>
</table>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Key Points</h3>
<div class="callout-content">
<ul>
<li>Many software packages exist for working with geospatial data.</li>
<li>Command-line programs allow you to automate and reproduce your
work.</li>
<li>JupyterLab provides a user-friendly interface for working with
Python.</li>
</ul>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</div>
</section></section><section id="aio-05-access-data"><p>Content from <a href="05-access-data.html">Access satellite imagery using Python</a></p>
<hr>
<p>Last updated on 2025-05-20 |

        <a href="https://github.com/carpentries-incubator/geospatial-python/edit/main/episodes/05-access-data.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>Where can I find open-access satellite data?</li>
<li>How do I search for satellite imagery with the STAC API?</li>
<li>How do I fetch remote raster datasets using Python?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Search public STAC repositories of satellite imagery using
Python.</li>
<li>Inspect search result’s metadata.</li>
<li>Download (a subset of) the assets available for a satellite
scene.</li>
<li>Open satellite imagery as raster data and save it to disk.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<section><h2 class="section-heading" id="considerations-for-the-position-of-this-episode-in-the-workshop">Considerations for the position of this episode in the workshop<a class="anchor" aria-label="anchor" href="#considerations-for-the-position-of-this-episode-in-the-workshop"></a>
</h2>
<hr class="half-width">
<p><em>When this workshop is taught to learners with limited prior
knowledge of Python, it might be better to place this episode after
episode 11 and before episode 12. This episode contains an introduction
to working with APIs and dictionaries, which can be perceived as
challenging by some learners. Another consideration for placing this
episode later in the workshop is when it is taught to learners with
prior GIS knowledge who want to perform GIS-like operations with data
they have already collected or for learners interested in working with
raster data but less interested in satellite images.</em></p>
</section><section><h2 class="section-heading" id="introduction">Introduction<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h2>
<hr class="half-width">
<p>A number of satellites take snapshots of the Earth’s surface from
space. The images recorded by these remote sensors represent a very
precious data source for any activity that involves monitoring changes
on Earth. Satellite imagery is typically provided in the form of
geospatial raster data, with the measurements in each grid cell
(“pixel”) being associated to accurate geographic coordinate
information.</p>
<p>In this episode we will explore how to access open satellite data
using Python. In particular, we will consider <a href="https://registry.opendata.aws/sentinel-2-l2a-cogs" class="external-link">the Sentinel-2
data collection that is hosted on Amazon Web Services (AWS)</a>. This
dataset consists of multi-band optical images acquired by the
constellation of two satellites from <a href="https://sentinel.esa.int/web/sentinel/missions/sentinel-2" class="external-link">the
Sentinel-2 mission</a> and it is continuously updated with new
images.</p>
</section><section><h2 class="section-heading" id="search-for-satellite-imagery">Search for satellite imagery<a class="anchor" aria-label="anchor" href="#search-for-satellite-imagery"></a>
</h2>
<hr class="half-width">
<div class="section level3">
<h3 id="the-spatiotemporal-asset-catalog-stac-specification">The SpatioTemporal Asset Catalog (STAC) specification<a class="anchor" aria-label="anchor" href="#the-spatiotemporal-asset-catalog-stac-specification"></a>
</h3>
<p>Current sensor resolutions and satellite revisit periods are such
that terabytes of data products are added daily to the corresponding
collections. Such datasets cannot be made accessible to users via
full-catalog download. Therefore, space agencies and other data
providers often offer access to their data catalogs through interactive
Graphical User Interfaces (GUIs), see for instance the <a href="https://browser.dataspace.copernicus.eu" class="external-link">Copernicus Browser</a>
for the Sentinel missions. Accessing data via a GUI is a nice way to
explore a catalog and get familiar with its content, but it represents a
heavy and error-prone task that should be avoided if carried out
systematically to retrieve data.</p>
<p>A service that offers programmatic access to the data enables users
to reach the desired data in a more reliable, scalable and reproducible
manner. An important element in the software interface exposed to the
users, which is generally called the Application Programming Interface
(API), is the use of standards. Standards, in fact, can significantly
facilitate the reusability of tools and scripts across datasets and
applications.</p>
<p>The SpatioTemporal Asset Catalog (STAC) specification is an emerging
standard for describing geospatial data. By organizing metadata in a
form that adheres to the STAC specifications, data providers make it
possible for users to access data from different missions, instruments
and collections using the same set of tools.</p>
<figure><img src="fig/E05/STAC-browser.jpg" alt="STAC browser screenshots" class="figure mx-auto d-block"><div class="figcaption">Views of the STAC browser</div>
</figure><div id="more-resources-on-stac" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div id="more-resources-on-stac" class="callout-inner">
<h3 class="callout-title">More Resources on STAC</h3>
<div class="callout-content">
<ul>
<li><a href="https://github.com/radiantearth/stac-spec#readme" class="external-link">STAC
specification</a></li>
<li><a href="https://stacindex.org/ecosystem" class="external-link">Tools based on
STAC</a></li>
<li><a href="https://stacindex.org/catalogs" class="external-link">STAC catalogs</a></li>
</ul>
</div>
</div>
</div>
</div>
</section><section><h2 class="section-heading" id="search-a-stac-catalog">Search a STAC catalog<a class="anchor" aria-label="anchor" href="#search-a-stac-catalog"></a>
</h2>
<hr class="half-width">
<p>The <a href="https://radiantearth.github.io/stac-browser/#/" class="external-link">STAC
browser</a> is a good starting point to discover available datasets, as
it provides an up-to-date list of existing STAC catalogs. From the list,
let’s click on the “Earth Search” catalog, i.e. the access point to
search the archive of Sentinel-2 images hosted on AWS.</p>
<div id="exercise-discover-a-stac-catalog" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="exercise-discover-a-stac-catalog" class="callout-inner">
<h3 class="callout-title">Exercise: Discover a STAC catalog</h3>
<div class="callout-content">
<p>Let’s take a moment to explore the Earth Search STAC catalog, which
is the catalog indexing the Sentinel-2 collection that is hosted on AWS.
We can interactively browse this catalog using the STAC browser at <a href="https://radiantearth.github.io/stac-browser/#/external/earth-search.aws.element84.com/v1" class="external-link">this
link</a>.</p>
<ol style="list-style-type: decimal">
<li>Open the link in your web browser. Which (sub-)catalogs are
available?</li>
<li>Open the Sentinel-2 Level 2A collection, and select one item from
the list. Each item corresponds to a satellite “scene”, i.e. a portion
of the footage recorded by the satellite at a given time. Have a look at
the metadata fields and the list of assets. What kind of data do the
assets represent?</li>
</ol>
</div>
</div>
</div>
<div id="accordionSolution1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution1" aria-expanded="false" aria-controls="collapseSolution1">
  <h4 class="accordion-header" id="headingSolution1"> Show me the solution </h4>
</button>
<div id="collapseSolution1" class="accordion-collapse collapse" aria-labelledby="headingSolution1" data-bs-parent="#accordionSolution1">
<div class="accordion-body">
<figure><img src="fig/E05/STAC-browser-exercise.jpg" alt="earth-search stac catalog views" class="figure mx-auto d-block"><div class="figcaption">Views of the Earth Search STAC endpoint</div>
</figure><ol style="list-style-type: decimal">
<li>8 sub-catalogs are available. In the STAC nomenclature, these are
actually “collections”, i.e. catalogs with additional information about
the elements they list: spatial and temporal extents, license,
providers, etc. Among the available collections, we have Landsat
Collection 2, Level-2 and Sentinel-2 Level 2A (see left screenshot in
the figure above).</li>
<li>When you select the Sentinel-2 Level 2A collection, and randomly
choose one of the items from the list, you should find yourself on a
page similar to the right screenshot in the figure above. On the left
side you will find a list of the available assets: overview images
(thumbnail and true color images), metadata files and the “real”
satellite images, one for each band captured by the Multispectral
Instrument on board Sentinel-2.</li>
</ol>
</div>
</div>
</div>
</div>
<p>When opening a catalog with the STAC browser, you can access the API
URL by clicking on the “Source” button on the top right of the page. By
using this URL, you have access to the catalog content and, if supported
by the catalog, to the functionality of searching its items. For the
Earth Search STAC catalog the API URL is:</p>
<div class="codewrapper sourceCode" id="cb1">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a>api_url <span class="op">=</span> <span class="st">"https://earth-search.aws.element84.com/v1"</span></span></code></pre>
</div>
<p>You can query a STAC API endpoint from Python using the <a href="https://pystac-client.readthedocs.io" class="external-link"><code>pystac_client</code>
library</a>. To do so we will first import <code>Client</code> from
<code>pystac_client</code> and use the <a href="https://pystac-client.readthedocs.io/en/stable/quickstart.html" class="external-link">method
<code>open</code> from the Client object</a>:</p>
<div class="codewrapper sourceCode" id="cb2">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a><span class="im">from</span> pystac_client <span class="im">import</span> Client</span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" tabindex="-1"></a>client <span class="op">=</span> Client.<span class="bu">open</span>(api_url)</span></code></pre>
</div>
<p>For this episode we will focus at scenes belonging to the
<code>sentinel-2-l2a</code> collection. This dataset is useful for our
case and includes Sentinel-2 data products pre-processed at level 2A
(bottom-of-atmosphere reflectance).</p>
<p>In order to see which collections are available in the provided
<code>api_url</code> the <a href="https://pystac-client.readthedocs.io/en/stable/api.html#pystac_client.Client.get_collections" class="external-link"><code>get_collections</code></a>
method can be used on the Client object.</p>
<div class="codewrapper sourceCode" id="cb3">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a>collections <span class="op">=</span> client.get_collections()</span></code></pre>
</div>
<p>To print the collections we can make a for loop doing:</p>
<div class="codewrapper sourceCode" id="cb4">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a><span class="cf">for</span> collection <span class="kw">in</span> collections:</span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a>    <span class="bu">print</span>(collection)</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>&lt;CollectionClient id=cop-dem-glo-30&gt;
&lt;CollectionClient id=naip&gt;
&lt;CollectionClient id=sentinel-2-l2a&gt;
&lt;CollectionClient id=sentinel-2-l1c&gt;
&lt;CollectionClient id=cop-dem-glo-90&gt;
&lt;CollectionClient id=landsat-c2-l2&gt;
&lt;CollectionClient id=sentinel-1-grd&gt;
&lt;CollectionClient id=sentinel-2-c1-l2a&gt;</code></pre>
</div>
<p>As said, we want to focus to the <code>sentinel-2-l2a</code>
collection. To do so, we set this collection into a variable:</p>
<div class="codewrapper sourceCode" id="cb6">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a>collection_sentinel_2_l2a <span class="op">=</span> <span class="st">"sentinel-2-l2a"</span></span></code></pre>
</div>
<p>The data in this collection is stored in the Cloud Optimized GeoTIFF
(COG) format and as JPEG2000 images. In this episode we will focus at
COGs, as these offer useful functionalities for our purpose.</p>
<div id="cloud-optimized-geotiffs" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div id="cloud-optimized-geotiffs" class="callout-inner">
<h3 class="callout-title">Cloud Optimized GeoTIFFs</h3>
<div class="callout-content">
<p>Cloud Optimized GeoTIFFs (COGs) are regular GeoTIFF files with some
additional features that make them ideal to be employed in the context
of cloud computing and other web-based services. This format builds on
the widely-employed GeoTIFF format, already introduced in <a href="01-intro-raster-data.html">Episode 1: Introduction to Raster
Data</a>. In essence, COGs are regular GeoTIFF files with a special
internal structure. One of the features of COGs is that data is
organized in “blocks” that can be accessed remotely via independent HTTP
requests. Data users can thus access the only blocks of a GeoTIFF that
are relevant for their analysis, without having to download the full
file. In addition, COGs typically include multiple lower-resolution
versions of the original image, called “overviews”, which can also be
accessed independently. By providing this “pyramidal” structure, users
that are not interested in the details provided by a high-resolution
raster can directly access the lower-resolution versions of the same
image, significantly saving on the downloading time. More information on
the COG format can be found <a href="https://www.cogeo.org" class="external-link">here</a>.</p>
</div>
</div>
</div>
<p>In order to get data for a specific location you can add longitude
latitude coordinates (World Geodetic System 1984 EPSG:4326) in your
request. In order to do so we are using the <code>shapely</code> library
to define a geometrical point. Below we have included a point on the
island of Rhodes, which is the location of interest for our case study
(i.e. Longitude: 27.95 | Latitude 36.20).</p>
<div class="codewrapper sourceCode" id="cb7">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a><span class="im">from</span> shapely.geometry <span class="im">import</span> Point</span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a>point <span class="op">=</span> Point(<span class="fl">27.95</span>, <span class="fl">36.20</span>)  <span class="co"># Coordinates of a point on Rhodes</span></span></code></pre>
</div>
<p>Note: at this stage, we are only dealing with metadata, so no image
is going to be downloaded yet. But even metadata can be quite bulky if a
large number of scenes match our search! For this reason, we limit the
search by the intersection of the point (by setting the parameter
<code>intersects</code>) and assign the collection (by setting the
parameter <code>collections</code>). More information about the possible
parameters to be set can be found in the <code>pystac_client</code>
documentation for the <a href="https://pystac-client.readthedocs.io/en/stable/api.html#pystac_client.Client.search" class="external-link">Client’s
<code>search</code> method</a>.</p>
<p>We now set up our search of satellite images in the following
way:</p>
<div class="codewrapper sourceCode" id="cb8">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a>search <span class="op">=</span> client.search(</span>
<span id="cb8-2"><a href="#cb8-2" tabindex="-1"></a>    collections<span class="op">=</span>[collection_sentinel_2_l2a],</span>
<span id="cb8-3"><a href="#cb8-3" tabindex="-1"></a>    intersects<span class="op">=</span>point,</span>
<span id="cb8-4"><a href="#cb8-4" tabindex="-1"></a>)</span></code></pre>
</div>
<p>Now we submit the query in order to find out how many scenes match
our search criteria with the parameters assigned above (please note that
this output can be different as more data is added to the catalog to
when this episode was created):</p>
<div class="codewrapper sourceCode" id="cb9">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a><span class="bu">print</span>(search.matched())</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code><span><span class="fl">611</span></span></code></pre>
</div>
<p>You will notice that more than 500 scenes match our search criteria.
We are however interested in the period right before and after the
wildfire of Rhodes. In the following exercise you will therefore have to
add a time filter to our search criteria to narrow down our search for
images of that period.</p>
<div id="exercise-search-satellite-scenes-with-a-time-filter" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="exercise-search-satellite-scenes-with-a-time-filter" class="callout-inner">
<h3 class="callout-title">Exercise: Search satellite scenes with a time filter</h3>
<div class="callout-content">
<p>Search for all the available Sentinel-2 scenes in the
<code>sentinel-2-c1-l2a</code> collection that have been recorded
between 1st of July 2023 and 31st of August 2023 (few weeks before and
after the time in which the wildfire took place).</p>
<p>Hint: You can find the input argument and the required syntax in the
documentation of <code>client.search</code> (which you can access from
Python or <a href="https://pystac-client.readthedocs.io/en/stable/api.html#pystac_client.Client.search" class="external-link">online</a>)</p>
<p>How many scenes are available?</p>
</div>
</div>
</div>
<div id="accordionSolution2" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution2" aria-expanded="false" aria-controls="collapseSolution2">
  <h4 class="accordion-header" id="headingSolution2"> Show me the solution </h4>
</button>
<div id="collapseSolution2" class="accordion-collapse collapse" aria-labelledby="headingSolution2" data-bs-parent="#accordionSolution2">
<div class="accordion-body">
<div class="codewrapper sourceCode" id="cb11">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a>search <span class="op">=</span> client.search(</span>
<span id="cb11-2"><a href="#cb11-2" tabindex="-1"></a>    collections<span class="op">=</span>[collection_sentinel_2_l2a],</span>
<span id="cb11-3"><a href="#cb11-3" tabindex="-1"></a>    intersects<span class="op">=</span>point,</span>
<span id="cb11-4"><a href="#cb11-4" tabindex="-1"></a>    datetime<span class="op">=</span><span class="st">'2023-07-01/2023-08-31'</span></span>
<span id="cb11-5"><a href="#cb11-5" tabindex="-1"></a>)</span>
<span id="cb11-6"><a href="#cb11-6" tabindex="-1"></a><span class="bu">print</span>(search.matched())</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code><span><span class="fl">12</span></span></code></pre>
</div>
<p>This means that 12 scenes satisfy the search criteria.</p>
</div>
</div>
</div>
</div>
<p>Now that we have added a time filter, we retrieve the metadata of the
search results by calling the method <code>item_collection</code>:</p>
<div class="codewrapper sourceCode" id="cb13">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a>items <span class="op">=</span> search.item_collection()</span></code></pre>
</div>
<p>The variable <code>items</code> is an <code>ItemCollection</code>
object. More information can be found at the <a href="https://pystac.readthedocs.io/en/latest/api/pystac.html#pystac.ItemCollection" class="external-link">pystac
documentation</a></p>
<p>Now let us check the size using <code>len</code>:</p>
<div class="codewrapper sourceCode" id="cb14">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" tabindex="-1"></a><span class="bu">print</span>(<span class="bu">len</span>(items))</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code><span><span class="fl">12</span></span></code></pre>
</div>
<p>which is consistent with the number of scenes matching our search
results as found with <code>search.matched()</code>. We can iterate over
the returned items and print these to show their IDs:</p>
<div class="codewrapper sourceCode" id="cb16">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" tabindex="-1"></a><span class="cf">for</span> item <span class="kw">in</span> items:</span>
<span id="cb16-2"><a href="#cb16-2" tabindex="-1"></a>    <span class="bu">print</span>(item)</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>&lt;Item id=S2A_35SNA_20230827_0_L2A&gt;
&lt;Item id=S2B_35SNA_20230822_0_L2A&gt;
&lt;Item id=S2A_35SNA_20230817_0_L2A&gt;
&lt;Item id=S2B_35SNA_20230812_0_L2A&gt;
&lt;Item id=S2A_35SNA_20230807_0_L2A&gt;
&lt;Item id=S2B_35SNA_20230802_0_L2A&gt;
&lt;Item id=S2A_35SNA_20230728_0_L2A&gt;
&lt;Item id=S2B_35SNA_20230723_0_L2A&gt;
&lt;Item id=S2A_35SNA_20230718_0_L2A&gt;
&lt;Item id=S2B_35SNA_20230713_0_L2A&gt;
&lt;Item id=S2A_35SNA_20230708_0_L2A&gt;
&lt;Item id=S2B_35SNA_20230703_0_L2A&gt;</code></pre>
</div>
<p>Each of the items contains information about the scene geometry, its
acquisition time, and other metadata that can be accessed as a
dictionary from the <code>properties</code> attribute. To see which
information Item objects can contain you can have a look at the <a href="https://pystac.readthedocs.io/en/latest/api/pystac.html#pystac.Item" class="external-link">pystac
documentation</a>.</p>
<p>Let us inspect the metadata associated with the first item of the
search results. Let us first look at the collection date of the first
item::</p>
<div class="codewrapper sourceCode" id="cb18">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" tabindex="-1"></a>item <span class="op">=</span> items[<span class="dv">0</span>]</span>
<span id="cb18-2"><a href="#cb18-2" tabindex="-1"></a><span class="bu">print</span>(item.datetime)</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>2023-08-27 09:00:21.327000+00:00</code></pre>
</div>
<p>Let us now look at the geometry and other properties as well.</p>
<div class="codewrapper sourceCode" id="cb20">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" tabindex="-1"></a><span class="bu">print</span>(item.geometry)</span>
<span id="cb20-2"><a href="#cb20-2" tabindex="-1"></a><span class="bu">print</span>(item.properties)</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>{'type': 'Polygon', 'coordinates': [[[27.290401625602243, 37.04621863329741], [27.23303872472207, 36.83882218126937], [27.011145718480538, 36.05673246264742], [28.21878905911668, 36.05053734221328], [28.234426643135546, 37.04015200857309], [27.290401625602243, 37.04621863329741]]]}
{'created': '2023-08-27T18:15:43.106Z', 'platform': 'sentinel-2a', 'constellation': 'sentinel-2', 'instruments': ['msi'], 'eo:cloud_cover': 0.955362, 'proj:epsg': 32635, 'mgrs:utm_zone': 35, 'mgrs:latitude_band': 'S', 'mgrs:grid_square': 'NA', 'grid:code': 'MGRS-35SNA', 'view:sun_azimuth': 144.36354987218, 'view:sun_elevation': 59.06665363921, 's2:degraded_msi_data_percentage': 0.0126, 's2:nodata_pixel_percentage': 12.146327, 's2:saturated_defective_pixel_percentage': 0, 's2:dark_features_percentage': 0.249403, 's2:cloud_shadow_percentage': 0.237454, 's2:vegetation_percentage': 6.073786, 's2:not_vegetated_percentage': 18.026696, 's2:water_percentage': 74.259061, 's2:unclassified_percentage': 0.198216, 's2:medium_proba_clouds_percentage': 0.613614, 's2:high_proba_clouds_percentage': 0.341423, 's2:thin_cirrus_percentage': 0.000325, 's2:snow_ice_percentage': 2.3e-05, 's2:product_type': 'S2MSI2A', 's2:processing_baseline': '05.09', 's2:product_uri': 'S2A_MSIL2A_20230827T084601_N0509_R107_T35SNA_20230827T115803.SAFE', 's2:generation_time': '2023-08-27T11:58:03.000000Z', 's2:datatake_id': 'GS2A_20230827T084601_042718_N05.09', 's2:datatake_type': 'INS-NOBS', 's2:datastrip_id': 'S2A_OPER_MSI_L2A_DS_2APS_20230827T115803_S20230827T085947_N05.09', 's2:granule_id': 'S2A_OPER_MSI_L2A_TL_2APS_20230827T115803_A042718_T35SNA_N05.09', 's2:reflectance_conversion_factor': 0.978189079756816, 'datetime': '2023-08-27T09:00:21.327000Z', 's2:sequence': '0', 'earthsearch:s3_path': 's3://sentinel-cogs/sentinel-s2-l2a-cogs/35/S/NA/2023/8/S2A_35SNA_20230827_0_L2A', 'earthsearch:payload_id': 'roda-sentinel2/workflow-sentinel2-to-stac/af0287974aaa3fbb037c6a7632f72742', 'earthsearch:boa_offset_applied': True, 'processing:software': {'sentinel2-to-stac': '0.1.1'}, 'updated': '2023-08-27T18:15:43.106Z'}</code></pre>
</div>
<p>You can access items from the <code>properties</code> dictionary as
usual in Python. For instance, for the EPSG code of the projected
coordinate system:</p>
<div class="codewrapper sourceCode" id="cb22">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" tabindex="-1"></a><span class="bu">print</span>(item.properties[<span class="st">'proj:code'</span>])</span></code></pre>
</div>
<div id="exercise-search-satellite-scenes-using-metadata-filters" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="exercise-search-satellite-scenes-using-metadata-filters" class="callout-inner">
<h3 class="callout-title">Exercise: Search satellite scenes using metadata filters</h3>
<div class="callout-content">
<p>Let’s add a filter on the cloud cover to select the only scenes with
less than 1% cloud coverage. How many scenes do now match our
search?</p>
<p>Hint: generic metadata filters can be implemented via the
<code>query</code> input argument of <code>client.search</code>, which
requires the following syntax (see <a href="https://pystac-client.readthedocs.io/en/stable/usage.html#query-extension" class="external-link">docs</a>):
<code>query=['&lt;property&gt;&lt;operator&gt;&lt;value&gt;']</code>.</p>
</div>
</div>
</div>
<div id="accordionSolution3" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution3" aria-expanded="false" aria-controls="collapseSolution3">
  <h4 class="accordion-header" id="headingSolution3"> Show me the solution </h4>
</button>
<div id="collapseSolution3" class="accordion-collapse collapse" aria-labelledby="headingSolution3" data-bs-parent="#accordionSolution3">
<div class="accordion-body">
<div class="codewrapper sourceCode" id="cb23">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" tabindex="-1"></a>search <span class="op">=</span> client.search(</span>
<span id="cb23-2"><a href="#cb23-2" tabindex="-1"></a>    collections<span class="op">=</span>[collection_sentinel_2_l2a],</span>
<span id="cb23-3"><a href="#cb23-3" tabindex="-1"></a>    intersects<span class="op">=</span>point,</span>
<span id="cb23-4"><a href="#cb23-4" tabindex="-1"></a>    datetime<span class="op">=</span><span class="st">'2023-07-01/2023-08-31'</span>,</span>
<span id="cb23-5"><a href="#cb23-5" tabindex="-1"></a>    query<span class="op">=</span>[<span class="st">'eo:cloud_cover&lt;1'</span>]</span>
<span id="cb23-6"><a href="#cb23-6" tabindex="-1"></a>)</span>
<span id="cb23-7"><a href="#cb23-7" tabindex="-1"></a><span class="bu">print</span>(search.matched())</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code><span><span class="fl">11</span></span></code></pre>
</div>
</div>
</div>
</div>
</div>
<p>Once we are happy with our search, we save the search results in a
file:</p>
<div class="codewrapper sourceCode" id="cb25">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" tabindex="-1"></a>items <span class="op">=</span> search.item_collection()</span>
<span id="cb25-2"><a href="#cb25-2" tabindex="-1"></a>items.save_object(<span class="st">"rhodes_sentinel-2.json"</span>)</span></code></pre>
</div>
<p>This creates a file in GeoJSON format, which we can reuse here and in
the next episodes. Note that this file contains the metadata of the
files that meet out criteria. It does not include the data itself, only
their metadata.</p>
<p>To load the saved search results as a <code>ItemCollection</code> we
can use <a href="https://pystac.readthedocs.io/en/stable/api/item_collection.html" class="external-link"><code>pystac.ItemCollection.from_file()</code></a>.
Through this, we are instructing Python to use the
<code>from_file</code> method of the <code>ItemCollection</code> class
from the <code>pystac</code> library to load data from the specified
GeoJSON file:</p>
<div class="codewrapper sourceCode" id="cb26">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" tabindex="-1"></a><span class="im">import</span> pystac</span>
<span id="cb26-2"><a href="#cb26-2" tabindex="-1"></a>items_loaded <span class="op">=</span> pystac.ItemCollection.from_file(<span class="st">"rhodes_sentinel-2.json"</span>)</span></code></pre>
</div>
<p>The loaded item collection (<code>items_loaded</code>) is equivalent
to the one returned earlier by <code>search.item_collection()</code>
(<code>items</code>). You can thus perform the same actions on it: you
can check the number of items (<code>len(items_loaded)</code>), you can
loop over items (<code>for item in items_loaded: ...</code>), and you
can access individual elements using their index
(<code>items_loaded[0]</code>).</p>
</section><section><h2 class="section-heading" id="access-the-assets">Access the assets<a class="anchor" aria-label="anchor" href="#access-the-assets"></a>
</h2>
<hr class="half-width">
<p>So far we have only discussed metadata - but how can one get to the
actual images of a satellite scene (the “assets” in the STAC
nomenclature)? These can be reached via links that are made available
through the item’s attribute <code>assets</code>. Let’s focus on the
last item in the collection: this is the oldest in time, and it thus
corresponds to an image taken before the wildfires.</p>
<div class="codewrapper sourceCode" id="cb27">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" tabindex="-1"></a>assets <span class="op">=</span> items[<span class="op">-</span><span class="dv">1</span>].assets  <span class="co"># last item's asset dictionary</span></span>
<span id="cb27-2"><a href="#cb27-2" tabindex="-1"></a><span class="bu">print</span>(assets.keys())</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>dict_keys(['aot', 'blue', 'coastal', 'granule_metadata', 'green', 'nir', 'nir08', 'nir09', 'red', 'rededge1', 'rededge2', 'rededge3', 'scl', 'swir16', 'swir22', 'thumbnail', 'tileinfo_metadata', 'visual', 'wvp', 'aot-jp2', 'blue-jp2', 'coastal-jp2', 'green-jp2', 'nir-jp2', 'nir08-jp2', 'nir09-jp2', 'red-jp2', 'rededge1-jp2', 'rededge2-jp2', 'rededge3-jp2', 'scl-jp2', 'swir16-jp2', 'swir22-jp2', 'visual-jp2', 'wvp-jp2'])</code></pre>
</div>
<p>We can print a minimal description of the available assets:</p>
<div class="codewrapper sourceCode" id="cb29">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" tabindex="-1"></a><span class="cf">for</span> key, asset <span class="kw">in</span> assets.items():</span>
<span id="cb29-2"><a href="#cb29-2" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>key<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>asset<span class="sc">.</span>title<span class="sc">}</span><span class="ss">"</span>)</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>aot: Aerosol optical thickness (AOT)
blue: Blue (band 2) - 10m
coastal: Coastal aerosol (band 1) - 60m
granule_metadata: None
green: Green (band 3) - 10m
nir: NIR 1 (band 8) - 10m
nir08: NIR 2 (band 8A) - 20m
nir09: NIR 3 (band 9) - 60m
red: Red (band 4) - 10m
rededge1: Red edge 1 (band 5) - 20m
rededge2: Red edge 2 (band 6) - 20m
rededge3: Red edge 3 (band 7) - 20m
scl: Scene classification map (SCL)
swir16: SWIR 1 (band 11) - 20m
swir22: SWIR 2 (band 12) - 20m
thumbnail: Thumbnail image
tileinfo_metadata: None
visual: True color image
wvp: Water vapour (WVP)
aot-jp2: Aerosol optical thickness (AOT)
blue-jp2: Blue (band 2) - 10m
coastal-jp2: Coastal aerosol (band 1) - 60m
green-jp2: Green (band 3) - 10m
nir-jp2: NIR 1 (band 8) - 10m
nir08-jp2: NIR 2 (band 8A) - 20m
nir09-jp2: NIR 3 (band 9) - 60m
red-jp2: Red (band 4) - 10m
rededge1-jp2: Red edge 1 (band 5) - 20m
rededge2-jp2: Red edge 2 (band 6) - 20m
rededge3-jp2: Red edge 3 (band 7) - 20m
scl-jp2: Scene classification map (SCL)
swir16-jp2: SWIR 1 (band 11) - 20m
swir22-jp2: SWIR 2 (band 12) - 20m
visual-jp2: True color image
wvp-jp2: Water vapour (WVP)</code></pre>
</div>
<p>Among the other data files, assets include multiple raster data files
(one per optical band, as acquired by the multi-spectral instrument), a
thumbnail, a true-color image (“visual”), instrument metadata and
scene-classification information (“SCL”). Let’s get the URL link to the
thumbnail, which gives us a glimpse of the Sentinel-2 scene:</p>
<div class="codewrapper sourceCode" id="cb31">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" tabindex="-1"></a><span class="bu">print</span>(assets[<span class="st">"thumbnail"</span>].href)</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/35/S/NA/2023/7/S2A_35SNA_20230708_0_L2A/thumbnail.jpg</code></pre>
</div>
<p>This can be used to download the corresponding file:</p>
<figure><img src="fig/E05/STAC-s2-preview-before.jpg" alt="thumbnail of the sentinel-2 scene before the wildfires" class="figure mx-auto d-block"><div class="figcaption">Overview of the true-color image (“thumbnail”)
before the wildfires on Rhodes</div>
</figure><p>For comparison, we can check out the thumbnail of the most recent
scene of the sequence considered (i.e. the first item in the item
collection), which has been taken after the wildfires:</p>
<div class="codewrapper sourceCode" id="cb33">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" tabindex="-1"></a><span class="bu">print</span>(items[<span class="dv">0</span>].assets[<span class="st">"thumbnail"</span>].href)</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/35/S/NA/2023/8/S2A_35SNA_20230827_0_L2A/thumbnail.jpg</code></pre>
</div>
<figure><img src="fig/E05/STAC-s2-preview-after.jpg" alt="thumbnail of the sentinel-2 scene after the wildfires" class="figure mx-auto d-block"><div class="figcaption">Overview of the true-color image (“thumbnail”)
after the wildfires on Rhodes</div>
</figure><p>From the thumbnails alone we can already observe some dark spots on
the island of Rhodes at the bottom right of the image!</p>
<p>In order to open the high-resolution satellite images and investigate
the scenes in more detail, we will be using the <a href="https://corteva.github.io/rioxarray" class="external-link"><code>rioxarray</code>
library</a>. Note that this library can both work with local and remote
raster data. At this moment, we will only quickly look at the
functionality of this library. We will learn more about it in the next
episode.</p>
<p>Now let us focus on the red band by accessing the item
<code>red</code> from the assets dictionary and get the Hypertext
Reference (also known as URL) attribute using <code>.href</code> after
the item selection.</p>
<p>For now we are using <a href="https://corteva.github.io/rioxarray/stable/rioxarray.html#rioxarray-open-rasterio" class="external-link">rioxarray
to open the raster file</a>.</p>
<div class="codewrapper sourceCode" id="cb35">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" tabindex="-1"></a><span class="im">import</span> rioxarray</span>
<span id="cb35-2"><a href="#cb35-2" tabindex="-1"></a>red_href <span class="op">=</span> assets[<span class="st">"red"</span>].href</span>
<span id="cb35-3"><a href="#cb35-3" tabindex="-1"></a>red <span class="op">=</span> rioxarray.open_rasterio(red_href)</span>
<span id="cb35-4"><a href="#cb35-4" tabindex="-1"></a><span class="bu">print</span>(red)</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>&lt;xarray.DataArray (band: 1, y: 10980, x: 10980)&gt; Size: 241MB
[120560400 values with dtype=uint16]
Coordinates:
  * band         (band) int32 4B 1
  * x            (x) float64 88kB 5e+05 5e+05 5e+05 ... 6.098e+05 6.098e+05
  * y            (y) float64 88kB 4.1e+06 4.1e+06 4.1e+06 ... 3.99e+06 3.99e+06
    spatial_ref  int32 4B 0
Attributes:
    AREA_OR_POINT:       Area
    OVR_RESAMPLING_ALG:  AVERAGE
    _FillValue:          0
    scale_factor:        1.0
    add_offset:          0.0</code></pre>
</div>
<p>Now we want to save the data to our local machine using the <a href="https://corteva.github.io/rioxarray/stable/rioxarray.html#rioxarray.raster_array.RasterArray.to_raster" class="external-link">to_raster</a>
method:</p>
<div class="codewrapper sourceCode" id="cb37">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" tabindex="-1"></a><span class="co"># save whole image to disk</span></span>
<span id="cb37-2"><a href="#cb37-2" tabindex="-1"></a>red.rio.to_raster(<span class="st">"red.tif"</span>)</span></code></pre>
</div>
<p>That might take a while, given there are over 10000 x 10000 = a
hundred million pixels in the 10-meter NIR band. But we can take a
smaller subset before downloading it. Because the raster is a COG, we
can download just what we need!</p>
<p>In order to do that, we are using rioxarray´s <a href="https://corteva.github.io/rioxarray/stable/examples/clip_box.html" class="external-link"><code>clip_box</code></a>
with which you can set a bounding box defining the area you want.</p>
<div class="codewrapper sourceCode" id="cb38">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" tabindex="-1"></a>red_subset <span class="op">=</span> red.rio.clip_box(</span>
<span id="cb38-2"><a href="#cb38-2" tabindex="-1"></a>    minx<span class="op">=</span><span class="dv">560900</span>,</span>
<span id="cb38-3"><a href="#cb38-3" tabindex="-1"></a>    miny<span class="op">=</span><span class="dv">3995000</span>,</span>
<span id="cb38-4"><a href="#cb38-4" tabindex="-1"></a>    maxx<span class="op">=</span><span class="dv">570900</span>,</span>
<span id="cb38-5"><a href="#cb38-5" tabindex="-1"></a>    maxy<span class="op">=</span><span class="dv">4015000</span></span>
<span id="cb38-6"><a href="#cb38-6" tabindex="-1"></a>)</span></code></pre>
</div>
<p>Next, we save the subset using <code>to_raster</code> again.</p>
<div class="codewrapper sourceCode" id="cb39">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1" tabindex="-1"></a>red_subset.rio.to_raster(<span class="st">"red_subset.tif"</span>)</span></code></pre>
</div>
<p>The difference is 241 Megabytes for the full image vs less than 10
Megabytes for the subset.</p>
<div id="exercise-downloading-landsat-8-assets" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="exercise-downloading-landsat-8-assets" class="callout-inner">
<h3 class="callout-title">Exercise: Downloading Landsat 8 Assets</h3>
<div class="callout-content">
<p>In this exercise we put in practice all the skills we have learned in
this episode to retrieve images from a different mission: <a href="https://www.usgs.gov/landsat-missions/landsat-8" class="external-link">Landsat 8</a>. In
particular, we browse images from the <a href="https://lpdaac.usgs.gov/products/hlsl30v002/" class="external-link">Harmonized Landsat
Sentinel-2 (HLS) project</a>, which provides images from NASA’s Landsat
8 and ESA’s Sentinel-2 that have been made consistent with each other.
The HLS catalog is indexed in the NASA Common Metadata Repository (CMR)
and it can be accessed from the STAC API endpoint at the following URL:
<code>https://cmr.earthdata.nasa.gov/stac/LPCLOUD</code>.</p>
<ul>
<li>Using <code>pystac_client</code>, search for all assets of the
Landsat 8 collection (<code>HLSL30.v2.0</code>) from February to March
2021, intersecting the point with longitude/latitute coordinates
(-73.97, 40.78) deg.</li>
<li>Visualize an item’s thumbnail (asset key <code>browse</code>).</li>
</ul>
</div>
</div>
</div>
<div id="accordionSolution4" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution4" aria-expanded="false" aria-controls="collapseSolution4">
  <h4 class="accordion-header" id="headingSolution4"> Show me the solution </h4>
</button>
<div id="collapseSolution4" class="accordion-collapse collapse" aria-labelledby="headingSolution4" data-bs-parent="#accordionSolution4">
<div class="accordion-body">
<div class="codewrapper sourceCode" id="cb40">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" tabindex="-1"></a><span class="co"># connect to the STAC endpoint</span></span>
<span id="cb40-2"><a href="#cb40-2" tabindex="-1"></a>cmr_api_url <span class="op">=</span> <span class="st">"https://cmr.earthdata.nasa.gov/stac/LPCLOUD"</span></span>
<span id="cb40-3"><a href="#cb40-3" tabindex="-1"></a>client <span class="op">=</span> Client.<span class="bu">open</span>(cmr_api_url)</span>
<span id="cb40-4"><a href="#cb40-4" tabindex="-1"></a></span>
<span id="cb40-5"><a href="#cb40-5" tabindex="-1"></a><span class="co"># setup search</span></span>
<span id="cb40-6"><a href="#cb40-6" tabindex="-1"></a>search <span class="op">=</span> client.search(</span>
<span id="cb40-7"><a href="#cb40-7" tabindex="-1"></a>    collections<span class="op">=</span>[<span class="st">"HLSL30.v2.0"</span>],</span>
<span id="cb40-8"><a href="#cb40-8" tabindex="-1"></a>    intersects<span class="op">=</span>Point(<span class="op">-</span><span class="fl">73.97</span>, <span class="fl">40.78</span>),</span>
<span id="cb40-9"><a href="#cb40-9" tabindex="-1"></a>    datetime<span class="op">=</span><span class="st">"2021-02-01/2021-03-30"</span>,</span>
<span id="cb40-10"><a href="#cb40-10" tabindex="-1"></a>) <span class="co"># nasa cmr cloud cover filtering is currently broken: https://github.com/nasa/cmr-stac/issues/239</span></span>
<span id="cb40-11"><a href="#cb40-11" tabindex="-1"></a></span>
<span id="cb40-12"><a href="#cb40-12" tabindex="-1"></a><span class="co"># retrieve search results</span></span>
<span id="cb40-13"><a href="#cb40-13" tabindex="-1"></a>items <span class="op">=</span> search.item_collection()</span>
<span id="cb40-14"><a href="#cb40-14" tabindex="-1"></a><span class="bu">print</span>(<span class="bu">len</span>(items))</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code><span><span class="fl">5</span></span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb42">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb42-1"><a href="#cb42-1" tabindex="-1"></a>items_sorted <span class="op">=</span> <span class="bu">sorted</span>(items, key<span class="op">=</span><span class="kw">lambda</span> x: x.properties[<span class="st">"eo:cloud_cover"</span>]) <span class="co"># sorting and then selecting by cloud cover</span></span>
<span id="cb42-2"><a href="#cb42-2" tabindex="-1"></a>item <span class="op">=</span> items_sorted[<span class="dv">0</span>]</span>
<span id="cb42-3"><a href="#cb42-3" tabindex="-1"></a><span class="bu">print</span>(item)</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>&lt;Item id=HLS.L30.T18TWL.2021039T153324.v2.0&gt;</code></pre>
</div>
<div class="codewrapper sourceCode" id="cb44">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb44-1"><a href="#cb44-1" tabindex="-1"></a><span class="bu">print</span>(item.assets[<span class="st">"browse"</span>].href)</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code><span><span class="st">'https://data.lpdaac.earthdatacloud.nasa.gov/lp-prod-public/HLSL30.020/HLS.L30.T18TWL.2021039T153324.v2.0/HLS.L30.T18TWL.039T153324.v2.0.jpg'</span></span></code></pre>
</div>
<figure><img src="fig/E05/STAC-l8-preview.jpg" alt="thumbnail of the landsat-8 scene" class="figure mx-auto d-block"><div class="figcaption">Thumbnail of the Landsat-8 scene</div>
</figure>
</div>
</div>
</div>
</div>
<div id="public-catalogs-protected-data" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div id="public-catalogs-protected-data" class="callout-inner">
<h3 class="callout-title">Public catalogs, protected data</h3>
<div class="callout-content">
<p>Publicly accessible catalogs and STAC endpoints do not necessarily
imply publicly accessible data. Data providers, in fact, may limit data
access to specific infrastructures and/or require authentication. For
instance, the NASA CMR STAC endpoint considered in the last exercise
offers publicly accessible metadata for the HLS collection, but most of
the linked assets are available only for registered users (the thumbnail
is publicly accessible).</p>
<p>The authentication procedure for dataset with restricted access might
differ depending on the data provider. For the NASA CMR, follow these
steps in order to access data using Python:</p>
<ul>
<li>Create a NASA Earthdata login account <a href="https://urs.earthdata.nasa.gov" class="external-link">here</a>;</li>
<li>Set up a netrc file with your credentials, e.g. by using <a href="https://git.earthdata.nasa.gov/projects/LPDUR/repos/daac_data_download_python/browse/EarthdataLoginSetup.py" class="external-link">this
script</a>;</li>
<li>Define the following environment variables:</li>
</ul>
<div class="codewrapper sourceCode" id="cb46">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb46-1"><a href="#cb46-1" tabindex="-1"></a><span class="im">import</span> os</span>
<span id="cb46-2"><a href="#cb46-2" tabindex="-1"></a>os.environ[<span class="st">"GDAL_HTTP_COOKIEFILE"</span>] <span class="op">=</span> <span class="st">"./cookies.txt"</span></span>
<span id="cb46-3"><a href="#cb46-3" tabindex="-1"></a>os.environ[<span class="st">"GDAL_HTTP_COOKIEJAR"</span>] <span class="op">=</span> <span class="st">"./cookies.txt"</span></span></code></pre>
</div>
</div>
</div>
</div>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Key Points</h3>
<div class="callout-content">
<ul>
<li>Accessing satellite images via the providers’ API enables a more
reliable and scalable data retrieval.</li>
<li>STAC catalogs can be browsed and searched using the same tools and
scripts.</li>
<li>
<code>rioxarray</code> allows you to open and download remote raster
files.</li>
</ul>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</section></section><section id="aio-06-raster-intro"><p>Content from <a href="06-raster-intro.html">Read and visualize raster data</a></p>
<hr>
<p>Last updated on 2025-05-20 |

        <a href="https://github.com/carpentries-incubator/geospatial-python/edit/main/episodes/06-raster-intro.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>How is a raster represented by rioxarray?</li>
<li>How do I read and plot raster data in Python?</li>
<li>How can I handle missing data?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Describe the fundamental attributes of a raster dataset.</li>
<li>Explore raster attributes and metadata using Python.</li>
<li>Read rasters into Python using the <code>rioxarray</code>
package.</li>
<li>Visualize single/multi-band raster data.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<section><h2 class="section-heading" id="raster-data">Raster Data<a class="anchor" aria-label="anchor" href="#raster-data"></a>
</h2>
<hr class="half-width">
<p>In the <a href="01-intro-raster-data.html">first episode</a> of this
course we provided an introduction on what Raster datasets are and how
these divert from vector data. In this episode we will dive more into
raster data and focus on how to work with them. We introduce fundamental
principles, python packages, metadata and raster attributes for working
with this type of data. In addition, we will explore how Python handles
missing and bad data values.</p>
<p>The Python package we will use throughout this episode to handle
raster data is <a href="https://corteva.github.io/rioxarray/stable/" class="external-link"><code>rioxarray</code></a>.
This package is based on the popular <a href="https://rasterio.readthedocs.io/en/latest/" class="external-link"><code>rasterio</code></a>
(which is build upon the GDAL library) for working with raster data and
<a href="https://xarray.pydata.org/en/stable/" class="external-link"><code>xarray</code></a>
for working with multi-dimensional arrays.</p>
<p><code>rioxarray</code> extends <code>xarray</code> by providing
top-level functions like the <a href="https://corteva.github.io/rioxarray/html/rioxarray.html#rioxarray-open-rasterio" class="external-link"><code>open_rasterio</code></a>
function to open raster datasets. Furthermore, it adds a set of methods
to the main objects of the <code>xarray</code> package like the <a href="https://docs.xarray.dev/en/stable/generated/xarray.Dataset.html" class="external-link"><code>Dataset</code></a>
and the <a href="https://docs.xarray.dev/en/stable/generated/xarray.DataArray.html#xarray.DataArray" class="external-link"><code>DataArray</code></a>.
These methods are made available via the <code>rio</code> accessor and
become available from <code>xarray</code> objects after importing
<code>rioxarray</code>.</p>
<div id="exploring-rioxarray-and-getting-help" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div id="exploring-rioxarray-and-getting-help" class="callout-inner">
<h3 class="callout-title">Exploring <code>rioxarray</code> and getting
help</h3>
<div class="callout-content">
<p>Since a lot of the functions, methods and attributes from
<code>rioxarray</code> originate from other packages (mostly
<code>rasterio</code>), the documentation is in some cases limited and
requires a little puzzling. It is therefore recommended to foremost
focus at the notebook´s functionality to use tab completion and go
through the various functionalities. In addition, adding a question mark
<code>?</code> after every function or method offers the opportunity to
see the available options.</p>
<p>For instance if you want to understand the options for rioxarray´s
<code>open_rasterio</code> function:</p>
<div class="codewrapper sourceCode" id="cb1">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a>rioxarray.open_rasterio?</span></code></pre>
</div>
</div>
</div>
</div>
<div id="introduce-the-data" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div id="introduce-the-data" class="callout-inner">
<h3 class="callout-title">Introduce the data</h3>
<div class="callout-content">
<p>In this episode, we will use satellite images from the search that we
have carried out in <a href="05-access-data.html">the episode: “Access
satellite imagery using Python”</a>. Briefly, we have searched for
Sentinel-2 scenes of Rhodes from July 1st to August 31st 2023 that have
less than 1% cloud coverage. The search resulted in 11 scenes. We focus
here on the most recent scene (August 27th), since that would show the
situation after the wildfire, and use this as an example to demonstrate
raster data loading and visualization.</p>
<p>For your convenience, we included the scene of interest among the
datasets that you have already downloaded when following <a href="index.html#setup">the setup instructions</a> (the raster data files
should be in the <code>data/sentinel2</code> directory). You should,
however, be able to download the same datasets “on-the-fly” using the
JSON metadata file that was created in <a href="05-access-data.html">the
previous episode</a> (the file <code>rhodes_sentinel-2.json</code>).</p>
<p>If you choose to work with the provided data (which is advised in
case you are working offline or have a slow/unstable network connection)
you can skip the remaining part of the block and continue with the
following section: <a href="#Load-a-Raster-and-View-Attributes">Load a
Raster and View Attributes</a>.</p>
<p>If you want instead to experiment with downloading the data
on-the-fly, you need to load the file
<code>rhodes_sentinel-2.json</code>, which contains information on where
and how to access the target images from the remote repository:</p>
<div class="codewrapper sourceCode" id="cb2">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a><span class="im">import</span> pystac</span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a>items <span class="op">=</span> pystac.ItemCollection.from_file(<span class="st">"rhodes_sentinel-2.json"</span>)</span></code></pre>
</div>
<p>The loaded item collection is equivalent to the one returned by
<code>pystac_client</code> when querying the API in the <a href="05-access-data.html">the episode: “Access satellite imagery using
Python”</a>. You can thus perform the same actions on it, like accessing
the individual items using their index. Here we select the first item in
the collection, which is the most recent:</p>
<div class="codewrapper sourceCode" id="cb3">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a>item <span class="op">=</span> items[<span class="dv">0</span>]</span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a><span class="bu">print</span>(item)</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>&lt;Item id=S2A_35SNA_20230827_0_L2A&gt;</code></pre>
</div>
<p>In this episode we will consider the red band and the true color
image associated with this scene. They are labelled with the
<code>red</code> and <code>visual</code> keys, respectively, in the
asset dictionary. For each asset, we extract the URL / <code>href</code>
(Hypertext Reference) that point to the file, and store it in a variable
that we can use later on to access the data instead of the raster data
paths:</p>
<div class="codewrapper sourceCode" id="cb5">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a>rhodes_red_href <span class="op">=</span> item.assets[<span class="st">"red"</span>].href  <span class="co"># red band</span></span>
<span id="cb5-2"><a href="#cb5-2" tabindex="-1"></a>rhodes_visual_href <span class="op">=</span> item.assets[<span class="st">"visual"</span>].href  <span class="co"># true color image</span></span></code></pre>
</div>
</div>
</div>
</div>
</section><section><h2 class="section-heading" id="load-a-raster-and-view-attributes">Load a Raster and View Attributes<a class="anchor" aria-label="anchor" href="#load-a-raster-and-view-attributes"></a>
</h2>
<hr class="half-width">
<p>To analyse the burned areas, we are interested in the red band of the
satellite scene. In <a href="/episodes/09-raster-calculations.html">episode 9</a> we will
further explain why the characteristics of that band are interesting in
relation to wildfires. For now, we can load the red band using the
function <a href="https://corteva.github.io/rioxarray/html/rioxarray.html#rioxarray-open-rasterio" class="external-link"><code>rioxarray.open_rasterio()</code></a>:</p>
<div class="codewrapper sourceCode" id="cb6">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a><span class="im">import</span> rioxarray</span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a>rhodes_red <span class="op">=</span> rioxarray.open_rasterio(<span class="st">"data/sentinel2/red.tif"</span>)</span></code></pre>
</div>
<p>The first call to <code>rioxarray.open_rasterio()</code> opens the
file and it returns a <code>xarray.DataArray</code> object. The object
is stored in a variable, i.e. <code>rhodes_red</code>. Reading in the
data with <code>xarray</code> instead of <code>rioxarray</code> also
returns a <code>xarray.DataArray</code>, but the output will not contain
the geospatial metadata (such as projection information). You can use
numpy functions or built-in Python math operators on a
<code>xarray.DataArray</code> just like a numpy array. Calling the
variable name of the <code>DataArray</code> also prints out all of its
metadata information.</p>
<p>By printing the variable we can get a quick look at the shape and
attributes of the data.</p>
<div class="codewrapper sourceCode" id="cb7">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a><span class="bu">print</span>(rhodes_red)</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>&lt;xarray.DataArray (band: 1, y: 10980, x: 10980)&gt; Size: 241MB
[120560400 values with dtype=uint16]
Coordinates:
  * band         (band) int32 4B 1
  * x            (x) float64 88kB 5e+05 5e+05 5e+05 ... 6.098e+05 6.098e+05
  * y            (y) float64 88kB 4.1e+06 4.1e+06 4.1e+06 ... 3.99e+06 3.99e+06
    spatial_ref  int32 4B 0
Attributes:
    AREA_OR_POINT:       Area
    OVR_RESAMPLING_ALG:  AVERAGE
    _FillValue:          0
    scale_factor:        1.0
    add_offset:          0.0</code></pre>
</div>
<p>The output tells us that we are looking at an
<code>xarray.DataArray</code>, with <code>1</code> band,
<code>10980</code> rows, and <code>10980</code> columns. We can also see
the number of pixel values in the <code>DataArray</code>, and the type
of those pixel values, which is unsigned integer (or
<code>uint16</code>). The <code>DataArray</code> also stores different
values for the coordinates of the <code>DataArray</code>. When using
<code>rioxarray</code>, the term coordinates refers to spatial
coordinates like <code>x</code> and <code>y</code> but also the
<code>band</code> coordinate. Each of these sequences of values has its
own data type, like <code>float64</code> for the spatial coordinates and
<code>int64</code> for the <code>band</code> coordinate.</p>
<p>This <code>DataArray</code> object also has a couple of attributes
that are accessed like <code>.rio.crs</code>, <code>.rio.nodata</code>,
and <code>.rio.bounds()</code> (in jupyter you can browse through these
attributes by using <code>tab</code> for auto completion or have a look
at the documentation <a href="https://corteva.github.io/rioxarray/stable/rioxarray.html#rioxarray-rio-accessors" class="external-link">here</a>),
which contains the metadata for the file we opened. Note that many of
the metadata are accessed as attributes without <code>()</code>, however
since <code>bounds()</code> is a method (i.e. a function in an object)
it requires these parentheses this is also the case for
<code>.rio.resolution()</code>.</p>
<div class="codewrapper sourceCode" id="cb9">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a><span class="bu">print</span>(rhodes_red.rio.crs)</span>
<span id="cb9-2"><a href="#cb9-2" tabindex="-1"></a><span class="bu">print</span>(rhodes_red.rio.nodata)</span>
<span id="cb9-3"><a href="#cb9-3" tabindex="-1"></a><span class="bu">print</span>(rhodes_red.rio.bounds())</span>
<span id="cb9-4"><a href="#cb9-4" tabindex="-1"></a><span class="bu">print</span>(rhodes_red.rio.width)</span>
<span id="cb9-5"><a href="#cb9-5" tabindex="-1"></a><span class="bu">print</span>(rhodes_red.rio.height)</span>
<span id="cb9-6"><a href="#cb9-6" tabindex="-1"></a><span class="bu">print</span>(rhodes_red.rio.resolution())</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>EPSG:32635
0
(499980.0, 3990240.0, 609780.0, 4100040.0)
10980
10980
(10.0, -10.0)</code></pre>
</div>
<p>The Coordinate Reference System, or <code>rhodes_red.rio.crs</code>,
is reported as the string <code>EPSG:32635</code>. The
<code>nodata</code> value is encoded as 0 and the bounding box corners
of our raster are represented by the output of <code>.bounds()</code> as
a <code>tuple</code> (like a list but you can’t edit it). The height and
width match what we saw when we printed the <code>DataArray</code>, but
by using <code>.rio.width</code> and <code>.rio.height</code> we can
access these values if we need them in calculations.</p>
</section><section><h2 class="section-heading" id="visualize-a-raster">Visualize a Raster<a class="anchor" aria-label="anchor" href="#visualize-a-raster"></a>
</h2>
<hr class="half-width">
<p>After viewing the attributes of our raster, we can examine the raw
values of the array with <code>.values</code>:</p>
<div class="codewrapper sourceCode" id="cb11">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a>rhodes_red.values</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>array([[[    0,     0,     0, ...,  8888,  9075,  8139],
        [    0,     0,     0, ..., 10444, 10358,  8669],
        [    0,     0,     0, ..., 10346, 10659,  9168],
        ...,
        [    0,     0,     0, ...,  4295,  4289,  4320],
        [    0,     0,     0, ...,  4291,  4269,  4179],
        [    0,     0,     0, ...,  3944,  3503,  3862]]], dtype=uint16)</code></pre>
</div>
<p>This can give us a quick view of the values of our array, but only at
the corners. Since our raster is loaded in python as a
<code>DataArray</code> type, we can plot this in one line similar to a
pandas <code>DataFrame</code> with <code>DataArray.plot()</code>.</p>
<div class="codewrapper sourceCode" id="cb13">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a>rhodes_red.plot()</span></code></pre>
</div>
<figure><img src="fig/E06/rhodes_red_B04.png" alt="raster plot with defualt setting" class="figure mx-auto d-block"><div class="figcaption">Raster plot with rioxarray</div>
</figure><p>Notice that <code>rioxarray</code> helpfully allows us to plot this
raster with spatial coordinates on the x and y axis (this is not the
default in many cases with other functions or libraries). Nice plot!
However, it probably took a while for it to load therefore it would make
sense to resample it.</p>
</section><div class="section level1">
<h1 id="resampling-the-raster-image">Resampling the raster image<a class="anchor" aria-label="anchor" href="#resampling-the-raster-image"></a>
</h1>
<p>The red band image is available as a raster file with 10 m
resolution, which makes it a relatively large file (few hundreds MBs).
In order to keep calculations “manageable” (reasonable execution time
and memory usage) we select here a lower resolution version of the
image, taking advantage of the so-called “pyramidal” structure of
cloud-optimized GeoTIFFs (COGs). COGs, in fact, typically include
multiple lower-resolution versions of the original image, called
“overviews”, in the same file. This allows us to avoid downloading
high-resolution images when only quick previews are required.</p>
<p>Overviews are often computed using powers of 2 as down-sampling (or
zoom) factors. So, typically, the first level overview (index 0)
corresponds to a zoom factor of 2, the second level overview (index 1)
corresponds to a zoom factor of 4, and so on. Here, we open the third
level overview (index 2, zoom factor 8) and check that the resolution is
about 80 m:</p>
<div class="codewrapper sourceCode" id="cb14">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" tabindex="-1"></a><span class="im">import</span> rioxarray</span>
<span id="cb14-2"><a href="#cb14-2" tabindex="-1"></a>rhodes_red_80 <span class="op">=</span> rioxarray.open_rasterio(<span class="st">"data/sentinel2/red.tif"</span>, overview_level<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb14-3"><a href="#cb14-3" tabindex="-1"></a><span class="bu">print</span>(rhodes_red_80.rio.resolution())</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>(79.97086671522214, -79.97086671522214)</code></pre>
</div>
<p>Lets plot this one.</p>
<div class="codewrapper sourceCode" id="cb16">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" tabindex="-1"></a>rhodes_red_80.plot()</span></code></pre>
</div>
<figure><img src="fig/E06/rhodes_red_80_B04.png" alt="raster plot with defualt setting" class="figure mx-auto d-block"><div class="figcaption">Raster plot 80 x 80 meter resolution with
rioxarray</div>
</figure><p>This plot shows the satellite measurement of the band
<code>red</code> for Rhodes before the wildfire. According to the <a href="https://sentinels.copernicus.eu/web/sentinel/technical-guides/sentinel-2-msi/msi-instrument" class="external-link">Sentinel-2
documentaion</a>, this is a band with the central wavelength of 665nm.
It has a spatial resolution of 10m. Note that the <code>band=1</code> in
the image title refers to the ordering of all the bands in the
<code>DataArray</code>, not the Sentinel-2 band number <code>04</code>
that we saw in the pystac search results.</p>
<div id="tool-tip" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div id="tool-tip" class="callout-inner">
<h3 class="callout-title">Tool Tip</h3>
<div class="callout-content">
<p>The option <code>robust=True</code> always forces displaying values
between the 2nd and 98th percentile. Of course, this will not work for
every case.</p>
<div class="codewrapper sourceCode" id="cb17">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" tabindex="-1"></a>rhodes_red_80.plot(robust<span class="op">=</span><span class="va">True</span>)</span></code></pre>
</div>
<figure><img src="fig/E06/rhodes_red_80_B04_robust.png" alt="raster plot with robust setting" class="figure mx-auto d-block"><div class="figcaption">Raster plot using the “robust” setting</div>
</figure><p>Now the color limit is set in a way fitting most of the values in the
image. We have a better view of the ground pixels.</p>
<p>For a customized displaying range, you can also manually specifying
the keywords <code>vmin</code> and <code>vmax</code>. For example
ploting between <code>100</code> and <code>2000</code>:</p>
<div class="codewrapper sourceCode" id="cb18">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" tabindex="-1"></a>rhodes_red_80.plot(vmin<span class="op">=</span><span class="dv">100</span>, vmax<span class="op">=</span><span class="dv">2000</span>)</span></code></pre>
</div>
<figure><img src="fig/E06/rhodes_red_80_B04_vmin100_vmax2000.png" alt="raster plot with robust setting" class="figure mx-auto d-block"><div class="figcaption">Raster plot using vmin 100 and vmax 2000</div>
</figure><p>More options can be consulted <a href="https://docs.xarray.dev/en/v2024.02.0/generated/xarray.plot.imshow.html" class="external-link">here</a>.
You will notice that these parameters are part of the
<code>imshow</code> method from the plot function. Since plot originates
from matplotlib and is so widely used, your python environment helps you
to interpret the parameters without having to specify the method. It is
a service to help you, but can be confusing when teaching it. We will
explain more about this below.</p>
</div>
</div>
</div>
<div class="section level2">
<h2 id="view-raster-coordinate-reference-system-crs-in-python">View Raster Coordinate Reference System (CRS) in Python<a class="anchor" aria-label="anchor" href="#view-raster-coordinate-reference-system-crs-in-python"></a>
</h2>
<p>Another information that we’re interested in is the CRS, and it can
be accessed with <code>.rio.crs</code>. We introduced the concept of a
CRS in <a href="03-crs.html">an earlier episode</a>. Now we will see how
features of the CRS appear in our data file and what meanings they have.
We can view the CRS string associated with our DataArray’s
<code>rio</code> object using the <code>crs</code> attribute.</p>
<div class="codewrapper sourceCode" id="cb19">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" tabindex="-1"></a><span class="bu">print</span>(rhodes_red_80.rio.crs)</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code><span><span class="va">EPSG</span><span class="op">:</span><span class="fl">32635</span></span></code></pre>
</div>
<p>To print the EPSG code number as an <code>int</code>, we use the
<code>.to_epsg()</code> method (which originally is part of rasterio <a href="https://rasterio.readthedocs.io/en/stable/api/rasterio.crs.html#rasterio.crs.CRS.to_epsg" class="external-link"><code>to_epsg</code></a>):</p>
<div class="codewrapper sourceCode" id="cb21">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" tabindex="-1"></a>rhodes_red_80.rio.crs.to_epsg()</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code><span><span class="fl">32635</span></span></code></pre>
</div>
<p>EPSG codes are great for succinctly representing a particular
coordinate reference system. But what if we want to see more details
about the CRS, like the units? For that, we can use <a href="https://pyproj4.github.io/pyproj/stable/api/index.html" class="external-link"><code>pyproj</code></a>
, a library for representing and working with coordinate reference
systems.</p>
<div class="codewrapper sourceCode" id="cb23">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" tabindex="-1"></a><span class="im">from</span> pyproj <span class="im">import</span> CRS</span>
<span id="cb23-2"><a href="#cb23-2" tabindex="-1"></a>epsg <span class="op">=</span> rhodes_red_80.rio.crs.to_epsg()</span>
<span id="cb23-3"><a href="#cb23-3" tabindex="-1"></a>crs <span class="op">=</span> CRS(epsg)</span>
<span id="cb23-4"><a href="#cb23-4" tabindex="-1"></a>crs</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>&lt;Projected CRS: EPSG:32635&gt;
Name: WGS 84 / UTM zone 35N
Axis Info [cartesian]:
- E[east]: Easting (metre)
- N[north]: Northing (metre)
Area of Use:
- name: Between 24°E and 30°E, northern hemisphere between equator and 84°N, onshore and offshore. Belarus. Bulgaria. Central African Republic. Democratic Republic of the Congo (Zaire). Egypt. Estonia. Finland. Greece. Latvia. Lesotho. Libya. Lithuania. Moldova. Norway. Poland. Romania. Russian Federation. Sudan. Svalbard. Türkiye (Turkey). Uganda. Ukraine.
- bounds: (24.0, 0.0, 30.0, 84.0)
Coordinate Operation:
- name: UTM zone 35N
- method: Transverse Mercator
Datum: World Geodetic System 1984 ensemble
- Ellipsoid: WGS 84
- Prime Meridian: Greenwich</code></pre>
</div>
<p>The <code>CRS</code> class from the <code>pyproj</code> library
allows us to create a <code>CRS</code> object with methods and
attributes for accessing specific information about a CRS, or the
detailed summary shown above.</p>
<p>A particularly useful attribute is <a href="https://pyproj4.github.io/pyproj/stable/api/crs/crs.html#pyproj.crs.CRS.area_of_use" class="external-link"><code>area_of_use</code></a>,
which shows the geographic bounds that the CRS is intended to be
used.</p>
<div class="codewrapper sourceCode" id="cb25">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" tabindex="-1"></a>crs.area_of_use</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code><span><span class="fu">AreaOfUse</span><span class="op">(</span>west<span class="op">=</span><span class="fl">24.0</span>, south<span class="op">=</span><span class="fl">0.0</span>, east<span class="op">=</span><span class="fl">30.0</span>, north<span class="op">=</span><span class="fl">84.0</span>, name<span class="op">=</span><span class="st">'Between 24°E and 30°E, northern hemisphere between equator and 84°N, onshore and offshore. Belarus. Bulgaria. Central African Republic. Democratic Republic of the Congo (Zaire). Egypt. Estonia. Finland. Greece. Latvia. Lesotho. Libya. Lithuania. Moldova. Norway. Poland. Romania. Russian Federation. Sudan. Svalbard. Türkiye (Turkey). Uganda. Ukraine.'</span><span class="op">)</span></span></code></pre>
</div>
<div id="exercise-find-the-axes-units-of-the-crs" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="exercise-find-the-axes-units-of-the-crs" class="callout-inner">
<h3 class="callout-title">Exercise: find the axes units of the CRS</h3>
<div class="callout-content">
<p>What units are our data in? See if you can find a method to examine
this information using <code>help(crs)</code> or
<code>dir(crs)</code></p>
</div>
</div>
</div>
<div id="accordionSolution1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution1" aria-expanded="false" aria-controls="collapseSolution1">
  <h4 class="accordion-header" id="headingSolution1"> Show me the solution </h4>
</button>
<div id="collapseSolution1" class="accordion-collapse collapse" data-bs-parent="#accordionSolution1" aria-labelledby="headingSolution1">
<div class="accordion-body">
<p><code>crs.axis_info</code> tells us that the CRS for our raster has
two axis and both are in meters. We could also get this information from
the attribute <code>rhodes_red_80.rio.crs.linear_units</code>.</p>
</div>
</div>
</div>
</div>
<div class="section level3">
<h3 id="understanding-pyproj-crs-summary">Understanding pyproj CRS Summary<a class="anchor" aria-label="anchor" href="#understanding-pyproj-crs-summary"></a>
</h3>
<p>Let’s break down the pieces of the <code>pyproj</code> CRS summary.
The string contains all of the individual CRS elements that Python or
another GIS might need, separated into distinct sections, and datum.</p>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>&lt;Projected CRS: EPSG:32635&gt;
Name: WGS 84 / UTM zone 35N
Axis Info [cartesian]:
- E[east]: Easting (metre)
- N[north]: Northing (metre)
Area of Use:
- name: Between 24°E and 30°E, northern hemisphere between equator and 84°N, onshore and offshore. Belarus. Bulgaria. Central African Republic. Democratic Republic of the Congo (Zaire). Egypt. Estonia. Finland. Greece. Latvia. Lesotho. Libya. Lithuania. Moldova. Norway. Poland. Romania. Russian Federation. Sudan. Svalbard. Türkiye (Turkey). Uganda. Ukraine.
- bounds: (24.0, 0.0, 30.0, 84.0)
Coordinate Operation:
- name: UTM zone 35N
- method: Transverse Mercator
Datum: World Geodetic System 1984 ensemble
- Ellipsoid: WGS 84
- Prime Meridian: Greenwich</code></pre>
</div>
<ul>
<li>
<strong>Name</strong> of the projection is UTM zone 35N (UTM has 60
zones, each 6-degrees of longitude in width). The underlying datum is
WGS84.</li>
<li>
<strong>Axis Info</strong>: the CRS shows a Cartesian system with
two axes, easting and northing, in meter units.</li>
<li>
<strong>Area of Use</strong>: the projection is used for a
particular range of longitudes <code>24°E to 30°E</code> in the northern
hemisphere (<code>0.0°N to 84.0°N</code>)</li>
<li>
<strong>Coordinate Operation</strong>: the operation to project the
coordinates (if it is projected) onto a cartesian (x, y) plane.
Transverse Mercator is accurate for areas with longitudinal widths of a
few degrees, hence the distinct UTM zones.</li>
<li>
<strong>Datum</strong>: Details about the datum, or the reference
point for coordinates. <code>WGS 84</code> and <code>NAD 1983</code> are
common datums. <code>NAD 1983</code> is <a href="https://en.wikipedia.org/wiki/Datum_of_2022" class="external-link">set to be replaced in
2022</a>.</li>
</ul>
<p>Note that the zone is unique to the UTM projection. Not all CRSs will
have a zone. Below is a simplified view of US UTM zones.</p>
<figure><img src="fig/E03/Utm-zones-USA.svg" alt="UTM zones across the CONUS" class="figure mx-auto d-block"><div class="figcaption">The UTM zones across the continental United
States (Chrismurf at English Wikipedia, via <a href="https://en.wikipedia.org/wiki/Universal_Transverse_Mercator_coordinate_system#/media/File:Utm-zones-USA.svg" class="external-link">Wikimedia
Commons</a> (CC-BY))</div>
</figure>
</div>
</div>
<div class="section level2">
<h2 id="calculate-raster-statistics">Calculate Raster Statistics<a class="anchor" aria-label="anchor" href="#calculate-raster-statistics"></a>
</h2>
<p>It is useful to know the minimum or maximum values of a raster
dataset. We can compute these and other descriptive statistics with
<code>min</code>, <code>max</code>, <code>mean</code>, and
<code>std</code>.</p>
<div class="codewrapper sourceCode" id="cb28">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" tabindex="-1"></a><span class="bu">print</span>(rhodes_red_80.<span class="bu">min</span>())</span>
<span id="cb28-2"><a href="#cb28-2" tabindex="-1"></a><span class="bu">print</span>(rhodes_red_80.<span class="bu">max</span>())</span>
<span id="cb28-3"><a href="#cb28-3" tabindex="-1"></a><span class="bu">print</span>(rhodes_red_80.mean())</span>
<span id="cb28-4"><a href="#cb28-4" tabindex="-1"></a><span class="bu">print</span>(rhodes_red_80.std())</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>&lt;xarray.DataArray ()&gt; Size: 2B
array(0, dtype=uint16)
Coordinates:
    spatial_ref  int32 4B 0
&lt;xarray.DataArray ()&gt; Size: 2B
array(7277, dtype=uint16)
Coordinates:
    spatial_ref  int32 4B 0
&lt;xarray.DataArray ()&gt; Size: 8B
array(404.07532588)
Coordinates:
    spatial_ref  int32 4B 0
&lt;xarray.DataArray ()&gt; Size: 8B
array(527.5557502)
Coordinates:
    spatial_ref  int32 4B 0</code></pre>
</div>
<p>The information above includes a report of the min, max, mean, and
standard deviation values, along with the data type. If we want to see
specific quantiles, we can use xarray’s <code>.quantile()</code> method.
For example for the 25% and 75% quantiles:</p>
<div class="codewrapper sourceCode" id="cb30">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" tabindex="-1"></a><span class="bu">print</span>(rhodes_red_80.quantile([<span class="fl">0.25</span>, <span class="fl">0.75</span>]))</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>&lt;xarray.DataArray (quantile: 2)&gt; Size: 16B
array([165., 315.])
Coordinates:
  * quantile  (quantile) float64 16B 0.25 0.75</code></pre>
</div>
<div id="data-tip---numpy-methods" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div id="data-tip---numpy-methods" class="callout-inner">
<h3 class="callout-title">Data Tip - NumPy methods</h3>
<div class="callout-content">
<p>You could also get each of these values one by one using
<code>numpy</code>.</p>
<div class="codewrapper sourceCode" id="cb32">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" tabindex="-1"></a><span class="im">import</span> numpy</span>
<span id="cb32-2"><a href="#cb32-2" tabindex="-1"></a><span class="bu">print</span>(numpy.percentile(rhodes_red_80, <span class="dv">25</span>))</span>
<span id="cb32-3"><a href="#cb32-3" tabindex="-1"></a><span class="bu">print</span>(numpy.percentile(rhodes_red_80, <span class="dv">75</span>))</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code><span><span class="fl">165.0</span></span>
<span><span class="fl">315.0</span></span></code></pre>
</div>
<p>You may notice that <code>rhodes_red_80.quantile</code> and
<code>numpy.percentile</code> didn’t require an argument specifying the
axis or dimension along which to compute the quantile. This is because
<code>axis=None</code> is the default for most numpy functions, and
therefore <code>dim=None</code> is the default for most xarray methods.
It’s always good to check out the docs on a function to see what the
default arguments are, particularly when working with multi-dimensional
image data. To do so, we can
use<code>help(rhodes_red_80.quantile)</code> or
<code>?rhodes_red_80.percentile</code> if you are using jupyter notebook
or jupyter lab.</p>
</div>
</div>
</div>
</div>
<div class="section level2">
<h2 id="dealing-with-missing-data">Dealing with Missing Data<a class="anchor" aria-label="anchor" href="#dealing-with-missing-data"></a>
</h2>
<p>So far, we have visualized a band of a Sentinel-2 scene and
calculated its statistics. However, as you can see on the image it also
contains an artificial band to the top left where data is missing. In
order to calculate meaningfull statistics, we need to take missing data
into account. Raster data often has a “no data value” associated with it
and for raster datasets read in by <code>rioxarray</code>. This value is
referred to as <code>nodata</code>. This is a value assigned to pixels
where data is missing or no data were collected. There can be different
cases that cause missing data, and it’s common for other values in a
raster to represent different cases. The most common example is missing
data at the edges of rasters.</p>
<p>By default the shape of a raster is always rectangular. So if we have
a dataset that has a shape that isn’t rectangular, like most satellite
images, some pixels at the edge of the raster will have no data values.
This often happens when the data were collected by a sensor which only
flew over some part of a defined region and is also almost by default
because of the fact that the earth is not flat and that we work with
geographic and projected coordinate system.</p>
<p>To check the value of <a href="https://corteva.github.io/rioxarray/html/rioxarray.html#rioxarray.raster_array.RasterArray.nodata" class="external-link"><code>nodata</code></a>
of this dataset you can use:</p>
<div class="codewrapper sourceCode" id="cb34">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" tabindex="-1"></a>rhodes_red_80.rio.nodata</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code><span><span class="fl">0</span></span></code></pre>
</div>
<p>You will find out that this is 0. When we have plotted the band data,
or calculated statistics, the missing value was not distinguished from
other values. Missing data may cause some unexpected results.</p>
<p>To distinguish missing data from real data, one possible way is to
use <code>nan</code>(which stands for Not a Number) to represent them.
This can be done by specifying <code>masked=True</code> when loading the
raster. Let us reload our data and put it into a different variable with
the mask:</p>
<div class="codewrapper sourceCode" id="cb36">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" tabindex="-1"></a>rhodes_red_mask_80 <span class="op">=</span> rioxarray.open_rasterio(<span class="st">"data/sentinel2/red.tif"</span>, masked<span class="op">=</span><span class="va">True</span>, overview_level<span class="op">=</span><span class="dv">2</span>)</span></code></pre>
</div>
<p>Let us have a look at the data.</p>
<div class="codewrapper sourceCode" id="cb37">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" tabindex="-1"></a><span class="bu">print</span>(rhodes_red_mask_80)</span></code></pre>
</div>
<p>One can also use the <code>where</code> function, which is standard
python functionality, to select all the pixels which are different from
the <code>nodata</code> value of the raster:</p>
<div class="codewrapper sourceCode" id="cb38">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" tabindex="-1"></a>rhodes_red_altmask_80 <span class="op">=</span> rhodes_red_80.where(rhodes_red_80<span class="op">!=</span>rhodes_red_80.rio.nodata)</span></code></pre>
</div>
<p>Either way will change the <code>nodata</code> value from 0 to
<code>nan</code>. Now if we compute the statistics again, the missing
data will not be considered. Let´s compare them:</p>
<div class="codewrapper sourceCode" id="cb39">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1" tabindex="-1"></a><span class="bu">print</span>(rhodes_red_80.<span class="bu">min</span>())</span>
<span id="cb39-2"><a href="#cb39-2" tabindex="-1"></a><span class="bu">print</span>(rhodes_red_mask_80.<span class="bu">min</span>())</span>
<span id="cb39-3"><a href="#cb39-3" tabindex="-1"></a><span class="bu">print</span>(rhodes_red_80.<span class="bu">max</span>())</span>
<span id="cb39-4"><a href="#cb39-4" tabindex="-1"></a><span class="bu">print</span>(rhodes_red_mask_80.<span class="bu">max</span>())</span>
<span id="cb39-5"><a href="#cb39-5" tabindex="-1"></a><span class="bu">print</span>(rhodes_red_80.mean())</span>
<span id="cb39-6"><a href="#cb39-6" tabindex="-1"></a><span class="bu">print</span>(rhodes_red_mask_80.mean())</span>
<span id="cb39-7"><a href="#cb39-7" tabindex="-1"></a><span class="bu">print</span>(rhodes_red_80.std())</span>
<span id="cb39-8"><a href="#cb39-8" tabindex="-1"></a><span class="bu">print</span>(rhodes_red_mask_80.std())</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>&lt;xarray.DataArray ()&gt; Size: 2B
array(0, dtype=uint16)
Coordinates:
    spatial_ref  int32 4B 0
&lt;xarray.DataArray ()&gt; Size: 4B
array(1., dtype=float32)
Coordinates:
    spatial_ref  int32 4B 0
&lt;xarray.DataArray ()&gt; Size: 2B
array(7277, dtype=uint16)
Coordinates:
    spatial_ref  int32 4B 0
&lt;xarray.DataArray ()&gt; Size: 4B
array(7277., dtype=float32)
Coordinates:
    spatial_ref  int32 4B 0
&lt;xarray.DataArray ()&gt; Size: 8B
array(404.07532588)
Coordinates:
    spatial_ref  int32 4B 0
&lt;xarray.DataArray ()&gt; Size: 4B
array(461.78833, dtype=float32)
Coordinates:
    spatial_ref  int32 4B 0
&lt;xarray.DataArray ()&gt; Size: 8B
array(527.5557502)
Coordinates:
    spatial_ref  int32 4B 0
&lt;xarray.DataArray ()&gt; Size: 4B
array(539.82855, dtype=float32)
Coordinates:
    spatial_ref  int32 4B 0</code></pre>
</div>
<p>And if we plot the image, the <code>nodata</code> pixels are not
shown because they are not 0 anymore:</p>
<figure><img src="fig/E06/rhodes_red_80_B04_robust_nan.png" alt="raster plot masking missing values" class="figure mx-auto d-block"><div class="figcaption">Raster plot after masking out missing
values</div>
</figure><p>One should notice that there is a side effect of using
<code>nan</code> instead of <code>0</code> to represent the missing
data: the data type of the <code>DataArray</code> was changed from
integers to float (as can be seen when we printed the statistics). This
needs to be taken into consideration when the data type matters in your
application.</p>
</div>
<div class="section level2">
<h2 id="raster-bands">Raster Bands<a class="anchor" aria-label="anchor" href="#raster-bands"></a>
</h2>
<p>So far we looked into a single band raster, i.e. the <code>red</code>
band of a Sentinel-2 scene. However, for certain applications it is
helpful to visualize the true-color image of the region. This is
provided as a multi-band raster – a raster dataset that contains more
than one band.</p>
<figure><img src="fig/E06/single_multi_raster.png" alt="multi-band raster" class="figure mx-auto d-block"><div class="figcaption">Sketch of a multi-band raster image</div>
</figure><p>The <code>visual</code> asset in the Sentinel-2 scene is a multiband
asset. Similar to the red band, we can load it by:</p>
<div class="codewrapper sourceCode" id="cb41">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb41-1"><a href="#cb41-1" tabindex="-1"></a>rhodes_visual <span class="op">=</span> rioxarray.open_rasterio(<span class="st">'data/sentinel2/visual.tif'</span>, overview_level<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb41-2"><a href="#cb41-2" tabindex="-1"></a>rhodes_visual</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>&lt;xarray.DataArray (band: 3, y: 1373, x: 1373)&gt; Size: 6MB
[5655387 values with dtype=uint8]
Coordinates:
  * band         (band) int32 12B 1 2 3
  * x            (x) float64 11kB 5e+05 5.001e+05 ... 6.097e+05 6.097e+05
  * y            (y) float64 11kB 4.1e+06 4.1e+06 4.1e+06 ... 3.99e+06 3.99e+06
    spatial_ref  int32 4B 0
Attributes:
    AREA_OR_POINT:       Area
    OVR_RESAMPLING_ALG:  AVERAGE
    _FillValue:          0
    scale_factor:        1.0
    add_offset:          0.0</code></pre>
</div>
<p>The band number comes first when GeoTiffs are read with the
<code>.open_rasterio()</code> function. As we can see in the
<code>xarray.DataArray</code> object, the shape is now
<code>(band: 3, y: 1373, x: 1373)</code>, with three bands in the
<code>band</code> dimension. It’s always a good idea to examine the
shape of the raster array you are working with and make sure it’s what
you expect. Many functions, especially the ones that plot images, expect
a raster array to have a particular shape. One can also check the shape
using the <a href="https://docs.xarray.dev/en/latest/generated/xarray.DataArray.shape.html" class="external-link"><code>.shape</code></a>
attribute:</p>
<div class="codewrapper sourceCode" id="cb43">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb43-1"><a href="#cb43-1" tabindex="-1"></a>rhodes_visual.shape</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>(3, 1373, 1373)</code></pre>
</div>
<p>One can visualize the multi-band data with the
<code>DataArray.plot.imshow()</code> function:</p>
<div class="codewrapper sourceCode" id="cb45">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb45-1"><a href="#cb45-1" tabindex="-1"></a>rhodes_visual.plot.imshow()</span></code></pre>
</div>
<figure><img src="fig/E06/rhodes_multiband_80.png" alt="true-color image overview" class="figure mx-auto d-block"><div class="figcaption">Overview of the true-color image (multi-band
raster)</div>
</figure><p>Note that the <code>DataArray.plot.imshow()</code> function makes
assumptions about the shape of the input DataArray, that since it has
three channels, the correct colormap for these channels is RGB. It does
not work directly on image arrays with more than 3 channels. One can
replace one of the RGB channels with another band, to make a false-color
image.</p>
<div id="exercise-set-the-plotting-aspect-ratio" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="exercise-set-the-plotting-aspect-ratio" class="callout-inner">
<h3 class="callout-title">Exercise: set the plotting aspect ratio</h3>
<div class="callout-content">
<p>As seen in the figure above, the true-color image is stretched. Let’s
visualize it with the right aspect ratio. You can use the <a href="https://xarray.pydata.org/en/stable/generated/xarray.DataArray.plot.imshow.html" class="external-link">documentation</a>
of <code>DataArray.plot.imshow()</code>.</p>
</div>
</div>
</div>
<div id="accordionSolution2" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution2" aria-expanded="false" aria-controls="collapseSolution2">
  <h4 class="accordion-header" id="headingSolution2"> Show me the solution </h4>
</button>
<div id="collapseSolution2" class="accordion-collapse collapse" data-bs-parent="#accordionSolution2" aria-labelledby="headingSolution2">
<div class="accordion-body">
<p>Since we know the height/width ratio is 1:1 (check the
<code>rio.height</code> and <code>rio.width</code> attributes), we can
set the aspect ratio to be 1. For example, we can choose the size to be
5 inches, and set <code>aspect=1</code>. Note that according to the <a href="https://xarray.pydata.org/en/stable/generated/xarray.DataArray.plot.imshow.html" class="external-link">documentation</a>
of <code>DataArray.plot.imshow()</code>, when specifying the
<code>aspect</code> argument, <code>size</code> also needs to be
provided.</p>
<div class="codewrapper sourceCode" id="cb46">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb46-1"><a href="#cb46-1" tabindex="-1"></a>rhodes_visual.plot.imshow(size<span class="op">=</span><span class="dv">5</span>, aspect<span class="op">=</span><span class="dv">1</span>)</span></code></pre>
</div>
<figure><img src="fig/E06/rhodes_multiband_80_equal_aspect.png" alt="raster plot with correct aspect ratio" class="figure mx-auto d-block"><div class="figcaption">Overview of the true-color image with the
correct aspect ratio</div>
</figure>
</div>
</div>
</div>
</div>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Key Points</h3>
<div class="callout-content">
<ul>
<li>
<code>rioxarray</code> and <code>xarray</code> are for working with
multidimensional arrays like pandas is for working with tabular
data.</li>
<li>
<code>rioxarray</code> stores CRS information as a CRS object that
can be converted to an EPSG code or PROJ4 string.</li>
<li>Missing raster data are filled with nodata values, which should be
handled with care for statistics and visualization.</li>
</ul>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</div>
</div></section><section id="aio-07-vector-data-in-python"><p>Content from <a href="07-vector-data-in-python.html">Vector data in Python</a></p>
<hr>
<p>Last updated on 2025-05-20 |

        <a href="https://github.com/carpentries-incubator/geospatial-python/edit/main/episodes/07-vector-data-in-python.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>How can I read, inspect, and process spatial objects, such as
points, lines, and polygons?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Load spatial objects.</li>
<li>Select the spatial objects within a bounding box.</li>
<li>Perform a CRS conversion of spatial objects.</li>
<li>Select features of spatial objects.</li>
<li>Match objects in two datasets based on their spatial
relationships.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<section><h2 class="section-heading" id="introduction">Introduction<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h2>
<hr class="half-width">
<p>In the preceding episodes, we have prepared, selected and downloaded
raster data from before and after the wildfire event in the summer of
2023 on the Greek island of Rhodes. To evaluate the impact of this
wildfire on the vital infrastructure and built-up areas we are going to
create a subset of vector data representing these assets. In this
episode you will learn how to extract vector data with specific
characteristics like the type of attributes or their locations. The
dataset that we will generate in this episode can lateron be confronted
with scorched areas which we determine by analyzing the satellite images
<a href="09-raster-calculations.html">Episode 9: Raster Calculations in
Python</a>.</p>
<p>We’ll be examining vector datasets that represent the valuable
assests of Rhodes. As mentioned in <a href="02-intro-vector-data.html">Episode 2: Introduction to Vector
Data</a>, vector data uses points, lines, and polygons to depict
specific features on the Earth’s surface. These geographic elements can
have one or more attributes, like ‘name’ and ‘population’ for a city. In
this episode we’ll be using two open data sources: the Database of
Global Administrative Areas (GADM) dataset to generate a polygon for the
island of Rhodes and and Open Street Map data for the vital
infrastructure and valuable assets.</p>
<p>To handle the vector data in python we use the package <a href="https://geopandas.org/en/stable/" class="external-link"><code>geopandas</code></a>. This
package allows us to open, manipulate, and write vector dataset through
python.</p>
<figure><img src="fig/E07/pandas_geopandas_relation.png" alt="Pandas and Geopandas" class="figure mx-auto d-block"></figure><p><code>geopandas</code> enhances the widely-used <code>pandas</code>
library for data analysis by extending its functionality to geospatial
applications. The primary <code>pandas</code> objects
(<code>Series</code> and <code>DataFrame</code>) are extended to
<code>geopandas</code> objects (<code>GeoSeries</code> and
<code>GeoDataFrame</code>). This extension is achieved by incorporating
geometric types, represented in Python using the <code>shapely</code>
library, and by offering dedicated methods for spatial operations like
<code>union</code>, <code>spatial joins</code> and
<code>intersect</code>. In order to understand how geopandas works, it
is good to provide a brief explanation of the relationship between
<code>Series</code>, a <code>DataFrame</code>, <code>GeoSeries</code>,
and a <code>GeoDataFrame</code>:</p>
<ul>
<li>A <code>Series</code> is a one-dimensional array with an axis that
can hold any data type (integers, strings, floating-point numbers,
Python objects, etc.)</li>
<li>A <code>DataFrame</code> is a two-dimensional labeled data structure
with columns that can potentially hold different types of data.</li>
<li>A <code>GeoSeries</code> is a <code>Series</code> object designed to
store shapely geometry objects.</li>
<li>A <code>GeoDataFrame</code> is an extended
<code>pandas.DataFrame</code> that includes a column with geometry
objects, which is a <code>GeoSeries</code>.</li>
</ul>
<div id="introduce-the-vector-data" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div id="introduce-the-vector-data" class="callout-inner">
<h3 class="callout-title">Introduce the Vector Data</h3>
<div class="callout-content">
<p>In this episode, we will use the downloaded vector data from the
<code>data</code> directory. Please refer to the <a href="index.html#setup">setup page</a> on where to download the data. Note
that we manipulated that data a little for the purposes of this
workshop. The link to the original source can be found on the <a href="index.html#setup">setup page</a>.</p>
</div>
</div>
</div>
</section><section><h2 class="section-heading" id="get-the-administration-boundary-of-study-area">Get the administration boundary of study area<a class="anchor" aria-label="anchor" href="#get-the-administration-boundary-of-study-area"></a>
</h2>
<hr class="half-width">
<p>The first thing we want to do is to extract a polygon containing the
boundary of the island of Rhodes from Greece. For this we will use the
<a href="https://gadm.org/download_country.html" class="external-link">GADM dataset</a> layer
<code>ADM_ADM_3.gpkg</code> for Greece. For your convenience we saved a
copy at: <code>data/data/gadm/ADM_ADM_3.gpkg</code> We will use the
<code>geopandas</code> package to load the file and use the
<code>read_file</code> function <a href="https://geopandas.org/en/stable/docs/user_guide/io.html" class="external-link">see</a>.
Note that geopandas is often abbreviated as gpd.</p>
<div class="codewrapper sourceCode" id="cb1">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="im">import</span> geopandas <span class="im">as</span> gpd</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a>gdf_greece <span class="op">=</span> gpd.read_file(<span class="st">'data/gadm/ADM_ADM_3.gpkg'</span>)</span></code></pre>
</div>
<p>We can print out the <code>gdf_greece</code>variable:</p>
<div class="codewrapper sourceCode" id="cb2">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a>gdf_greece</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>GID_3 GID_0 COUNTRY    GID_1                       NAME_1  \
0     GRC.1.1.1_1   GRC  Greece  GRC.1_1                       Aegean
1     GRC.1.1.2_1   GRC  Greece  GRC.1_1                       Aegean
2     GRC.1.1.3_1   GRC  Greece  GRC.1_1                       Aegean
..            ...   ...     ...      ...                          ...
324  GRC.8.2.24_1   GRC  Greece  GRC.8_1  Thessaly and Central Greece
325  GRC.8.2.25_1   GRC  Greece  GRC.8_1  Thessaly and Central Greece

                      NL_NAME_1      GID_2        NAME_2      NL_NAME_2  \
0                        Αιγαίο  GRC.1.1_1  North Aegean  Βόρειο Αιγαίο
1                        Αιγαίο  GRC.1.1_1  North Aegean  Βόρειο Αιγαίο
2                        Αιγαίο  GRC.1.1_1  North Aegean  Βόρειο Αιγαίο
..                          ...        ...           ...            ...
324  Θεσσαλία και Στερεά Ελλάδα  GRC.8.2_1      Thessaly       Θεσσαλία
325  Θεσσαλία και Στερεά Ελλάδα  GRC.8.2_1      Thessaly       Θεσσαλία
...
324  POLYGON ((22.81903 39.27344, 22.81884 39.27332...
325  POLYGON ((23.21375 39.36514, 23.21272 39.36469...

[326 rows x 17 columns]</code></pre>
</div>
<p>The data are read into the variable fields as a
<code>GeoDataFrame</code>. This is an extened data format of
<code>pandas.DataFrame</code>, with an extra column
<code>geometry</code>. To explore the dataframe you can call this
variable just like a <code>pandas dataframe</code> by using functions
like <code>.shape</code>, <code>.head</code> and <code>.tail</code>
etc.</p>
<p>To visualize the polygons we can use the <a href="https://geopandas.org/en/stable/docs/user_guide/mapping.html" class="external-link"><code>plot()</code></a>
function to the <code>GeoDataFrame</code> we have loaded
<code>gdf_greece</code>:</p>
<div class="codewrapper sourceCode" id="cb4">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a>gdf_greece.plot()</span></code></pre>
</div>
<figure><img src="fig/E07/greece_administration_areas.png" alt="greece_administrations" class="figure mx-auto d-block"></figure><p>If you want to interactively explore your data you can use the <a href="https://geopandas.org/en/stable/docs/user_guide/interactive_mapping.html" class="external-link"><code>.explore</code></a>
function in geopandas:</p>
<div class="codewrapper sourceCode" id="cb5">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a>gdf_greece.explore()</span></code></pre>
</div>
<p>In this interactive map you can easily zoom in and out and hover over
the polygons to see which attributes, stored in the rows of your
GeoDataFrame, are related to each polygon.</p>
<p>Next, we’ll focus on isolating the administrative area of Rhodes
Island. Once you hover over the polygon of Rhodos (the relatively big
island to the east) you will find out that the label <code>Rhodos</code>
is stored in the <code>NAME_3</code> column of <code>gdf_greece</code>,
where Rhodes Island is listed as <code>Rhodos</code>. Since our goal is
to have a boundary of Rhodes, we’ll now create a new variable that
exclusively represents Rhodes Island.</p>
<p>To select an item in our GeoDataFrame with a specific value is done
the same way in which this is done in a pandas <code>DataFrame</code>
using <a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.loc.html" class="external-link"><code>.loc</code></a>.</p>
<div class="codewrapper sourceCode" id="cb6">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a>gdf_rhodes <span class="op">=</span> gdf_greece.loc[gdf_greece[<span class="st">'NAME_3'</span>]<span class="op">==</span><span class="st">'Rhodos'</span>]</span></code></pre>
</div>
<p>And we can plot the overview by (or show it interactively using
<code>.explore</code>):</p>
<div class="codewrapper sourceCode" id="cb7">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a>gdf_rhodes.plot()</span></code></pre>
</div>
<figure><img src="fig/E07/rhodes_administration_areas.png" alt="rhodes_administrations" class="figure mx-auto d-block"></figure><p>Now that we have the administrative area of Rhodes Island. We can use
the <code>to_file()</code> function save this file for future use.</p>
<div class="codewrapper sourceCode" id="cb8">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a>gdf_rhodes.to_file(<span class="st">'rhodes.gpkg'</span>)</span></code></pre>
</div>
</section><section><h2 class="section-heading" id="get-the-vital-infrastructure-and-built-up-areas">Get the vital infrastructure and built-up areas<a class="anchor" aria-label="anchor" href="#get-the-vital-infrastructure-and-built-up-areas"></a>
</h2>
<hr class="half-width">
<div class="section level3">
<h3 id="road-data-from-open-street-map-osm">Road data from Open Street Map (OSM)<a class="anchor" aria-label="anchor" href="#road-data-from-open-street-map-osm"></a>
</h3>
<p>Now that we have the boundary of our study area, we will make use
this to select the main roads in our study area. We will make the
following processing steps:</p>
<ol style="list-style-type: decimal">
<li>Select roads of study area</li>
<li>Select key infrastruture: ‘primary’, ‘secondary’, ‘tertiary’</li>
<li>Create a 100m buffer around the rounds. This buffer will be regarded
as the infrastructure region. (note that this buffer is arbitrary and
can be changed afterwards if you want!)</li>
</ol>
<div class="section level4">
<h4 id="step-1-select-roads-of-study-area">Step 1: Select roads of study area<a class="anchor" aria-label="anchor" href="#step-1-select-roads-of-study-area"></a>
</h4>
<p>For this workshop, in particular to not have everyone downloading too
much data, we created a subset of the <a href="https://www.openstreetmap.org/" class="external-link">Openstreetmap</a> data we
downloaded for Greece from <a href="https://download.geofabrik.de/europe.html" class="external-link">the Geofabrik</a>. This
data comes in the form of a shapefile (see <a href="02-intro-vector-data.html">episode 2</a>) from which we extracted
all the roads for <code>Rhodes</code> and some surrounding islands. The
data is stored in the osm folder as <code>osm_roads.gpkg</code>, but
contains <em>all</em> the roads on the island (so also hiking paths,
private roads etc.), whereas we in particular are interested in the key
infrastructure which we consider to be roads classified as primary,
secondary or tertiary roads.</p>
<p>Let’s load the file and plot it:</p>
<div class="codewrapper sourceCode" id="cb9">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a>gdf_roads <span class="op">=</span> gpd.read_file(<span class="st">'data/osm/osm_roads.gpkg'</span>)</span></code></pre>
</div>
<p>We can explore it using the same commands as above:</p>
<div class="codewrapper sourceCode" id="cb10">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a>gdf_roads.plot()</span></code></pre>
</div>
<figure><img src="fig/E07/greece_highways.png" alt="greece_highways" class="figure mx-auto d-block"></figure><p>As you may have noticed, loading and plotting
<code>osm_roads.gpkg</code> takes a bit long. This is because the file
contains all the roads of Rhodos and some surrounding islands as well.
Since we are only interested in the roads on Rhodes Island. We will use
the <a href="https://geopandas.org/en/stable/docs/user_guide/io.html" class="external-link"><code>mask</code></a>
parameter of the <code>read_file()</code> function to load only the
roads on Rhodes Island.</p>
<p>Now let us overwrite the GeoDataframe <code>gdf_roads</code> using
the mask with the GeoDataFrame <code>gdf_rhodes</code> we created
above.</p>
<div class="codewrapper sourceCode" id="cb11">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a>gdf_roads <span class="op">=</span> gpd.read_file(<span class="st">'data/osm/osm_roads.gpkg'</span>, mask<span class="op">=</span>gdf_rhodes)</span></code></pre>
</div>
<p>Now let us explore these roads using <code>.explore</code> (or
<code>.plot</code>):</p>
<div class="codewrapper sourceCode" id="cb12">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a>gdf_roads.explore()</span></code></pre>
</div>
<figure><img src="fig/E07/rhodes_highways.png" alt="rhodes_highways" class="figure mx-auto d-block"></figure>
</div>
<div class="section level4">
<h4 id="step-2-select-key-infrastruture">Step 2: Select key infrastruture<a class="anchor" aria-label="anchor" href="#step-2-select-key-infrastruture"></a>
</h4>
<p>As you will find out while exploring the roads dataset, information
about the type of roads is stored in the <code>fclass</code> column. To
get an overview of the different values that are present in the collumn
<code>fclass</code> , we can use the <a href="https://pandas.pydata.org/docs/reference/api/pandas.unique.html" class="external-link"><code>unique()</code></a>
function from pandas:</p>
<div class="codewrapper sourceCode" id="cb13">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a>gdf_roads[<span class="st">'fclass'</span>].unique()</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>array(['residential', 'service', 'unclassified', 'footway',
       'track_grade4', 'primary', 'track', 'tertiary', 'track_grade3',
       'path', 'track_grade5', 'steps', 'secondary', 'primary_link',
       'track_grade2', 'track_grade1', 'pedestrian', 'tertiary_link',
       'secondary_link', 'living_street', 'cycleway'], dtype=object)</code></pre>
</div>
<p>It seems the variable <code>gdf_roads</code> contains all kind of
hiking paths and footpaths as well. Since we are only interested in
vital infrastructure, classified as “primary”, “secondary” and
“tertiary” roads, we need to make a subselection.</p>
<p>Let us first create a list with the labels we want to select.</p>
<div class="codewrapper sourceCode" id="cb15">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" tabindex="-1"></a>key_infra_labels <span class="op">=</span> [<span class="st">'primary'</span>, <span class="st">'secondary'</span>, <span class="st">'tertiary'</span>]</span></code></pre>
</div>
<p>Now we are using this list make a subselection of the key
infrastructure using pandas´ <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.isin.html" class="external-link"><code>.isin</code>
function</a>.</p>
<div class="codewrapper sourceCode" id="cb16">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" tabindex="-1"></a>key_infra <span class="op">=</span> gdf_roads[gdf_roads[<span class="st">'fclass'</span>].isin(key_infra_labels)]</span></code></pre>
</div>
<p>We can plot the key infrastructure :</p>
<div class="codewrapper sourceCode" id="cb17">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" tabindex="-1"></a>key_infra.plot()</span></code></pre>
</div>
<figure><img src="fig/E07/rhodes_infra_highways.png" alt="rhodes_infra_highways" class="figure mx-auto d-block"></figure>
</div>
<div class="section level4">
<h4 id="step-3-create-a-100m-buffer-around-the-key-infrastructure">Step 3: Create a 100m buffer around the key infrastructure<a class="anchor" aria-label="anchor" href="#step-3-create-a-100m-buffer-around-the-key-infrastructure"></a>
</h4>
<p>Now that we selected the key infrastructure, we want to create a 100m
buffer around them. This buffer will be regarded as the infrastructure
region.</p>
<p>As you might have notice, the numbers on the x and y axis of our
plots represent Lon Lat coordinates, meaning that the data is not yet
projected. The current data has a geographic coordinate system with
measures in degrees but not meter. Creating a buffer of 100 meters is
not possible. Therfore, in order to create a 100m buffer, we first need
to project our data. In our case we decided to project the data as WGS
84 / UTM zone 31N, with EPSG code 32631 (<a href="/episodes/03-crs.html">see chapter 03 for more information about
the CRS and EPSG codes</a>.</p>
<p>To project our data we use <a href="https://geopandas.org/en/stable/docs/reference/api/geopandas.GeoDataFrame.to_crs.html" class="external-link">.to_crs</a>.
We first define a variable with the EPSG value (in our case 32631),
which we then us in the to_crs function.</p>
<div class="codewrapper sourceCode" id="cb18">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" tabindex="-1"></a>epsg_code <span class="op">=</span> <span class="dv">32631</span></span>
<span id="cb18-2"><a href="#cb18-2" tabindex="-1"></a>key_infra_meters <span class="op">=</span> key_infra.to_crs(epsg_code)</span></code></pre>
</div>
<p>Now that our data is projected, we can create a buffer. For this we
make use of <a href="https://geopandas.org/en/stable/docs/user_guide/geometric_manipulations.html#GeoSeries.buffer" class="external-link">geopandas´
.buffer function</a> :</p>
<div class="codewrapper sourceCode" id="cb19">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" tabindex="-1"></a>key_infra_meters_buffer <span class="op">=</span> key_infra_meters.<span class="bu">buffer</span>(<span class="dv">100</span>)</span>
<span id="cb19-2"><a href="#cb19-2" tabindex="-1"></a>key_infra_meters_buffer</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>53       POLYGON ((2779295.383 4319805.295, 2779317.029...
54       POLYGON ((2779270.962 4319974.441, 2779272.393...
55       POLYGON ((2779172.341 4319578.062, 2779165.312...
84       POLYGON ((2779615.109 4319862.058, 2779665.519...
140      POLYGON ((2781330.698 4320046.538, 2781330.749...
                               ...
19020    POLYGON ((2780193.230 4337691.133, 2780184.279...
19021    POLYGON ((2780330.823 4337772.262, 2780324.966...
19022    POLYGON ((2780179.850 4337917.135, 2780188.871...
19024    POLYGON ((2780516.550 4339028.863, 2780519.340...
19032    POLYGON ((2780272.050 4338213.937, 2780274.519...
Length: 1386, dtype: geometry</code></pre>
</div>
<p>Note that the type of the <code>key_infra_meters_buffer</code> is a
<code>GeoSeries</code> and not a <code>GeoDataFrame</code>. This is
because the <code>buffer()</code> function returns a
<code>GeoSeries</code> object. You can check that by calling the type of
the variable.</p>
<div class="codewrapper sourceCode" id="cb21">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" tabindex="-1"></a><span class="bu">type</span>(key_infra_meters_buffer)</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code><span><span class="va">geopandas.geoseries.GeoSeries</span></span></code></pre>
</div>
<p>Now that we have a buffer, we can convert it back to the geographic
coordinate system to keep the data consistent. Note that we are now
using the crs information from the <code>key_infra</code>, instead of
using the EPSG code directly (EPSG:4326):</p>
<div class="codewrapper sourceCode" id="cb23">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" tabindex="-1"></a>key_infra_buffer <span class="op">=</span> key_infra_meters_buffer.to_crs(key_infra.crs)</span>
<span id="cb23-2"><a href="#cb23-2" tabindex="-1"></a>key_infra_buffer</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>45       POLYGON ((27.72826 36.12409, 27.72839 36.12426...
58       POLYGON ((27.71666 36.11678, 27.71665 36.11678...
99       POLYGON ((27.75485 35.95242, 27.75493 35.95248...
100      POLYGON ((27.76737 35.95086, 27.76733 35.95086...
108      POLYGON ((27.76706 35.95199, 27.76702 35.95201...
                               ...
18876    POLYGON ((28.22855 36.41890, 28.22861 36.41899...
18877    POLYGON ((28.22819 36.41838, 28.22825 36.41845...
18878    POLYGON ((28.22865 36.41904, 28.22871 36.41912...
18879    POLYGON ((28.23026 36.41927, 28.23034 36.41921...
18880    POLYGON ((28.23020 36.41779, 28.23007 36.41745...
Length: 1369, dtype: geometry</code></pre>
</div>
<p>As you can see, the buffers created in <code>key_infra_buffer</code>
have the <code>Polygon</code> geometry type.</p>
<p>To double check the EPSG code of key_infra:</p>
<div class="codewrapper sourceCode" id="cb25">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" tabindex="-1"></a><span class="bu">print</span>(key_infra.crs)</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code><span><span class="va">EPSG</span><span class="op">:</span><span class="fl">4326</span></span></code></pre>
</div>
<p>Reprojecting and buffering our data is something that we are going to
do multiple times during this episode. To avoid have to call the same
functions multiple times it would make sense to create a function.
Therefore, let us create a function in which we can add the buffer as a
variable.</p>
<div class="codewrapper sourceCode" id="cb27">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" tabindex="-1"></a><span class="kw">def</span> buffer_crs(gdf, size, meter_crs<span class="op">=</span><span class="dv">32631</span>, target_crs<span class="op">=</span><span class="dv">4326</span>):</span>
<span id="cb27-2"><a href="#cb27-2" tabindex="-1"></a>    <span class="cf">return</span> gdf.to_crs(meter_crs).<span class="bu">buffer</span>(size).to_crs(target_crs)</span></code></pre>
</div>
<p>For example, we can use this function to create a 200m buffer around
the infrastructure the key infrastructure by doing:</p>
<div class="codewrapper sourceCode" id="cb28">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" tabindex="-1"></a>key_infra_buffer_200 <span class="op">=</span> buffer_crs(key_infra, <span class="dv">200</span>)</span></code></pre>
</div>
</div>
</div>
<div class="section level3">
<h3 id="get-built-up-regions-from-open-street-map-osm">Get built-up regions from Open Street Map (OSM)<a class="anchor" aria-label="anchor" href="#get-built-up-regions-from-open-street-map-osm"></a>
</h3>
<p>Now that we have a buffered dataset for the key infrastructure of
Rhodes, our next step is to create a dataset with all the built-up
areas. To do so we will use the land use data from OSM, which we
prepared for you in the file <code>data/osm_landuse.gpkg</code>. This
file includes the land use data for the entire Greece. We assume the
built-up regions to be the union of three types of land use:
“commercial”, “industrial”, and “residential”.</p>
<p>Note that for the simplicity of this course, we limit the built-up
regions to these three types of land use. In reality, the built-up
regions can be more complex also there is definately more high quality
(e.g. local government).</p>
<p>Now it will be up to you to create a dataset with valueable assets.
You should be able to complete this task by yourself with the knowledge
you have gained from the previous steps and links to the documentation
we provided.</p>
<div id="exercise-get-the-built-up-regions" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="exercise-get-the-built-up-regions" class="callout-inner">
<h3 class="callout-title">Exercise: Get the built-up regions</h3>
<div class="callout-content">
<p>Create a <code>builtup_buffer</code> from the file
<code>data/osm/osm_landuse.gpkg</code> by the following steps:</p>
<ol style="list-style-type: decimal">
<li>Load the land use data from <code>data/osm/osm_landuse.gpkg</code>
and mask it with the administrative boundary of Rhodes Island
(<code>gdf_rhodes</code>).</li>
<li>Select the land use data for “commercial”, “industrial”, and
“residential”.</li>
<li>Create a 10m buffer around the land use data.</li>
<li>Visualize the results.</li>
</ol>
<p>After completing the exercise, answer the following questions:</p>
<ol style="list-style-type: decimal">
<li>How many unique land use types are there in
<code>osm_landuse.gpkg</code>?</li>
<li>After selecting the three types of land use, how many entries (rows)
are there in the results?</li>
</ol>
<p>Hints:</p>
<ul>
<li>
<code>data/osm_landuse.gpkg</code> contains the land use data for
the entire Greece. Use the administrative boundary of Rhodes Island
(<code>gdf_rhodes</code>) to select the land use data for Rhodes
Island.</li>
<li>The land use attribute is stored in the <code>fclass</code>
column.</li>
<li>Reuse <code>buffer_crs</code> function to create the buffer.</li>
</ul>
</div>
</div>
</div>
<div id="accordionSolution1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution1" aria-expanded="false" aria-controls="collapseSolution1">
  <h4 class="accordion-header" id="headingSolution1"> Show me the solution </h4>
</button>
<div id="collapseSolution1" class="accordion-collapse collapse" data-bs-parent="#accordionSolution1" aria-labelledby="headingSolution1">
<div class="accordion-body">
<div class="codewrapper sourceCode" id="cb29">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" tabindex="-1"></a><span class="co"># Read data with a mask of Rhodes</span></span>
<span id="cb29-2"><a href="#cb29-2" tabindex="-1"></a>gdf_landuse <span class="op">=</span> gpd.read_file(<span class="st">'./data/osm/osm_landuse.gpkg'</span>, mask<span class="op">=</span>gdf_rhodes)</span>
<span id="cb29-3"><a href="#cb29-3" tabindex="-1"></a></span>
<span id="cb29-4"><a href="#cb29-4" tabindex="-1"></a><span class="co"># Find number of unique landuse types</span></span>
<span id="cb29-5"><a href="#cb29-5" tabindex="-1"></a><span class="bu">print</span>(<span class="bu">len</span>(gdf_landuse[<span class="st">'fclass'</span>].unique()))</span>
<span id="cb29-6"><a href="#cb29-6" tabindex="-1"></a></span>
<span id="cb29-7"><a href="#cb29-7" tabindex="-1"></a><span class="co"># Extract built-up regions</span></span>
<span id="cb29-8"><a href="#cb29-8" tabindex="-1"></a>builtup_labels <span class="op">=</span> [<span class="st">'commercial'</span>, <span class="st">'industrial'</span>, <span class="st">'residential'</span>]</span>
<span id="cb29-9"><a href="#cb29-9" tabindex="-1"></a>builtup <span class="op">=</span> gdf_landuse[gdf_landuse[<span class="st">'fclass'</span>].isin(builtup_labels)]</span>
<span id="cb29-10"><a href="#cb29-10" tabindex="-1"></a></span>
<span id="cb29-11"><a href="#cb29-11" tabindex="-1"></a><span class="co"># Create 10m buffer around the built-up regions</span></span>
<span id="cb29-12"><a href="#cb29-12" tabindex="-1"></a>builtup_buffer <span class="op">=</span> buffer_crs(builtup, <span class="dv">10</span>)</span>
<span id="cb29-13"><a href="#cb29-13" tabindex="-1"></a></span>
<span id="cb29-14"><a href="#cb29-14" tabindex="-1"></a><span class="co"># Get the number of entries</span></span>
<span id="cb29-15"><a href="#cb29-15" tabindex="-1"></a><span class="bu">print</span>(<span class="bu">len</span>(builtup_buffer))</span>
<span id="cb29-16"><a href="#cb29-16" tabindex="-1"></a></span>
<span id="cb29-17"><a href="#cb29-17" tabindex="-1"></a><span class="co"># Visualize the buffer</span></span>
<span id="cb29-18"><a href="#cb29-18" tabindex="-1"></a>builtup_buffer.plot()</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code><span><span class="fl">19</span></span>
<span><span class="fl">1349</span></span></code></pre>
</div>
<figure><img src="fig/E07/rhodes_builtup_buffer.png" alt="rhodes_builtup_buffer" class="figure mx-auto d-block"></figure>
</div>
</div>
</div>
</div>
</div>
</section><section><h2 class="section-heading" id="merge-the-infrastructure-regions-and-built-up-regions">Merge the infrastructure regions and built-up regions<a class="anchor" aria-label="anchor" href="#merge-the-infrastructure-regions-and-built-up-regions"></a>
</h2>
<hr class="half-width">
<p>Now that we have the infrastructure regions and built-up regions, we
can merge them into a single region. We would like to keep track of the
type after merging, so we will add two new columns: <code>type</code>
and <code>code</code> by converting the <code>GeoSeries</code> to
<code>GeoDataFrame</code>.</p>
<p>First we convert the buffer around key infrastructure:</p>
<div class="codewrapper sourceCode" id="cb31">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" tabindex="-1"></a>data <span class="op">=</span> {<span class="st">'geometry'</span>: key_infra_buffer, <span class="st">'type'</span>: <span class="st">'infrastructure'</span>, <span class="st">'code'</span>: <span class="dv">1</span>}</span>
<span id="cb31-2"><a href="#cb31-2" tabindex="-1"></a>gdf_infra <span class="op">=</span> gpd.GeoDataFrame(data)</span></code></pre>
</div>
<p>Then we convert the built-up buffer:</p>
<div class="codewrapper sourceCode" id="cb32">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" tabindex="-1"></a>data <span class="op">=</span> {<span class="st">'geometry'</span>: builtup_buffer, <span class="st">'type'</span>: <span class="st">'builtup'</span>, <span class="st">'code'</span>: <span class="dv">2</span>}</span>
<span id="cb32-2"><a href="#cb32-2" tabindex="-1"></a>gdf_builtup <span class="op">=</span> gpd.GeoDataFrame(data)</span></code></pre>
</div>
<p>After that, we can merge the two <code>GeoDataFrame</code> into
one:</p>
<div class="codewrapper sourceCode" id="cb33">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb33-2"><a href="#cb33-2" tabindex="-1"></a>gdf_assets <span class="op">=</span> pd.concat([gdf_infra, gdf_builtup]).reset_index(drop<span class="op">=</span><span class="va">True</span>)</span></code></pre>
</div>
<p>In <code>gdf_assets</code>, we can distinguish the infrastructure
regions and built-up regions by the <code>type</code> and
<code>code</code> columns. We can plot the <code>gdf_assets</code> to
visualize the merged regions. See the <a href="https://geopandas.org/en/stable/docs/user_guide/mapping.html" class="external-link">geopandas
documentation</a> on how to do this:</p>
<div class="codewrapper sourceCode" id="cb34">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" tabindex="-1"></a>gdf_assets.plot(column<span class="op">=</span><span class="st">'type'</span>, legend<span class="op">=</span><span class="va">True</span>)</span></code></pre>
</div>
<figure><img src="fig/E07/rhodes_assets.png" alt="rhodes_assets" class="figure mx-auto d-block"></figure><p>Finally, we can save the <code>gdf_assets</code> to a file for future
use:</p>
<div class="codewrapper sourceCode" id="cb35">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" tabindex="-1"></a>gdf_assets.to_file(<span class="st">'assets.gpkg'</span>)</span></code></pre>
</div>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Key Points</h3>
<div class="callout-content">
<ul>
<li>Load spatial objects into Python with
<code>geopandas.read_file()</code> function.</li>
<li>Spatial objects can be plotted directly with
<code>GeoDataFrame</code>’s <code>.plot()</code> method.</li>
<li>Convert CRS of spatial objects with <code>.to_crs()</code>. Note
that this generates a <code>GeoSeries</code> object.</li>
<li>Create a buffer of spatial objects with <code>.buffer()</code>.</li>
<li>Merge spatial objects with <code>pd.concat()</code>.</li>
</ul>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</section></section><section id="aio-08-crop-raster-data"><p>Content from <a href="08-crop-raster-data.html">Crop raster data with rioxarray and geopandas</a></p>
<hr>
<p>Last updated on 2025-05-20 |

        <a href="https://github.com/carpentries-incubator/geospatial-python/edit/main/episodes/08-crop-raster-data.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>How can I crop my raster data to the area of interest?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Align the CRS of geopatial data.</li>
<li>Crop raster data with a bounding box.</li>
<li>Crop raster data with a polygon.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<p>It is quite common that the raster data you have in hand is too large
to process, or not all the pixels are relevant to your area of interest
(AoI). In both situations, you should consider cropping your raster data
before performing data analysis.</p>
<p>In this episode, we will introduce how to crop raster data into the
desired area. We will use one Sentinel-2 image over Rhodes Island as the
example raster data, and introduce how to crop your data to different
types of AoIs.</p>
<div id="introduce-the-data" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div id="introduce-the-data" class="callout-inner">
<h3 class="callout-title">Introduce the Data</h3>
<div class="callout-content">
<p>In this episode, we will work with both raster and vector data.</p>
<p>As <em>raster data</em>, we will use satellite images from the search
that we have carried out in <a href="05-access-data.html">the episode:
“Access satellite imagery using Python”</a> as well as Digital Elevation
Model (DEM) data from the <a href="https://spacedata.copernicus.eu/collections/copernicus-digital-elevation-model" class="external-link">Copernicus
DEM GLO-30 dataset</a>.</p>
<p>For the satellite images, we have searched for Sentinel-2 scenes of
Rhodes from July 1st to August 31st 2023 that have less than 1% cloud
coverage. The search resulted in 11 scenes. We focus here on the most
recent scene (August 27th), since that would show the situation after
the wildfire, and use this as an example to demonstrate raster data
cropping.</p>
<p>For your convenience, we have included the scene of interest among
the datasets that you have already downloaded when following <a href="index.html#setup">the setup instructions</a>. You should, however, be
able to download the satellite images “on-the-fly” using the JSON
metadata file that was created in <a href="05-access-data.html">the
previous episode</a> (the file <code>rhodes_sentinel-2.json</code>).</p>
<p>If you choose to work with the provided data (which is advised in
case you are working offline or have a slow/unstable network connection)
you can skip the remaining part of the block and continue with the
following section: <a href="#Align-the-CRS-of-the-raster-and-the-vector-data">Align the CRS of
the raster and the vector data</a>.</p>
<p>If you want instead to experiment with downloading the data
on-the-fly, you need to load the file
<code>rhodes_sentinel-2.json</code>, which contains information on where
and how to access the target satellite images from the remote
repository:</p>
<div class="codewrapper sourceCode" id="cb1">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="im">import</span> pystac</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a>items <span class="op">=</span> pystac.ItemCollection.from_file(<span class="st">"rhodes_sentinel-2.json"</span>)</span></code></pre>
</div>
<p>You can then select the first item in the collection, which is the
most recent in the sequence:</p>
<div class="codewrapper sourceCode" id="cb2">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a>item <span class="op">=</span> items[<span class="dv">0</span>]</span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a><span class="bu">print</span>(item)</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>&lt;Item id=S2A_35SNA_20230827_0_L2A&gt;</code></pre>
</div>
<p>In this episode we will consider the true color image associated with
this scene, which is labelled with the <code>visual</code> key in the
asset dictionary. We extract the URL / <code>href</code> (Hypertext
Reference) that point to the file, and store it in a variable that we
can use later on instead of the raster data path to access the data:</p>
<div class="codewrapper sourceCode" id="cb4">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a>rhodes_visual_href <span class="op">=</span> item.assets[<span class="st">"visual"</span>].href  <span class="co"># true color image</span></span></code></pre>
</div>
<p>As <strong>vector data</strong>, we will use the
<code>assets.gpkg</code>, which was generated in an exercise from <a href="07-vector-data-in-python.html">Episode 7: Vector data in
python</a>.</p>
</div>
</div>
</div>
<section><h2 class="section-heading" id="align-the-crs-of-the-raster-and-the-vector-data">Align the CRS of the raster and the vector data<a class="anchor" aria-label="anchor" href="#align-the-crs-of-the-raster-and-the-vector-data"></a>
</h2>
<hr class="half-width">
<div class="section level3">
<h3 id="data-loading">Data loading<a class="anchor" aria-label="anchor" href="#data-loading"></a>
</h3>
<p>First, we will load the visual image of Sentinel-2 over Rhodes
Island, which we downloaded and stored in
<code>data/sentinel2/visual.tif</code>.</p>
<p>We can open this asset with <code>rioxarray</code>, and specify the
overview level, since this is a Cloud-Optimized GeoTIFF (COG) file. As
explained in episode 6 raster images can be quite big, therefore we
decided to resample the data using ´rioxarray’s´ overview parameter and
set it to <code>overview_level=1</code>.</p>
<div class="codewrapper sourceCode" id="cb5">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a><span class="im">import</span> rioxarray</span>
<span id="cb5-2"><a href="#cb5-2" tabindex="-1"></a>path_visual <span class="op">=</span> <span class="st">'data/sentinel2/visual.tif'</span></span>
<span id="cb5-3"><a href="#cb5-3" tabindex="-1"></a>visual <span class="op">=</span> rioxarray.open_rasterio(path_visual, overview_level<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb5-4"><a href="#cb5-4" tabindex="-1"></a>visual</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>&lt;xarray.DataArray (band: 3, y: 2745, x: 2745)&gt;
[22605075 values with dtype=uint8]
Coordinates:
  * band         (band) int64 1 2 3
  * x            (x) float64 5e+05 5e+05 5.001e+05 ... 6.097e+05 6.098e+05
  * y            (y) float64 4.1e+06 4.1e+06 4.1e+06 ... 3.99e+06 3.99e+06
    spatial_ref  int64 0
Attributes:
    AREA_OR_POINT:       Area
    OVR_RESAMPLING_ALG:  AVERAGE
    _FillValue:          0
    scale_factor:        1.0
    add_offset:          0.0</code></pre>
</div>
<p>As we introduced in the raster data introduction episode, this will
perform a “lazy” loading of the image meaning that the image will not be
loaded into the memory until necessary.</p>
<p>Let’s also load the assets file generated in the vector data
episode:</p>
<div class="codewrapper sourceCode" id="cb7">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a><span class="im">import</span> geopandas <span class="im">as</span> gpd</span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a>assets <span class="op">=</span> gpd.read_file(<span class="st">'assets.gpkg'</span>)</span></code></pre>
</div>
</div>
<div class="section level3">
<h3 id="crop-the-raster-with-a-bounding-box">Crop the raster with a bounding box<a class="anchor" aria-label="anchor" href="#crop-the-raster-with-a-bounding-box"></a>
</h3>
<p>The assets file contains the information of the vital infrastructure
and built-up areas on the island Rhodes. The visual image, on the other
hand, has a larger extent. Let us check this by visualizing the raster
image:</p>
<div class="codewrapper sourceCode" id="cb8">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a>visual.plot.imshow()</span></code></pre>
</div>
<figure><img src="fig/E08/visual_large.png" alt="Large visual raster" class="figure mx-auto d-block"></figure><p>Let’s check the extent of the assets to find out its rough location
in the raster image. We can use the <a href="https://geopandas.org/en/stable/docs/reference/api/geopandas.GeoSeries.total_bounds.html" class="external-link"><code>total_bounds</code></a>
attribute from <code>GeoSeries</code> of <code>geopandas</code> to get
the bounding box:</p>
<div class="codewrapper sourceCode" id="cb9">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a>assets.total_bounds</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>array([27.7121001 , 35.87837949, 28.24591124, 36.45725024])</code></pre>
</div>
<p>The bounding box is composed of the
<code>[minx, miny, maxx, maxy]</code> values of the raster. Comparing
these values with the raster image, we can identify that the magnitude
of the bounding box coordinates does not match the coordinates of the
raster image. This is because the two datasets have different coordinate
reference systems (CRS). This will cause problems when cropping the
raster image, therefore we first need to align the CRS-s of the two
datasets</p>
<p>Considering the raster image has larger data volume than the vector
data, we will reproject the vector data to the CRS of the raster data.
We can use the <code>to_crs</code> method:</p>
<div class="codewrapper sourceCode" id="cb11">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a><span class="co"># Reproject</span></span>
<span id="cb11-2"><a href="#cb11-2" tabindex="-1"></a>assets <span class="op">=</span> assets.to_crs(visual.rio.crs)</span>
<span id="cb11-3"><a href="#cb11-3" tabindex="-1"></a></span>
<span id="cb11-4"><a href="#cb11-4" tabindex="-1"></a><span class="co"># Check the new bounding box</span></span>
<span id="cb11-5"><a href="#cb11-5" tabindex="-1"></a>assets.total_bounds</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>array([ 564058.0257114, 3970719.4080227,  611743.71498815, 4035358.56340039])</code></pre>
</div>
<p>Now the bounding box coordinates are updated. We can use the
<code>clip_box</code> function, through the <code>rioaxarray</code>
accessor, to crop the raster image to the bounding box of the vector
data. <code>clip_box</code> takes four positional input arguments in the
order of <code>xmin</code>, <code>ymin</code>, <code>xmax</code>,
<code>ymax</code>, which is exactly the same order in the
<code>assets.total_bounds</code>. Since <code>assets.total_bounds</code>
is an <code>numpy.array</code>, we can use the symbol <code>*</code> to
unpack it to the relevant positions in <code>clip_box</code>.</p>
<div class="codewrapper sourceCode" id="cb13">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a><span class="co"># Crop the raster with the bounding box</span></span>
<span id="cb13-2"><a href="#cb13-2" tabindex="-1"></a>visual_clipbox <span class="op">=</span> visual.rio.clip_box(<span class="op">*</span>assets.total_bounds)</span>
<span id="cb13-3"><a href="#cb13-3" tabindex="-1"></a></span>
<span id="cb13-4"><a href="#cb13-4" tabindex="-1"></a><span class="co"># Visualize the cropped image</span></span>
<span id="cb13-5"><a href="#cb13-5" tabindex="-1"></a>visual_clipbox.plot.imshow()</span></code></pre>
</div>
<figure><img src="fig/E08/visual_clip_box.png" alt="Clip box results" class="figure mx-auto d-block"></figure><div id="code-tip" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div id="code-tip" class="callout-inner">
<h3 class="callout-title">Code Tip</h3>
<div class="callout-content">
<p>Cropping a raster with a bounding box is a quick way to reduce the
size of the raster data. Since this operation is based on min/max
coordinates, it is not as computational extensive as cropping with
polygons, which requires more accurate overlay operations.</p>
</div>
</div>
</div>
</div>
<div class="section level3">
<h3 id="crop-the-raster-with-a-polygon">Crop the raster with a polygon<a class="anchor" aria-label="anchor" href="#crop-the-raster-with-a-polygon"></a>
</h3>
<p>We can also crop the raster with a polygon. In this case, we will use
the raster <code>clip</code> function through the <code>rio</code>
accessor. For this we will use the <code>geometry</code> column of the
<code>assets</code> GeoDataFrame to specify the polygon:</p>
<div class="codewrapper sourceCode" id="cb14">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" tabindex="-1"></a><span class="co"># Crop the raster with the polygon</span></span>
<span id="cb14-2"><a href="#cb14-2" tabindex="-1"></a>visual_clip <span class="op">=</span> visual_clipbox.rio.clip(assets[<span class="st">"geometry"</span>])</span>
<span id="cb14-3"><a href="#cb14-3" tabindex="-1"></a></span>
<span id="cb14-4"><a href="#cb14-4" tabindex="-1"></a><span class="co"># Visualize the cropped image</span></span>
<span id="cb14-5"><a href="#cb14-5" tabindex="-1"></a>visual_clip.plot.imshow()</span></code></pre>
</div>
<figure><img src="fig/E08/visual_clip.png" alt="Clip results" class="figure mx-auto d-block"></figure><div id="exercise-clip-the-red-band-for-rhodes" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="exercise-clip-the-red-band-for-rhodes" class="callout-inner">
<h3 class="callout-title">Exercise: Clip the red band for Rhodes</h3>
<div class="callout-content">
<p>Now that you have seen how clip a raster using a polygon, we want you
to do this for the red band of the satellite image. Use the shape of
Rhodes from GADM and clip the red band with it. Furthermore, make sure
to transform the no data values to not-a-number (NaN) values.</p>
</div>
</div>
</div>
<div id="accordionSolution1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution1" aria-expanded="false" aria-controls="collapseSolution1">
  <h4 class="accordion-header" id="headingSolution1"> Show me the solution </h4>
</button>
<div id="collapseSolution1" class="accordion-collapse collapse" data-bs-parent="#accordionSolution1" aria-labelledby="headingSolution1">
<div class="accordion-body">
<div class="codewrapper sourceCode" id="cb15">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" tabindex="-1"></a><span class="co"># Solution</span></span>
<span id="cb15-2"><a href="#cb15-2" tabindex="-1"></a></span>
<span id="cb15-3"><a href="#cb15-3" tabindex="-1"></a><span class="co"># Step 1 - Load the datasets - Vector data</span></span>
<span id="cb15-4"><a href="#cb15-4" tabindex="-1"></a></span>
<span id="cb15-5"><a href="#cb15-5" tabindex="-1"></a><span class="im">import</span> geopandas <span class="im">as</span> gpd</span>
<span id="cb15-6"><a href="#cb15-6" tabindex="-1"></a>gdf_greece <span class="op">=</span> gpd.read_file(<span class="st">'./data/gadm/ADM_ADM_3.gpkg'</span>)</span>
<span id="cb15-7"><a href="#cb15-7" tabindex="-1"></a>gdf_rhodes <span class="op">=</span> gdf_greece[gdf_greece[<span class="st">'NAME_3'</span>]<span class="op">==</span><span class="st">'Rhodos'</span>]</span>
<span id="cb15-8"><a href="#cb15-8" tabindex="-1"></a></span>
<span id="cb15-9"><a href="#cb15-9" tabindex="-1"></a><span class="co"># Step 2 - Load the raster red band</span></span>
<span id="cb15-10"><a href="#cb15-10" tabindex="-1"></a><span class="im">import</span> rioxarray</span>
<span id="cb15-11"><a href="#cb15-11" tabindex="-1"></a>path_red <span class="op">=</span> <span class="st">'./data/sentinel2/red.tif'</span></span>
<span id="cb15-12"><a href="#cb15-12" tabindex="-1"></a>red <span class="op">=</span> rioxarray.open_rasterio(path_red, overview_level<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb15-13"><a href="#cb15-13" tabindex="-1"></a></span>
<span id="cb15-14"><a href="#cb15-14" tabindex="-1"></a><span class="co"># Step 3 - It will not work, since it is not projected yet</span></span>
<span id="cb15-15"><a href="#cb15-15" tabindex="-1"></a></span>
<span id="cb15-16"><a href="#cb15-16" tabindex="-1"></a>gdf_rhodes <span class="op">=</span> gdf_rhodes.to_crs(red.rio.crs)</span>
<span id="cb15-17"><a href="#cb15-17" tabindex="-1"></a></span>
<span id="cb15-18"><a href="#cb15-18" tabindex="-1"></a><span class="co"># Step 4 - Clip the two</span></span>
<span id="cb15-19"><a href="#cb15-19" tabindex="-1"></a></span>
<span id="cb15-20"><a href="#cb15-20" tabindex="-1"></a>red_clip <span class="op">=</span> red.rio.clip(gdf_rhodes[<span class="st">"geometry"</span>])</span>
<span id="cb15-21"><a href="#cb15-21" tabindex="-1"></a></span>
<span id="cb15-22"><a href="#cb15-22" tabindex="-1"></a><span class="co"># Step 5 - assing nan values to no data</span></span>
<span id="cb15-23"><a href="#cb15-23" tabindex="-1"></a></span>
<span id="cb15-24"><a href="#cb15-24" tabindex="-1"></a>red_clip_nan <span class="op">=</span> red_clip.where(red_clip<span class="op">!=</span>red_clip.rio.nodata)</span>
<span id="cb15-25"><a href="#cb15-25" tabindex="-1"></a></span>
<span id="cb15-26"><a href="#cb15-26" tabindex="-1"></a><span class="co"># Step 6 - Visualize the result</span></span>
<span id="cb15-27"><a href="#cb15-27" tabindex="-1"></a></span>
<span id="cb15-28"><a href="#cb15-28" tabindex="-1"></a>red_clip_nan.plot()</span></code></pre>
</div>
<figure><img src="fig/E08/solution_exercise.png" alt="rhodes_builtup_buffer" class="figure mx-auto d-block"></figure>
</div>
</div>
</div>
</div>
</div>
<div class="section level3">
<h3 id="match-two-rasters">Match two rasters<a class="anchor" aria-label="anchor" href="#match-two-rasters"></a>
</h3>
<p>Sometimes you need to match two rasters with different extents,
resolutions, or CRS. For this you can use the <a href="https://corteva.github.io/rioxarray/stable/examples/reproject_match.html#Reproject-Match" class="external-link"><code>reproject_match</code></a>
function . We will demonstrate this by matching the cropped raster
<code>visual_clip</code> with the Digital Elevation Model
(DEM),<code>rhodes_dem.tif</code> of Rhodes.</p>
<p>First, let’s load the DEM:</p>
<div class="codewrapper sourceCode" id="cb16">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" tabindex="-1"></a>dem <span class="op">=</span> rioxarray.open_rasterio(<span class="st">'./data/dem/rhodes_dem.tif'</span>)</span></code></pre>
</div>
<p>And visualize it:</p>
<div class="codewrapper sourceCode" id="cb17">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" tabindex="-1"></a>dem.plot()</span></code></pre>
</div>
<figure><img src="fig/E08/dem.png" alt="DEM" class="figure mx-auto d-block"></figure><p>From the visualization, we can see that the DEM has a different
extent, resolution and CRS compared to the cropped visual image. We can
also confirm this by checking the CRS of the two images:</p>
<div class="codewrapper sourceCode" id="cb18">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" tabindex="-1"></a><span class="bu">print</span>(dem.rio.crs)</span>
<span id="cb18-2"><a href="#cb18-2" tabindex="-1"></a><span class="bu">print</span>(visual_clip.rio.crs)</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code><span><span class="va">EPSG</span><span class="op">:</span><span class="fl">4326</span></span>
<span><span class="va">EPSG</span><span class="op">:</span><span class="fl">32635</span></span></code></pre>
</div>
<p>We can use the <code>reproject_match</code> function to match the two
rasters. One can choose to match the dem to the visual image or vice
versa. Here we will match the DEM to the visual image:</p>
<div class="codewrapper sourceCode" id="cb20">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" tabindex="-1"></a>dem_matched <span class="op">=</span> dem.rio.reproject_match(visual_clip)</span></code></pre>
</div>
<p>And then visualize the matched DEM:</p>
<div class="codewrapper sourceCode" id="cb21">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" tabindex="-1"></a>dem_matched.plot()</span></code></pre>
</div>
<figure><img src="fig/E08/dem_matched.png" alt="Matched DEM" class="figure mx-auto d-block"></figure><p>As we can see, <code>reproject_match</code> does a lot of helpful
things in one line of code:</p>
<ol style="list-style-type: decimal">
<li>It reprojects.</li>
<li>It matches the extent.</li>
<li>It matches the resolution.</li>
</ol>
<p>Finally, we can save the matched DEM for later use. We save it as a
Cloud-Optimized GeoTIFF (COG) file:</p>
<div class="codewrapper sourceCode" id="cb22">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" tabindex="-1"></a>dem_matched.rio.to_raster(<span class="st">'dem_rhodes_match.tif'</span>, driver<span class="op">=</span><span class="st">'COG'</span>)</span></code></pre>
</div>
<div id="code-tip-1" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div id="code-tip-1" class="callout-inner">
<h3 class="callout-title">Code Tip</h3>
<div class="callout-content">
<p>There is also a method in rioxarray: <a href="https://corteva.github.io/rioxarray/stable/rioxarray.html#rioxarray.raster_array.RasterArray.reproject" class="external-link"><code>reproject()</code></a>,
which only reprojects one raster to another projection. If you want more
control over how rasters are resampled, clipped, and/or reprojected, you
can use the <code>reproject()</code> method individually.</p>
</div>
</div>
</div>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Key Points</h3>
<div class="callout-content">
<ul>
<li>Use <code>clip_box</code> to crop a raster with a bounding box.</li>
<li>Use <code>clip</code> to crop a raster with a given polygon.</li>
<li>Use <code>reproject_match</code> to match two raster datasets.</li>
</ul>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</div>
</section></section><section id="aio-09-raster-calculations"><p>Content from <a href="09-raster-calculations.html">Raster Calculations in Python</a></p>
<hr>
<p>Last updated on 2025-05-20 |

        <a href="https://github.com/carpentries-incubator/geospatial-python/edit/main/episodes/09-raster-calculations.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>How do I perform calculations on rasters and extract pixel values
for defined locations?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Carry out operations with two rasters using Python’s built-in math
operators.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<section><h2 class="section-heading" id="introduction">Introduction<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h2>
<hr class="half-width">
<p>We often want to combine values of and perform calculations on
rasters to create a new output raster. This episode covers how to
perform basic math operations using raster datasets. It also illustrates
how to match rasters with different resolutions so that they can be used
in the same calculation. As an example, we will calculate <a href="https://custom-scripts.sentinel-hub.com/sentinel-2/burned_area_ms/" class="external-link">a
binary classification mask</a> to identify burned area over a satellite
scene.</p>
<p>The classification mask requires the following of <a href="https://gisgeography.com/sentinel-2-bands-combinations/" class="external-link">the
Sentinel-2 bands</a> (and derived indices):</p>
<ul>
<li>
<a href="https://en.wikipedia.org/wiki/Normalized_difference_vegetation_index" class="external-link">Normalized
difference vegetation index (NDVI)</a>, derived from the
<strong>near-infrared (NIR)</strong> and <strong>red</strong>
bands:</li>
</ul>
<p><span class="math display">\[ NDVI = \frac{NIR - red}{NIR + red}
\]</span></p>
<ul>
<li>
<a href="https://en.wikipedia.org/wiki/Normalized_difference_water_index" class="external-link">Normalized
difference water index (NDWI)</a>, derived from the
<strong>green</strong> and <strong>NIR</strong> bands:</li>
</ul>
<p><span class="math display">\[ NDWI = \frac{green - NIR}{green + NIR}
\]</span></p>
<ul>
<li>A custom index derived from two of the <strong>short-wave infrared
(SWIR)</strong> bands (with wavelenght ~1600 nm and ~2200 nm,
respectively):</li>
</ul>
<p><span class="math display">\[ INDEX = \frac{SWIR_{16} -
SWIR_{22}}{SWIR_{16} + SWIR_{22}}\]</span></p>
<ul>
<li>The <strong>blue</strong>, <strong>NIR</strong>, and
<strong>SWIR</strong> (1600 nm) bands.</li>
</ul>
<p>In the following, we start by computing the NDVI.</p>
<div class="section level3">
<h3 id="load-and-crop-the-data">Load and crop the Data<a class="anchor" aria-label="anchor" href="#load-and-crop-the-data"></a>
</h3>
<p>For this episode, we will use one of the Sentinel-2 scenes that we
have already employed in the previous episodes.</p>
<div id="introduce-the-data" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div id="introduce-the-data" class="callout-inner">
<h3 class="callout-title">Introduce the Data</h3>
<div class="callout-content">
<p>We will use satellite images from the search that we have carried out
in <a href="05-access-data.html">the episode: “Access satellite imagery
using Python”</a>. Briefly, we have searched for Sentinel-2 scenes of
Rhodes from July 1st to August 31st 2023 that have less than 1% cloud
coverage. The search resulted in 11 scenes. We focus here on the most
recent scene (August 27th), since that would show the situation after
the wildfire, and use this as an example to demonstrate raster
calculations.</p>
<p>For your convenience, we have included the scene of interest among
the datasets that you have already downloaded when following <a href="index.html#setup">the setup instructions</a>. You should, however, be
able to download the satellite images “on-the-fly” using the JSON
metadata file that was created in <a href="05-access-data.html">the
previous episode</a> (the file <code>rhodes_sentinel-2.json</code>).</p>
<p>If you choose to work with the provided data (which is advised in
case you are working offline or have a slow/unstable network connection)
you can skip the remaining part of the block.</p>
<p>If you want instead to experiment with downloading the data
on-the-fly, you need to load the file
<code>rhodes_sentinel-2.json</code>, which contains information on where
and how to access the target satellite images from the remote
repository:</p>
<div class="codewrapper sourceCode" id="cb1">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="im">import</span> pystac</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a>items <span class="op">=</span> pystac.ItemCollection.from_file(<span class="st">"rhodes_sentinel-2.json"</span>)</span></code></pre>
</div>
<p>You can then select the first item in the collection, which is the
most recent in the sequence:</p>
<div class="codewrapper sourceCode" id="cb2">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a>item <span class="op">=</span> items[<span class="dv">0</span>]</span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a><span class="bu">print</span>(item)</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>&lt;Item id=S2A_35SNA_20230827_0_L2A&gt;</code></pre>
</div>
<p>In this episode we will consider a number of bands associated with
this scene. We extract the URL / <code>href</code> (Hypertext Reference)
that point to each of the raster files, and store these in variables
that we can use later on instead of the raster data paths to access the
data:</p>
<div class="codewrapper sourceCode" id="cb4">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a>rhodes_red_href <span class="op">=</span> item.assets[<span class="st">"red"</span>].href  <span class="co"># red band</span></span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a>rhodes_green_href <span class="op">=</span> item.assets[<span class="st">"green"</span>].href  <span class="co"># green band</span></span>
<span id="cb4-3"><a href="#cb4-3" tabindex="-1"></a>rhodes_blue_href <span class="op">=</span> item.assets[<span class="st">"blue"</span>].href  <span class="co"># blue band</span></span>
<span id="cb4-4"><a href="#cb4-4" tabindex="-1"></a>rhodes_nir_href <span class="op">=</span> item.assets[<span class="st">"nir"</span>].href  <span class="co"># near-infrared band</span></span>
<span id="cb4-5"><a href="#cb4-5" tabindex="-1"></a>rhodes_swir16_href <span class="op">=</span> item.assets[<span class="st">"swir16"</span>].href  <span class="co"># short-wave infrared (1600 nm) band</span></span>
<span id="cb4-6"><a href="#cb4-6" tabindex="-1"></a>rhodes_swir22_href <span class="op">=</span> item.assets[<span class="st">"swir22"</span>].href  <span class="co"># short-wave infrared (2200 nm) band</span></span>
<span id="cb4-7"><a href="#cb4-7" tabindex="-1"></a>rhodes_visual_href <span class="op">=</span> item.assets[<span class="st">"visual"</span>].href  <span class="co"># true-color image</span></span></code></pre>
</div>
</div>
</div>
</div>
<p>Let’s load the red and NIR band rasters with
<code>open_rasterio</code> using the argument
<code>masked=True</code>:</p>
<div class="codewrapper sourceCode" id="cb5">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a><span class="im">import</span> rioxarray</span>
<span id="cb5-2"><a href="#cb5-2" tabindex="-1"></a>red <span class="op">=</span> rioxarray.open_rasterio(<span class="st">"data/sentinel2/red.tif"</span>, masked<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb5-3"><a href="#cb5-3" tabindex="-1"></a>nir <span class="op">=</span> rioxarray.open_rasterio(<span class="st">"data/sentinel2/nir.tif"</span>, masked<span class="op">=</span><span class="va">True</span>)</span></code></pre>
</div>
<p>Let’s restrict our analysis to the island of Rhodes - we can extract
the bounding box from the vector file written in an earlier episode
(note that we need to match the CRS to the one of the raster files):</p>
<div class="codewrapper sourceCode" id="cb6">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a><span class="co"># determine bounding box of Rhodes, in the projected CRS</span></span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a><span class="im">import</span> geopandas</span>
<span id="cb6-3"><a href="#cb6-3" tabindex="-1"></a>rhodes <span class="op">=</span> geopandas.read_file(<span class="st">'rhodes.gpkg'</span>)</span>
<span id="cb6-4"><a href="#cb6-4" tabindex="-1"></a>rhodes_reprojected <span class="op">=</span> rhodes.to_crs(red.rio.crs)</span>
<span id="cb6-5"><a href="#cb6-5" tabindex="-1"></a>bbox <span class="op">=</span> rhodes_reprojected.total_bounds</span>
<span id="cb6-6"><a href="#cb6-6" tabindex="-1"></a></span>
<span id="cb6-7"><a href="#cb6-7" tabindex="-1"></a><span class="co"># crop the rasters</span></span>
<span id="cb6-8"><a href="#cb6-8" tabindex="-1"></a>red_clip <span class="op">=</span> red.rio.clip_box(<span class="op">*</span>bbox)</span>
<span id="cb6-9"><a href="#cb6-9" tabindex="-1"></a>nir_clip <span class="op">=</span> nir.rio.clip_box(<span class="op">*</span>bbox)</span></code></pre>
</div>
<p>We can now plot the two rasters. Using <code>robust=True</code> color
values are stretched between the 2nd and 98th percentiles of the data,
which results in clearer distinctions between high and low
reflectances:</p>
<div class="codewrapper sourceCode" id="cb7">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a>red_clip.plot(robust<span class="op">=</span><span class="va">True</span>)</span></code></pre>
</div>
<figure><img src="fig/E09/red-band.png" alt="red band image" class="figure mx-auto d-block"></figure><div class="codewrapper sourceCode" id="cb8">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a>nir_clip.plot(robust<span class="op">=</span><span class="va">True</span>)</span></code></pre>
</div>
<figure><img src="fig/E09/NIR-band.png" alt="near infra-red band image" class="figure mx-auto d-block"></figure><p>The burned area is immediately evident as a dark spot in the NIR
wavelength, due to the lack of reflection from the vegetation in the
scorched area.</p>
</div>
</section><section><h2 class="section-heading" id="raster-math">Raster Math<a class="anchor" aria-label="anchor" href="#raster-math"></a>
</h2>
<hr class="half-width">
<p>We can perform raster calculations by subtracting (or adding,
multiplying, etc.) two rasters. In the geospatial world, we call this
“raster math”, and typically it refers to operations on rasters that
have the same width and height (including <code>nodata</code> pixels).
We can check the shapes of the two rasters in the following way:</p>
<div class="codewrapper sourceCode" id="cb9">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a><span class="bu">print</span>(red_clip.shape, nir_clip.shape)</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>(1, 4523, 4828) (1, 4523, 4828)</code></pre>
</div>
<p>The shapes of the two rasters match (and, not shown, the coordinates
and the CRSs match too).</p>
<p>Let’s now compute the NDVI as a new raster using the formula
presented above. We’ll use <code>DataArray</code> objects so that we can
easily plot our result and keep track of the metadata.</p>
<div class="codewrapper sourceCode" id="cb11">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a>ndvi <span class="op">=</span> (nir_clip <span class="op">-</span> red_clip)<span class="op">/</span> (nir_clip <span class="op">+</span> red_clip)</span>
<span id="cb11-2"><a href="#cb11-2" tabindex="-1"></a><span class="bu">print</span>(ndvi)</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>&lt;xarray.DataArray (band: 1, y: 1131, x: 1207)&gt;
array([[[0., 0., 0., ..., 0., 0., 0.],
        [0., 0., 0., ..., 0., 0., 0.],
        [0., 0., 0., ..., 0., 0., 0.],
        ...,
        [0., 0., 0., ..., 0., 0., 0.],
        [0., 0., 0., ..., 0., 0., 0.],
        [0., 0., 0., ..., 0., 0., 0.]]], dtype=float32)
Coordinates:
  * band         (band) int64 1
  * x            (x) float64 5.615e+05 5.616e+05 ... 6.097e+05 6.098e+05
  * y            (y) float64 4.035e+06 4.035e+06 4.035e+06 ... 3.99e+06 3.99e+06
    spatial_ref  int64 0</code></pre>
</div>
<p>We can now plot the output NDVI:</p>
<div class="codewrapper sourceCode" id="cb13">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a>ndvi.plot()</span></code></pre>
</div>
<figure><img src="fig/E09/NDVI-map.png" alt="NDVI map" class="figure mx-auto d-block"></figure><p>Notice that the range of values for the output NDVI is between -1 and
1. Does this make sense for the selected region?</p>
<p>Maps are great, but it can also be informative to plot histograms of
values to better understand the distribution. We can accomplish this
using a built-in xarray method we have already been using:
<code>plot.hist()</code></p>
<div class="codewrapper sourceCode" id="cb14">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" tabindex="-1"></a>ndvi.plot.hist()</span></code></pre>
</div>
<figure><img src="fig/E09/NDVI-hist.png" alt="NDVI histogram" class="figure mx-auto d-block"></figure><div id="exercise-ndwi-and-custom-index-to-detect-burned-areas" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="exercise-ndwi-and-custom-index-to-detect-burned-areas" class="callout-inner">
<h3 class="callout-title">Exercise: NDWI and custom index to detect burned areas</h3>
<div class="callout-content">
<p>Calculate the other two indices required to compute the burned area
classification mask, specifically:</p>
<ul>
<li>The <a href="https://en.wikipedia.org/wiki/Normalized_difference_water_index" class="external-link">normalized
difference water index (NDWI)</a>, derived from the
<strong>green</strong> and <strong>NIR</strong> bands (file “green.tif”
and “nir.tif”, respectively):</li>
</ul>
<p><span class="math display">\[ NDWI = \frac{green - NIR}{green + NIR}
\]</span></p>
<ul>
<li>A custom index derived from the 1600 nm and the 2200 nm
<strong>short-wave infrared (SWIR)</strong> bands ( “swir16.tif” and
“swir22.tif”, respectively):</li>
</ul>
<p><span class="math display">\[ INDEX = \frac{SWIR_{16} -
SWIR_{22}}{SWIR_{16} + SWIR_{22}}\]</span></p>
<p>What challenge do you foresee in combining the data from the two
indices?</p>
</div>
</div>
</div>
<div id="accordionSolution1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution1" aria-expanded="false" aria-controls="collapseSolution1">
  <h4 class="accordion-header" id="headingSolution1"> Show me the solution </h4>
</button>
<div id="collapseSolution1" class="accordion-collapse collapse" aria-labelledby="headingSolution1" data-bs-parent="#accordionSolution1">
<div class="accordion-body">
<div class="codewrapper sourceCode" id="cb15">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" tabindex="-1"></a><span class="kw">def</span> get_band_and_clip(band_path, bbox):</span>
<span id="cb15-2"><a href="#cb15-2" tabindex="-1"></a>    band <span class="op">=</span> rioxarray.open_rasterio(band_path, masked<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb15-3"><a href="#cb15-3" tabindex="-1"></a>    <span class="cf">return</span> band.rio.clip_box(<span class="op">*</span>bbox)</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb16">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" tabindex="-1"></a>data_path <span class="op">=</span> <span class="st">'data/sentinel2'</span></span>
<span id="cb16-2"><a href="#cb16-2" tabindex="-1"></a>green_clip <span class="op">=</span> get_band_and_clip(<span class="ss">f'</span><span class="sc">{</span>data_path<span class="sc">}</span><span class="ss">/green.tif'</span>, bbox)</span>
<span id="cb16-3"><a href="#cb16-3" tabindex="-1"></a>swir16_clip <span class="op">=</span> get_band_and_clip(<span class="ss">f'</span><span class="sc">{</span>data_path<span class="sc">}</span><span class="ss">/swir16.tif'</span>, bbox)</span>
<span id="cb16-4"><a href="#cb16-4" tabindex="-1"></a>swir22_clip <span class="op">=</span> get_band_and_clip(<span class="ss">f'</span><span class="sc">{</span>data_path<span class="sc">}</span><span class="ss">/swir22.tif'</span>, bbox)</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb17">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" tabindex="-1"></a>ndwi <span class="op">=</span> (green_clip <span class="op">-</span> nir_clip)<span class="op">/</span>(green_clip <span class="op">+</span> nir_clip)</span>
<span id="cb17-2"><a href="#cb17-2" tabindex="-1"></a>index <span class="op">=</span> (swir16_clip <span class="op">-</span> swir22_clip)<span class="op">/</span>(swir16_clip <span class="op">+</span> swir22_clip)</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb18">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" tabindex="-1"></a>ndwi.plot(robust<span class="op">=</span><span class="va">True</span>)</span></code></pre>
</div>
<figure><img src="fig/E09/NDWI.png" alt="NDWI index" class="figure mx-auto d-block"></figure><div class="codewrapper sourceCode" id="cb19">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" tabindex="-1"></a>index.plot(robust<span class="op">=</span><span class="va">True</span>)</span></code></pre>
</div>
<figure><img src="fig/E09/custom-index.png" alt="custom index" class="figure mx-auto d-block"></figure><p>The challenge in combining the different indices is that the SWIR
bands (and thus the derived custom index) have lower resolution:</p>
<div class="codewrapper sourceCode" id="cb20">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" tabindex="-1"></a>ndvi.rio.resolution(), ndwi.rio.resolution(), index.rio.resolution()</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>((10.0, -10.0), (10.0, -10.0), (20.0, -20.0))</code></pre>
</div>
</div>
</div>
</div>
</div>
<p>In order to combine data from the computed indices, we use the
<code>reproject_match</code> method, which reprojects, clips and match
the resolution of a raster using another raster as a template. We use
the <code>ndvi</code> raster as a template, and match <code>index</code>
and <code>swir16_clip</code> to its resolution and extent:</p>
<div class="codewrapper sourceCode" id="cb22">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" tabindex="-1"></a>index_match <span class="op">=</span> index.rio.reproject_match(ndvi)</span>
<span id="cb22-2"><a href="#cb22-2" tabindex="-1"></a>swir16_match <span class="op">=</span> swir16_clip.rio.reproject_match(ndvi)</span></code></pre>
</div>
<p>Finally, we also load the blue band data and clip it to the area of
interest:</p>
<div class="codewrapper sourceCode" id="cb23">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" tabindex="-1"></a>blue_clip <span class="op">=</span> get_band_and_clip(<span class="ss">f'</span><span class="sc">{</span>data_path<span class="sc">}</span><span class="ss">/blue.tif'</span>, bbox)</span></code></pre>
</div>
<p>We can now go ahead and compute the binary classification mask for
burned areas. Note that we need to convert the unit of the Sentinel-2
bands <a href="https://docs.sentinel-hub.com/api/latest/data/sentinel-2-l2a/#units" class="external-link">from
digital numbers to reflectance</a> (this is achieved by dividing by
10,000):</p>
<div class="codewrapper sourceCode" id="cb24">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" tabindex="-1"></a>burned <span class="op">=</span> (</span>
<span id="cb24-2"><a href="#cb24-2" tabindex="-1"></a>    (ndvi <span class="op">&lt;=</span> <span class="fl">0.3</span>) <span class="op">&amp;</span></span>
<span id="cb24-3"><a href="#cb24-3" tabindex="-1"></a>    (ndwi <span class="op">&lt;=</span> <span class="fl">0.1</span>) <span class="op">&amp;</span></span>
<span id="cb24-4"><a href="#cb24-4" tabindex="-1"></a>    ((index_match <span class="op">+</span> nir_clip<span class="op">/</span><span class="dv">10_000</span>) <span class="op">&lt;=</span> <span class="fl">0.1</span>) <span class="op">&amp;</span></span>
<span id="cb24-5"><a href="#cb24-5" tabindex="-1"></a>    ((blue_clip<span class="op">/</span><span class="dv">10_000</span>) <span class="op">&lt;=</span> <span class="fl">0.1</span>) <span class="op">&amp;</span></span>
<span id="cb24-6"><a href="#cb24-6" tabindex="-1"></a>    ((swir16_match<span class="op">/</span><span class="dv">10_000</span>) <span class="op">&gt;=</span> <span class="fl">0.1</span>)</span>
<span id="cb24-7"><a href="#cb24-7" tabindex="-1"></a>)</span></code></pre>
</div>
<p>The classification mask has a single element along the “band” axis,
we can drop this dimension in the following way:</p>
<div class="codewrapper sourceCode" id="cb25">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" tabindex="-1"></a>burned <span class="op">=</span> burned.squeeze()</span></code></pre>
</div>
<p>Let’s now fetch and visualize the true color image of Rhodes, after
coloring the pixels identified as burned area in red:</p>
<div class="codewrapper sourceCode" id="cb26">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" tabindex="-1"></a>visual <span class="op">=</span> rioxarray.open_rasterio(<span class="ss">f'</span><span class="sc">{</span>data_path<span class="sc">}</span><span class="ss">/visual.tif'</span>)</span>
<span id="cb26-2"><a href="#cb26-2" tabindex="-1"></a>visual_clip <span class="op">=</span> visual.rio.clip_box(<span class="op">*</span>bbox)</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb27">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" tabindex="-1"></a><span class="co"># set red channel to max (255), green and blue channels to min (0).</span></span>
<span id="cb27-2"><a href="#cb27-2" tabindex="-1"></a>visual_clip[<span class="dv">0</span>] <span class="op">=</span> visual_clip[<span class="dv">0</span>].where(<span class="op">~</span>burned, <span class="dv">255</span>)</span>
<span id="cb27-3"><a href="#cb27-3" tabindex="-1"></a>visual_clip[<span class="dv">1</span>:<span class="dv">3</span>] <span class="op">=</span> visual_clip[<span class="dv">1</span>:<span class="dv">3</span>].where(<span class="op">~</span>burned, <span class="dv">0</span>)</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb28">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" tabindex="-1"></a>visual_clip.plot.imshow()</span></code></pre>
</div>
<figure><img src="fig/E09/visual-burned-index.png" alt="RGB image with burned area in red" class="figure mx-auto d-block"></figure><p>We can save the burned classification mask to disk after converting
booleans to integers:</p>
<div class="codewrapper sourceCode" id="cb29">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" tabindex="-1"></a>burned.rio.to_raster(<span class="st">'burned.tif'</span>, dtype<span class="op">=</span><span class="st">'int8'</span>)</span></code></pre>
</div>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Key Points</h3>
<div class="callout-content">
<ul>
<li>Python’s built-in math operators are fast and simple options for
raster math.</li>
</ul>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</section></section><section id="aio-10-zonal-statistics"><p>Content from <a href="10-zonal-statistics.html">Calculating Zonal Statistics on Rasters</a></p>
<hr>
<p>Last updated on 2025-05-20 |

        <a href="https://github.com/carpentries-incubator/geospatial-python/edit/main/episodes/10-zonal-statistics.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>How to compute raster statistics on different zones delineated by
vector data?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Extract zones from the vector dataset</li>
<li>Convert vector data to raster</li>
<li>Calculate raster statistics over zones</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<section><h2 class="section-heading" id="introduction">Introduction<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h2>
<hr class="half-width">
<p>Statistics on predefined zones of the raster data are commonly used
for analysis and to better understand the data. These zones are often
provided within a single vector dataset, identified by certain vector
attributes. For example, in the previous episodes, we defined
infrastructure regions and built-up regions on Rhodes Island as
polygons. Each region can be respectively identified as a “zone”,
resulting in two zones. One can evualuate the effect of the wild fire on
the two zones by calculating the zonal statistics.</p>
</section><section><h2 class="section-heading" id="data-loading">Data loading<a class="anchor" aria-label="anchor" href="#data-loading"></a>
</h2>
<hr class="half-width">
<p>We have created <code>assets.gpkg</code> in Episode “Vector data in
Python”, which contains the infrastructure regions and built-up regions
. We also calculated the burned index in Episode “Raster Calculations in
Python” and saved it in <code>burned.tif</code>. Lets load them:</p>
<div class="codewrapper sourceCode" id="cb1">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="co"># Load burned index</span></span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a><span class="im">import</span> rioxarray</span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a>burned <span class="op">=</span> rioxarray.open_rasterio(<span class="st">'burned.tif'</span>)</span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a><span class="co"># Load assests polygons</span></span>
<span id="cb1-6"><a href="#cb1-6" tabindex="-1"></a><span class="im">import</span> geopandas <span class="im">as</span> gpd</span>
<span id="cb1-7"><a href="#cb1-7" tabindex="-1"></a>assets <span class="op">=</span> gpd.read_file(<span class="st">'assets.gpkg'</span>)</span></code></pre>
</div>
</section><section><h2 class="section-heading" id="align-datasets">Align datasets<a class="anchor" aria-label="anchor" href="#align-datasets"></a>
</h2>
<hr class="half-width">
<p>Before we continue, let’s check if the two datasets are in the same
CRS:</p>
<div class="codewrapper sourceCode" id="cb2">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a><span class="bu">print</span>(assets.crs)</span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a><span class="bu">print</span>(burned.rio.crs)</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code><span><span class="va">EPSG</span><span class="op">:</span><span class="fl">4326</span></span>
<span><span class="va">EPSG</span><span class="op">:</span><span class="fl">32635</span></span></code></pre>
</div>
<p>The two datasets are in different CRS. Let’s reproject the assets to
the same CRS as the burned index raster:</p>
<div class="codewrapper sourceCode" id="cb4">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a>assets <span class="op">=</span> assets.to_crs(burned.rio.crs)</span></code></pre>
</div>
</section><section><h2 class="section-heading" id="rasterize-the-vector-data">Rasterize the vector data<a class="anchor" aria-label="anchor" href="#rasterize-the-vector-data"></a>
</h2>
<hr class="half-width">
<p>One way to define the zones, is to create a grid space with the same
extent and resolution as the burned index raster, and with the numerical
values in the grid representing the type of infrastructure, i.e., the
zones. This can be done by rasterize the vector data <code>assets</code>
to the grid space of <code>burned</code>.</p>
<p>Let’s first take two elements from <code>assets</code>, the geometry
column, and the code of the region.</p>
<div class="codewrapper sourceCode" id="cb5">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a>geom <span class="op">=</span> assets[[<span class="st">'geometry'</span>, <span class="st">'code'</span>]].values.tolist()</span>
<span id="cb5-2"><a href="#cb5-2" tabindex="-1"></a>geom</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>[[&lt;POLYGON ((602761.27 4013139.375, 602764.522 4013072.287, 602771.476 4012998...&gt;,
  1],
 [&lt;POLYGON ((602779.808 4013298.838, 602772.497 4013266.01, 602768.577 4013242...&gt;,
  1],
 [&lt;POLYGON ((602594.855 4012962.661, 602593.423 4012983.028, 602588.485 401302...&gt;,
  1],
  ...]</code></pre>
</div>
<p>The raster image <code>burned</code> is a 3D image with a “band”
dimension.</p>
<div class="codewrapper sourceCode" id="cb7">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a>burned.shape</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>(1, 4523, 4828)</code></pre>
</div>
<p>To create the grid space, we only need the two spatial dimensions. We
can used <code>.squeeze()</code> to drop the band dimension:</p>
<div class="codewrapper sourceCode" id="cb9">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a>burned_squeeze <span class="op">=</span> burned.squeeze()</span>
<span id="cb9-2"><a href="#cb9-2" tabindex="-1"></a>burned_squeeze.shape</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>(4523, 4828)</code></pre>
</div>
<p>Now we can use <code>features.rasterize</code> from
<code>rasterio</code> to rasterize the vector data <code>assets</code>
to the grid space of <code>burned</code>:</p>
<div class="codewrapper sourceCode" id="cb11">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a><span class="im">from</span> rasterio <span class="im">import</span> features</span>
<span id="cb11-2"><a href="#cb11-2" tabindex="-1"></a>assets_rasterized <span class="op">=</span> features.rasterize(geom, out_shape<span class="op">=</span>burned_squeeze.shape, transform<span class="op">=</span>burned.rio.transform())</span>
<span id="cb11-3"><a href="#cb11-3" tabindex="-1"></a>assets_rasterized</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>array([[0, 0, 0, ..., 0, 0, 0],
       [0, 0, 0, ..., 0, 0, 0],
       [0, 0, 0, ..., 0, 0, 0],
       ...,
       [0, 0, 0, ..., 0, 0, 0],
       [0, 0, 0, ..., 0, 0, 0],
       [0, 0, 0, ..., 0, 0, 0]], dtype=uint8)</code></pre>
</div>
</section><section><h2 class="section-heading" id="perform-zonal-statistics">Perform zonal statistics<a class="anchor" aria-label="anchor" href="#perform-zonal-statistics"></a>
</h2>
<hr class="half-width">
<p>The rasterized zones <code>assets_rasterized</code> is a
<code>numpy</code> array. The Python package <code>xrspatial</code>,
which is the one we will use for zoning statistics, accepts
<code>xarray.DataArray</code>. We need to first convert
<code>assets_rasterized</code>. We can use <code>burned_squeeze</code>
as a template:</p>
<div class="codewrapper sourceCode" id="cb13">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a>assets_rasterized_xarr <span class="op">=</span> burned_squeeze.copy()</span>
<span id="cb13-2"><a href="#cb13-2" tabindex="-1"></a>assets_rasterized_xarr.data <span class="op">=</span> assets_rasterized</span>
<span id="cb13-3"><a href="#cb13-3" tabindex="-1"></a>assets_rasterized_xarr.plot()</span></code></pre>
</div>
<figure><img src="fig/E10/zones_rasterized_xarray.png" alt="Rasterized zones" class="figure mx-auto d-block"></figure><p>Then we can calculate the zonal statistics using the
<code>zonal_stats</code> function:</p>
<div class="codewrapper sourceCode" id="cb14">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" tabindex="-1"></a><span class="im">from</span> xrspatial <span class="im">import</span> zonal_stats</span>
<span id="cb14-2"><a href="#cb14-2" tabindex="-1"></a>stats <span class="op">=</span> zonal_stats(assets_rasterized_xarr, burned_squeeze)</span>
<span id="cb14-3"><a href="#cb14-3" tabindex="-1"></a>stats</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>   zone      mean  max  min       sum       std       var       count
0     0  0.023504  1.0  0.0  485164.0  0.151498  0.022952  20641610.0
1     1  0.010361  1.0  0.0    9634.0  0.101259  0.010253    929853.0
2     2  0.000004  1.0  0.0       1.0  0.001940  0.000004    265581.0</code></pre>
</div>
<p>The results provide statistics for three zones: <code>1</code>
represents infrastructure regions, <code>2</code> represents built-up
regions, and <code>0</code> represents the rest of the area.</p>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Key Points</h3>
<div class="callout-content">
<ul>
<li>Zones can be extracted by attribute columns of a vector dataset</li>
<li>Zones can be rasterized using
<code>rasterio.features.rasterize</code>
</li>
<li>Calculate zonal statistics with <code>xrspatial.zonal_stats</code>
over the rasterized zones.</li>
</ul>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</section></section><section id="aio-11-parallel-raster-computations"><p>Content from <a href="11-parallel-raster-computations.html">Parallel raster computations using Dask</a></p>
<hr>
<p>Last updated on 2025-05-20 |

        <a href="https://github.com/carpentries-incubator/geospatial-python/edit/main/episodes/11-parallel-raster-computations.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>How can I parallelize computations on rasters with Dask?</li>
<li>How can I determine if parallelization improves calculation
speed?</li>
<li>What are good practices in applying parallelization to my raster
calculations?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Profile the timing of the raster calculations.</li>
<li>Open raster data as a chunked array.</li>
<li>Recognize good practices in selecting proper chunk sizes.</li>
<li>Setup raster calculations that take advantage of
parallelization.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<section><h2 class="section-heading" id="introduction">Introduction<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h2>
<hr class="half-width">
<p>Very often raster computations involve applying the same operation to
different pieces of data. Think, for instance, to the “pixel”-wise sum
of two raster datasets, where the same sum operation is applied to all
the matching grid-cells of the two rasters. This class of tasks can
benefit from chunking the input raster(s) into smaller pieces:
operations on different pieces can be run in parallel using multiple
computing units (e.g., multi-core CPUs), thus potentially speeding up
calculations. In addition, working on chunked data can lead to smaller
memory footprints, since one may bypass the need to store the full
dataset in memory by processing it chunk by chunk.</p>
<p>In this episode, we will introduce the use of Dask in the context of
raster calculations. Dask is a Python library for parallel and
distributed computing. It provides a framework to work with different
data structures, including chunked arrays (Dask Arrays). Dask is well
integrated with (<code>rio</code>)<code>xarray</code>, which can use
Dask arrays as underlying data structures.</p>
<div id="dask" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div id="dask" class="callout-inner">
<h3 class="callout-title">Dask</h3>
<div class="callout-content">
<p>This episode shows how Dask can be used to parallelize operations on
local CPUs. However, the same library can be configured to run tasks on
large compute clusters.</p>
<p>More resources on Dask:</p>
<ul>
<li>
<a href="https://dask.org" class="external-link">Dask</a> and <a href="https://docs.dask.org/en/stable/array.html" class="external-link">Dask Array</a>.</li>
<li>
<a href="https://xarray.pydata.org/en/stable/user-guide/dask.html" class="external-link">Xarray
with Dask</a>.</li>
</ul>
</div>
</div>
</div>
<p>It is important to realize, however, that many details determine the
extent to which using Dask’s chunked arrays instead of regular Numpy
arrays leads to faster calculations (and lower memory requirements). The
actual operations to carry out, the size of the dataset, and parameters
such as the chunks’ shape and size, all affects the performance of our
computations. Depending on the specifics of the calculations, serial
calculations might actually turn out to be faster! Being able to profile
the computational time is thus essential, and we will see how to do that
in a Jupyter environment in the next section.</p>
<div id="introduce-the-data" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div id="introduce-the-data" class="callout-inner">
<h3 class="callout-title">Introduce the Data</h3>
<div class="callout-content">
<p>We will use satellite images from the search that we have carried out
in <a href="05-access-data.html">the episode: “Access satellite imagery
using Python”</a>. Briefly, we have searched for Sentinel-2 scenes of
Rhodes from July 1st to August 31st 2023 that have less than 1% cloud
coverage. The search resulted in 11 scenes. We focus here on the most
recent scene (August 27th), since that would show the situation after
the wildfire, and use this as an example to demonstrate parallel raster
calculations.</p>
<p>For your convenience, we have included the scene of interest among
the datasets that you have already downloaded when following <a href="index.html#setup">the setup instructions</a>. You should, however, be
able to download the satellite images “on-the-fly” using the JSON
metadata file that was created in <a href="05-access-data.html">the
previous episode</a> (the file <code>rhodes_sentinel-2.json</code>).</p>
<p>If you choose to work with the provided data (which is advised in
case you are working offline or have a slow/unstable network connection)
you can skip the remaining part of the block and continue with the
following section: <a href="#Dask-powered-rasters">Dask-powered
rasters</a>.</p>
<p>If you want instead to experiment with downloading the data
on-the-fly, you need to load the file
<code>rhodes_sentinel-2.json</code>, which contains information on where
and how to access the target satellite images from the remote
repository:</p>
<div class="codewrapper sourceCode" id="cb1">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="im">import</span> pystac</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a>items <span class="op">=</span> pystac.ItemCollection.from_file(<span class="st">"rhodes_sentinel-2.json"</span>)</span></code></pre>
</div>
<p>You can then select the first item in the collection, which is the
most recent in the sequence:</p>
<div class="codewrapper sourceCode" id="cb2">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a>item <span class="op">=</span> items[<span class="dv">0</span>]</span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a><span class="bu">print</span>(item)</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>&lt;Item id=S2A_35SNA_20230827_0_L2A&gt;</code></pre>
</div>
<p>In this episode we will consider the red and near infrared bands
associated with this scene. We extract the URL / <code>href</code>
(Hypertext Reference) that point to each of the raster files, and store
these in variables that we can use later on instead of the raster data
paths to access the data:</p>
<div class="codewrapper sourceCode" id="cb4">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a>rhodes_red_href <span class="op">=</span> item.assets[<span class="st">"red"</span>].href  <span class="co"># red band</span></span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a>rhodes_nir_href <span class="op">=</span> item.assets[<span class="st">"nir"</span>].href  <span class="co"># near-infrared band</span></span></code></pre>
</div>
</div>
</div>
</div>
</section><section><h2 class="section-heading" id="dask-powered-rasters">Dask-powered rasters<a class="anchor" aria-label="anchor" href="#dask-powered-rasters"></a>
</h2>
<hr class="half-width">
<div class="section level3">
<h3 id="chunked-arrays">Chunked arrays<a class="anchor" aria-label="anchor" href="#chunked-arrays"></a>
</h3>
<p>As we have mentioned, <code>rioxarray</code> supports the use of
Dask’s chunked arrays as underlying data structure. When opening a
raster file with <code>open_rasterio</code> and providing the
<code>chunks</code> argument, Dask arrays are employed instead of
regular Numpy arrays. <code>chunks</code> describes the shape of the
blocks which the data will be split in. As an example, we open the red
band raster using a chunk shape of <code>(1, 4000, 4000)</code> (block
size of <code>1</code> in the first dimension and of <code>4000</code>
in the second and third dimensions):</p>
<div class="codewrapper sourceCode" id="cb5">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a><span class="im">import</span> rioxarray</span>
<span id="cb5-2"><a href="#cb5-2" tabindex="-1"></a>red <span class="op">=</span> rioxarray.open_rasterio(<span class="st">"data/sentinel2/red.tif"</span>, chunks<span class="op">=</span>(<span class="dv">1</span>, <span class="dv">4000</span>, <span class="dv">4000</span>))</span></code></pre>
</div>
<p>Xarray and Dask also provide a graphical representation of the raster
data array and of its blocked structure.</p>
<figure><img src="fig/E11/xarray-with-dask.png" alt="DataArray with Dask" class="figure mx-auto d-block"><div class="figcaption">Xarray Dask-backed DataArray</div>
</figure><div id="exercise-chunk-sizes-matter" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="exercise-chunk-sizes-matter" class="callout-inner">
<h3 class="callout-title">Exercise: Chunk sizes matter</h3>
<div class="callout-content">
<p>We have already seen how COGs are regular GeoTIFF files with a
special internal structure. Another feature of COGs is that data is
organized in “blocks” that can be accessed remotely via independent HTTP
requests, enabling partial file readings. This is useful if you want to
access only a portion of your raster file, but it also allows for
efficient parallel reading. You can check the blocksize employed in a
COG file with the following code snippet:</p>
<div class="codewrapper sourceCode" id="cb6">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a><span class="im">import</span> rasterio</span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a><span class="cf">with</span> rasterio.<span class="bu">open</span>(<span class="st">"/path/or/URL/to/file.tif"</span>) <span class="im">as</span> r:</span>
<span id="cb6-3"><a href="#cb6-3" tabindex="-1"></a>    <span class="cf">if</span> r.is_tiled:</span>
<span id="cb6-4"><a href="#cb6-4" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Chunk size: </span><span class="sc">{</span>r<span class="sc">.</span>block_shapes<span class="sc">}</span><span class="ss">"</span>)</span></code></pre>
</div>
<p>In order to optimally access COGs it is best to align the blocksize
of the file with the chunks enployed when loading the file. Which other
elements do you think should be considered when choosing the chunk size?
What do you think are suitable chunk sizes for the red band raster?</p>
</div>
</div>
</div>
<div id="accordionSolution1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution1" aria-expanded="false" aria-controls="collapseSolution1">
  <h4 class="accordion-header" id="headingSolution1"> Show me the solution </h4>
</button>
<div id="collapseSolution1" class="accordion-collapse collapse" aria-labelledby="headingSolution1" data-bs-parent="#accordionSolution1">
<div class="accordion-body">
<div class="codewrapper sourceCode" id="cb7">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a><span class="im">import</span> rasterio</span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a><span class="cf">with</span> rasterio.<span class="bu">open</span>(<span class="st">"data/sentinel2/red.tif"</span>) <span class="im">as</span> r:</span>
<span id="cb7-3"><a href="#cb7-3" tabindex="-1"></a>    <span class="cf">if</span> r.is_tiled:</span>
<span id="cb7-4"><a href="#cb7-4" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Chunk size: </span><span class="sc">{</span>r<span class="sc">.</span>block_shapes<span class="sc">}</span><span class="ss">"</span>)</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>Chunk size: [(1024, 1024)]</code></pre>
</div>
<p>Ideal chunk size values for this raster are multiples of 1024. An
element to consider is the number of resulting chunks and their size.
While the optimal chunk size strongly depends on the specific
application, chunks should in general not be too big nor too small
(i.e. too many). As a rule of thumb, chunk sizes of 100 MB typically
work well with Dask (see, e.g., this <a href="https://blog.dask.org/2021/11/02/choosing-dask-chunk-sizes" class="external-link">blog
post</a>). Also, the shape might be relevant, depending on the
application! Here, we might select a chunks shape of
<code>(1, 6144, 6144)</code>::</p>
<div class="codewrapper sourceCode" id="cb9">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a>red <span class="op">=</span> rioxarray.open_rasterio(<span class="st">"data/sentinel2/red.tif"</span>, chunks<span class="op">=</span>(<span class="dv">1</span>, <span class="dv">6144</span>, <span class="dv">6144</span>))</span></code></pre>
</div>
<p>which leads to chunks 72 MB large: ((1 x 6144 x 6144) x 2 bytes /
2^20 = 72 MB). Also, we can let rioxarray and Dask figure out
appropriate chunk shapes by setting <code>chunks="auto"</code>:</p>
<div class="codewrapper sourceCode" id="cb10">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a>red <span class="op">=</span> rioxarray.open_rasterio(<span class="st">"data/sentinel2/red.tif"</span>, chunks<span class="op">=</span><span class="st">"auto"</span>)</span></code></pre>
</div>
<p>which leads to <code>(1, 8192, 8192)</code> chunks (128 MB).</p>
</div>
</div>
</div>
</div>
</div>
<div class="section level3">
<h3 id="parallel-computations">Parallel computations<a class="anchor" aria-label="anchor" href="#parallel-computations"></a>
</h3>
<p>Operations performed on a <code>DataArray</code> that has been opened
as a chunked Dask array are executed using Dask. Dask coordinates how
the operations should be executed on the individual chunks of data, and
runs these tasks in parallel as much as possible.</p>
<p>Let us set up an example where we calculate the NDVI for a full
Sentinel-2 tile, and try to estimate the performance gain by running the
calculation in parallel on a multi-core CPU.</p>
<p>To run the calculation serially, we open the relevant raster bands,
as we have learned in the previous episodes:</p>
<div class="codewrapper sourceCode" id="cb11">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a>red <span class="op">=</span> rioxarray.open_rasterio(<span class="st">'data/sentinel2/red.tif'</span>, masked<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb11-2"><a href="#cb11-2" tabindex="-1"></a>nir <span class="op">=</span> rioxarray.open_rasterio(<span class="st">'data/sentinel2/nir.tif'</span>, masked<span class="op">=</span><span class="va">True</span>)</span></code></pre>
</div>
<p>We then compute the NDVI. Note the Jupyter magic <code>%%time</code>,
which returns the time required to run the content of a cell (note that
commands starting with <code>%%</code> needs to be on the first line of
the cell!):</p>
<div class="codewrapper sourceCode" id="cb12">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a><span class="op">%%</span>time</span>
<span id="cb12-2"><a href="#cb12-2" tabindex="-1"></a>ndvi <span class="op">=</span> (nir <span class="op">-</span> red)<span class="op">/</span>(nir <span class="op">+</span> red)</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>CPU times: user 4.99 s, sys: 3.44 s, total: 8.43 s
Wall time: 8.53 s</code></pre>
</div>
<p>We note down the calculation’s “Wall time” (actual time to perform
the task).</p>
<p>Now we run the same task in parallel using Dask. To do so, we open
the relevant rasters as chunked arrays:</p>
<div class="codewrapper sourceCode" id="cb14">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" tabindex="-1"></a>red_dask <span class="op">=</span> rioxarray.open_rasterio(<span class="st">'data/sentinel2/red.tif'</span>, masked<span class="op">=</span><span class="va">True</span>, lock<span class="op">=</span><span class="va">False</span>, chunks<span class="op">=</span>(<span class="dv">1</span>, <span class="dv">6144</span>, <span class="dv">6144</span>))</span>
<span id="cb14-2"><a href="#cb14-2" tabindex="-1"></a>nir_dask <span class="op">=</span> rioxarray.open_rasterio(<span class="st">'data/sentinel2/nir.tif'</span>, masked<span class="op">=</span><span class="va">True</span>, lock<span class="op">=</span><span class="va">False</span>, chunks<span class="op">=</span>(<span class="dv">1</span>, <span class="dv">6144</span>, <span class="dv">6144</span>))</span></code></pre>
</div>
<p>Setting <code>lock=False</code> tells <code>rioxarray</code> that the
individual data chunks can be loaded simultaneously from the source by
the Dask workers.</p>
<p>We now continue to the actual calculation: Note how the same syntax
as for its serial version is employed for computing the NDVI. Don’t
forget to add the Jupyter magic to record the timing!</p>
<div class="codewrapper sourceCode" id="cb15">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" tabindex="-1"></a><span class="op">%%</span>time</span>
<span id="cb15-2"><a href="#cb15-2" tabindex="-1"></a>ndvi_dask <span class="op">=</span> (nir_dask <span class="op">-</span> red_dask)<span class="op">/</span>(nir_dask <span class="op">+</span> red_dask)</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>CPU times: user 7.71 ms, sys: 1.71 ms, total: 9.42 ms
Wall time: 8.61 ms</code></pre>
</div>
<p>Did we just observe a 1000x speed-up when comparing to the serial
calculation (~8 s vs ~8 ms)? Actually, no calculation has run yet. This
is because operations performed on Dask arrays are executed “lazily”,
i.e. they are not immediately run.</p>
<div id="dask-graph" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div id="dask-graph" class="callout-inner">
<h3 class="callout-title">Dask graph</h3>
<div class="callout-content">
<p>The sequence of operations to carry out is stored in a task graph,
which can be visualized with:</p>
<div class="codewrapper sourceCode" id="cb17">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" tabindex="-1"></a><span class="im">import</span> dask</span>
<span id="cb17-2"><a href="#cb17-2" tabindex="-1"></a>dask.visualize(ndvi_dask)</span></code></pre>
</div>
<figure><img src="fig/E11/dask-graph.png" alt="dask graph" class="figure mx-auto d-block"><div class="figcaption">Dask graph</div>
</figure><p>The task graph gives Dask the complete “overview” of the calculation,
thus enabling a better management of tasks and resources when
dispatching calculations to be run in parallel.</p>
</div>
</div>
</div>
<p>Most methods of <code>DataArray</code>’s run operations lazily when
Dask arrays are employed. In order to trigger calculations, we can use
either <code>.persist()</code> or <code>.compute()</code>. The former
keeps data in the form of chunked Dask arrays, and it should thus be
used to run intermediate steps that will be followed by additional
calculations. The latter merges instead the chunks in a single Numpy
array, and it should be used at the very end of a sequence of
calculations. Both methods accept the same parameters. Here, we
explicitly tell Dask to parallelize the required workload over 4
threads. Let’s again time the cell execution:</p>
<div class="codewrapper sourceCode" id="cb18">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" tabindex="-1"></a><span class="op">%%</span>time</span>
<span id="cb18-2"><a href="#cb18-2" tabindex="-1"></a>ndvi_dask <span class="op">=</span> ndvi_dask.persist(scheduler<span class="op">=</span><span class="st">"threads"</span>, num_workers<span class="op">=</span><span class="dv">4</span>)</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>CPU times: user 4.18 s, sys: 2.19 s, total: 6.37 s
Wall time: 2.32 s</code></pre>
</div>
<p>The timing that we have recorded makes much more sense now. When
running the task on a 4-core CPU laptop, we observe a x3.6 speed-up when
comparing to the analogous serial calculation (8.53 s vs 2.32 s).</p>
<p>Once again, we stress that one does not always obtain similar
performance gains by exploiting the Dask-based parallelization. Even if
the algorithm employed is well suited for parallelization, Dask
introduces some overhead time to manage the tasks in the Dask graph.
This overhead, which is typically of the order of few milliseconds per
task, can be larger than the parallelization gain. This is the typical
situation with calculations with many small chunks.</p>
<p>Finally, let’s have a look at how Dask can be used to save raster
files. When calling <code>.to_raster()</code>, we provide the as
additional argument <code>lock=threading.Lock()</code>. This is because
the threads which are splitting the workload must “synchronise” when
writing to the same file (they might otherwise overwrite each other’s
output).</p>
<div class="codewrapper sourceCode" id="cb20">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" tabindex="-1"></a><span class="im">from</span> threading <span class="im">import</span> Lock</span>
<span id="cb20-2"><a href="#cb20-2" tabindex="-1"></a>ndvi_dask.rio.to_raster(<span class="st">'ndvi.tif'</span>, tiled<span class="op">=</span><span class="va">True</span>, lock<span class="op">=</span>Lock())</span></code></pre>
</div>
<p>Note that <code>.to_raster()</code> is among the methods that trigger
immediate calculations (one can change this behaviour by specifying
<code>compute=False</code>).</p>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Key Points</h3>
<div class="callout-content">
<ul>
<li>The <code>%%time</code> Jupyter magic command can be used to profile
calculations.</li>
<li>Data ‘chunks’ are the unit of parallelization in raster
calculations.</li>
<li>(<code>rio</code>)<code>xarray</code> can open raster files as
chunked arrays.</li>
<li>The chunk shape and size can significantly affect the calculation
performance.</li>
<li>Cloud-optimized GeoTIFFs have an internal structure that enables
performant parallel read.</li>
</ul>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</div>
</section></section><section id="aio-12-data-cube"><p>Content from <a href="12-data-cube.html">Data cubes with ODC-STAC</a></p>
<hr>
<p>Last updated on 2025-05-20 |

        <a href="https://github.com/carpentries-incubator/geospatial-python/edit/main/episodes/12-data-cube.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>Can I mosaic tiled raster datasets when my area of interest spans
multiple files?<br>
</li>
<li>Can I stack raster datasets that cover the same area along the time
dimension in order to explore temporal changes of some quantities?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>ODC-STAC allows you to work with raster datasets spanning multiple
files as if they were a single multi-dimensional object (a “data
cube”).</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<section><h2 class="section-heading" id="introduction">Introduction<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h2>
<hr class="half-width">
<p>In the previous episodes we worked with satellite images with a fixed
boundary on how they have been collected, however in many cases you
would want to have an image that covers your area of interest which
often does not align with boundaries of the collected images. If the
phenomena you are interested in covers two images you could manually
mosaic them, but sometimes you are interested in multiple images that
overlapping.</p>
<p>ODC-STAC offers functionality that allows you to get a mosaic-ed
image based on the a bounding box or a polygon containing the area of
interest. In this lesson we show how <a href="https://odc-stac.readthedocs.io/en/latest/?badge=latest" class="external-link">odc-stac</a>
can be employed to re-tile and stack satellite images in what are
sometimes referred to as “data cubes”.</p>
</section><section><h2 class="section-heading" id="create-a-data-cube-with-odc-stac">Create a data cube with ODC-STAC<a class="anchor" aria-label="anchor" href="#create-a-data-cube-with-odc-stac"></a>
</h2>
<hr class="half-width">
<p>As you might have noticed in the previous episodes, the satellite
images we have used until now do actually not cover the whole island of
Rhodes. They miss the southern part of the island. Using ODC-STAC we can
obtain an image for the whole island. We use the administrative boundary
of Rhodes to define our area of interest (AoI). This way we are sure to
have the whole island.</p>
<p>More important, using ODC-STAC you can also load multiple images
(lazy) into one datacube allowing you to perform all kind of interesting
analyses as will be demonstrated below.</p>
<p>But first we need to upload the geometry of Rhodes. To do so we use
geopandas and load the geometry we previously stored in a
geopackage.</p>
<div class="codewrapper sourceCode" id="cb1">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="im">import</span> geopandas</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a>rhodes <span class="op">=</span> geopandas.read_file(<span class="st">'rhodes.gpkg'</span>)</span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a>bbox <span class="op">=</span> rhodes.total_bounds</span></code></pre>
</div>
<p>Next, we search for satellite images that cover our AoI (i.e. Rhodes)
in the <a href="https://radiantearth.github.io/stac-browser/#/external/earth-search.aws.element84.com/v1/collections/sentinel-2-l2a" class="external-link">Sentinel-2
L2A</a> collection that is indexed in the <a href="https://radiantearth.github.io/stac-browser/#/external/earth-search.aws.element84.com/v1/" class="external-link">Earth
Search STAC API</a>. Since we are interested the period right before and
after the wild fire we include as dates the 1st of July until the 31st
of August 2023 :</p>
<div class="codewrapper sourceCode" id="cb2">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a><span class="im">import</span> pystac_client</span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" tabindex="-1"></a>api_url <span class="op">=</span> <span class="st">"https://earth-search.aws.element84.com/v1"</span></span>
<span id="cb2-4"><a href="#cb2-4" tabindex="-1"></a>collection_id <span class="op">=</span> <span class="st">"sentinel-2-c1-l2a"</span></span>
<span id="cb2-5"><a href="#cb2-5" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" tabindex="-1"></a>client <span class="op">=</span> pystac_client.Client.<span class="bu">open</span>(api_url)</span>
<span id="cb2-7"><a href="#cb2-7" tabindex="-1"></a>search <span class="op">=</span> client.search(</span>
<span id="cb2-8"><a href="#cb2-8" tabindex="-1"></a>    collections<span class="op">=</span>[collection_id],</span>
<span id="cb2-9"><a href="#cb2-9" tabindex="-1"></a>    datetime<span class="op">=</span><span class="st">"2023-07-01/2023-08-31"</span>,</span>
<span id="cb2-10"><a href="#cb2-10" tabindex="-1"></a>    bbox<span class="op">=</span>bbox</span>
<span id="cb2-11"><a href="#cb2-11" tabindex="-1"></a>)</span>
<span id="cb2-12"><a href="#cb2-12" tabindex="-1"></a></span>
<span id="cb2-13"><a href="#cb2-13" tabindex="-1"></a>item_collection <span class="op">=</span> search.item_collection()</span></code></pre>
</div>
<p><a href="https://odc-stac.readthedocs.io/en/latest/?badge=latest" class="external-link">odc-stac</a>
can ingest directly our search results and create a Xarray DataSet
object from the STAC metadata that are present in the
<code>item_collection</code>. By specifying
<code>groupby='solar_day'</code>, odc-stac automatically groups and
merges images corresponding to the same date of acquisition.
<code>chunks={...}</code> sets up the resulting data cube using Dask
arrays, thus enabling lazy loading (and further operations).
<code>use_overviews=True</code> tells odc-stac to direcly load
lower-resolution versions of the images from the overviews, if these are
available in Cloud Optimized Geotiffs (COGs). We set the resolution of
the data cube using the <code>resolution</code> argument, and define the
AoI using the bounding box (<code>bbox</code>). We decided to set the
resolution to 20 in order to limit the size of the images a bit.</p>
<div class="codewrapper sourceCode" id="cb3">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a><span class="im">import</span> odc.stac</span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a>ds <span class="op">=</span> odc.stac.load(</span>
<span id="cb3-3"><a href="#cb3-3" tabindex="-1"></a>    item_collection,</span>
<span id="cb3-4"><a href="#cb3-4" tabindex="-1"></a>    groupby<span class="op">=</span><span class="st">'solar_day'</span>,</span>
<span id="cb3-5"><a href="#cb3-5" tabindex="-1"></a>    chunks<span class="op">=</span>{<span class="st">'x'</span>: <span class="dv">2048</span>, <span class="st">'y'</span>: <span class="dv">2048</span>},</span>
<span id="cb3-6"><a href="#cb3-6" tabindex="-1"></a>    use_overviews<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb3-7"><a href="#cb3-7" tabindex="-1"></a>    resolution<span class="op">=</span><span class="dv">20</span>,</span>
<span id="cb3-8"><a href="#cb3-8" tabindex="-1"></a>    bbox<span class="op">=</span>rhodes.total_bounds,</span>
<span id="cb3-9"><a href="#cb3-9" tabindex="-1"></a>)</span></code></pre>
</div>
<p>odc-stac builds a data cube representation from all the relevant
files linked in <code>item_collection</code> as a Xarray DataSet. Let us
have a look at it:</p>
<div class="codewrapper sourceCode" id="cb4">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a><span class="bu">print</span>(ds)</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>&lt;xarray.Dataset&gt; Size: 7GB
Dimensions:      (y: 3255, x: 2567, time: 25)
Coordinates:
  * y            (y) float64 26kB 4.035e+06 4.035e+06 ... 3.97e+06 3.97e+06
  * x            (x) float64 21kB 5.613e+05 5.613e+05 ... 6.126e+05 6.126e+05
    spatial_ref  int32 4B 32635
  * time         (time) datetime64[ns] 200B 2023-07-01T09:10:15.805000 ... 20...
Data variables: (12/18)
    red          (time, y, x) uint16 418MB dask.array&lt;chunksize=(1, 2048, 2048), meta=np.ndarray&gt;
    green        (time, y, x) uint16 418MB dask.array&lt;chunksize=(1, 2048, 2048), meta=np.ndarray&gt;
    blue         (time, y, x) uint16 418MB dask.array&lt;chunksize=(1, 2048, 2048), meta=np.ndarray&gt;
    visual       (time, y, x) float32 836MB dask.array&lt;chunksize=(1, 2048, 2048), meta=np.ndarray&gt;
    nir          (time, y, x) uint16 418MB dask.array&lt;chunksize=(1, 2048, 2048), meta=np.ndarray&gt;
    swir22       (time, y, x) uint16 418MB dask.array&lt;chunksize=(1, 2048, 2048), meta=np.ndarray&gt;
    ...           ...
    scl          (time, y, x) uint8 209MB dask.array&lt;chunksize=(1, 2048, 2048), meta=np.ndarray&gt;
    aot          (time, y, x) uint16 418MB dask.array&lt;chunksize=(1, 2048, 2048), meta=np.ndarray&gt;
    coastal      (time, y, x) uint16 418MB dask.array&lt;chunksize=(1, 2048, 2048), meta=np.ndarray&gt;
    nir09        (time, y, x) uint16 418MB dask.array&lt;chunksize=(1, 2048, 2048), meta=np.ndarray&gt;
    cloud        (time, y, x) uint8 209MB dask.array&lt;chunksize=(1, 2048, 2048), meta=np.ndarray&gt;
    snow         (time, y, x) uint8 209MB dask.array&lt;chunksize=(1, 2048, 2048), meta=np.ndarray&gt;</code></pre>
</div>
</section><section><h2 class="section-heading" id="working-with-the-data-cube">Working with the data cube<a class="anchor" aria-label="anchor" href="#working-with-the-data-cube"></a>
</h2>
<hr class="half-width">
<p>Like we did in the previous episode, let us calculate the NDVI for
our study area. To do so we need to focus on the variables: the red band
(<code>red</code>), the near infrared band (<code>nir</code>) and the
scene classification map (<code>scl</code>). We will use the former two
to calculated the NDVI for the AoI. The latter, we use as <a href="https://sentinels.copernicus.eu/web/sentinel/technical-guides/sentinel-2-msi/level-2a/algorithm-overview" class="external-link">a
classification mask</a> provided together with Sentinel-2 L2A products.
In this mask, each pixel is classified according to a set of labels (see
Figure 3 in <a href="https://sentinels.copernicus.eu/web/sentinel/technical-guides/sentinel-2-msi/level-2a/algorithm-overview" class="external-link">classification
mask documentation</a> ).</p>
<p>First we define the bands that we are interested in:</p>
<div class="codewrapper sourceCode" id="cb6">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a>red <span class="op">=</span> ds[<span class="st">'red'</span>]</span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a>nir <span class="op">=</span> ds[<span class="st">'nir'</span>]</span>
<span id="cb6-3"><a href="#cb6-3" tabindex="-1"></a>scl <span class="op">=</span> ds[<span class="st">'scl'</span>]</span></code></pre>
</div>
<p>Next we will use the mask to drop pixels that are labeled as clouds
and water. For this we use the classification map to mask out pixels
recognized by the <a href="https://custom-scripts.sentinel-hub.com/custom-scripts/sentinel-2/scene-classification/" class="external-link">Sentinel-2
processing algorithm</a> as cloud or water:</p>
<div class="codewrapper sourceCode" id="cb7">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a><span class="co"># generate mask ("True" for pixel being cloud or water)</span></span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a>mask <span class="op">=</span> scl.isin([</span>
<span id="cb7-3"><a href="#cb7-3" tabindex="-1"></a>    <span class="dv">3</span>,  <span class="co"># CLOUD_SHADOWS</span></span>
<span id="cb7-4"><a href="#cb7-4" tabindex="-1"></a>    <span class="dv">6</span>,  <span class="co"># WATER</span></span>
<span id="cb7-5"><a href="#cb7-5" tabindex="-1"></a>    <span class="dv">8</span>,  <span class="co"># CLOUD_MEDIUM_PROBABILITY</span></span>
<span id="cb7-6"><a href="#cb7-6" tabindex="-1"></a>    <span class="dv">9</span>,  <span class="co"># CLOUD_HIGH_PROBABILITY</span></span>
<span id="cb7-7"><a href="#cb7-7" tabindex="-1"></a>    <span class="dv">10</span>  <span class="co"># THIN_CIRRUS</span></span>
<span id="cb7-8"><a href="#cb7-8" tabindex="-1"></a>])</span>
<span id="cb7-9"><a href="#cb7-9" tabindex="-1"></a>red_masked <span class="op">=</span> red.where(<span class="op">~</span>mask)</span>
<span id="cb7-10"><a href="#cb7-10" tabindex="-1"></a>nir_masked <span class="op">=</span> nir.where(<span class="op">~</span>mask)</span></code></pre>
</div>
<p>Then, we calculate the NDVI:</p>
<div class="codewrapper sourceCode" id="cb8">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a>ndvi <span class="op">=</span> (nir_masked <span class="op">-</span> red_masked) <span class="op">/</span> (nir_masked <span class="op">+</span> red_masked)</span></code></pre>
</div>
<p>We can visualize the calculated NDVI for the AoI at two given dates
(before and after the wildfires) by selecting the date:</p>
<div class="codewrapper sourceCode" id="cb9">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a>ndvi_before <span class="op">=</span> ndvi.sel(time<span class="op">=</span><span class="st">"2023-07-13"</span>)</span>
<span id="cb9-2"><a href="#cb9-2" tabindex="-1"></a>ndvi_before.plot()</span></code></pre>
</div>
<figure><img src="fig/E12/NDVI-before.png" alt="NDVI before the wildfire" class="figure mx-auto d-block"><div class="figcaption">NDVI before the wildfire</div>
</figure><div class="codewrapper sourceCode" id="cb10">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a>ndvi_after <span class="op">=</span> ndvi.sel(time<span class="op">=</span><span class="st">"2023-08-27"</span>)</span>
<span id="cb10-2"><a href="#cb10-2" tabindex="-1"></a>ndvi_after.plot()</span></code></pre>
</div>
<figure><img src="fig/E12/NDVI-after.png" alt="NDVI after the wildfire" class="figure mx-auto d-block"><div class="figcaption">NDVI after the wildfire</div>
</figure><p>Another feature of having the data available in a datacube is that
you can for instance questions multiple layers. If you want for instance
to see how the NDVI changed over time for a specific point you can do
the following. Let us first define a point in the region where we know
it was affected by the wildfile. To check that it is after the fire we
plot it:</p>
<div class="codewrapper sourceCode" id="cb11">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a>x <span class="op">=</span> <span class="dv">585_000</span></span>
<span id="cb11-2"><a href="#cb11-2" tabindex="-1"></a>y <span class="op">=</span> <span class="dv">3_995_000</span></span>
<span id="cb11-3"><a href="#cb11-3" tabindex="-1"></a></span>
<span id="cb11-4"><a href="#cb11-4" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb11-5"><a href="#cb11-5" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb11-6"><a href="#cb11-6" tabindex="-1"></a>ndvi_after.plot(ax<span class="op">=</span>ax)</span>
<span id="cb11-7"><a href="#cb11-7" tabindex="-1"></a>ax.scatter(x, y, marker<span class="op">=</span><span class="st">"o"</span>, c<span class="op">=</span><span class="st">"k"</span>)</span></code></pre>
</div>
<figure><img src="fig/E12/NDVI-after_point.png" alt="NDVI plot with selected point" class="figure mx-auto d-block"><div class="figcaption">NDVI plot with selected point</div>
</figure><p>Now let us extract the NDVI values computed at that point for the
full time series:</p>
<div class="codewrapper sourceCode" id="cb12">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a>ndvi_xy <span class="op">=</span> ndvi.sel(x<span class="op">=</span>x, y<span class="op">=</span>y, method<span class="op">=</span><span class="st">"nearest"</span>)</span>
<span id="cb12-2"><a href="#cb12-2" tabindex="-1"></a><span class="bu">print</span>(ndvi_xy)</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>&lt;xarray.DataArray (time: 25)&gt; Size: 100B
dask.array&lt;getitem, shape=(25,), dtype=float32, chunksize=(1,), chunktype=numpy.ndarray&gt;
Coordinates:
    y            float64 8B 3.995e+06
    x            float64 8B 5.85e+05
    spatial_ref  int32 4B 32635
  * time         (time) datetime64[ns] 200B 2023-07-01T09:10:15.805000 ... 20...</code></pre>
</div>
<p>We now trigger computation. Note that we run this in parallel
(probably not much of an effect here, but definitely helpful for larger
calculations):</p>
<div class="codewrapper sourceCode" id="cb14">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" tabindex="-1"></a><span class="op">%%</span>time</span>
<span id="cb14-2"><a href="#cb14-2" tabindex="-1"></a>ndvi_xy <span class="op">=</span> ndvi_xy.compute(scheduler<span class="op">=</span><span class="st">"threads"</span>, num_workers<span class="op">=</span><span class="dv">4</span>)</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>CPU times: user 15.6 s, sys: 4.9 s, total: 20.5 s
Wall time: 1min 8s</code></pre>
</div>
<p>The result is a time series representing the NDVI value computed for
the selected point for all the available scenes in the time range. We
drop the NaN values, and plot the final result:</p>
<div class="codewrapper sourceCode" id="cb16">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" tabindex="-1"></a>ndvi_xy.dropna(dim<span class="op">=</span><span class="st">"time"</span>).plot()</span></code></pre>
</div>
<figure><img src="fig/E12/NDVI-time-series.png" alt="NDVI time series" class="figure mx-auto d-block"><div class="figcaption">NDVI time series</div>
</figure><!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 --></section></section>
</div>
    </main>
</div>
<!-- END  : inst/pkgdown/templates/content-extra.html -->

      </div>
<!--/div.row-->
      		<footer class="row footer mx-md-3"><hr>
<div class="col-md-6">
        <p>This lesson is subject to the <a href="CODE_OF_CONDUCT.html">Code of Conduct</a></p>
        <p>

        <a href="https://github.com/carpentries-incubator/geospatial-python/edit/main/README.md" class="external-link">Edit on GitHub</a>

	
        | <a href="https://github.com/carpentries-incubator/geospatial-python/blob/main/CONTRIBUTING.md" class="external-link">Contributing</a>
        | <a href="https://github.com/carpentries-incubator/geospatial-python/" class="external-link">Source</a></p>
				<p><a href="https://github.com/carpentries-incubator/geospatial-python/blob/main/CITATION" class="external-link">Cite</a> | <a href="mailto:team@carpentries.org">Contact</a> | <a href="https://carpentries.org/about/" class="external-link">About</a></p>
			</div>
			<div class="col-md-6">

        <p>Materials licensed under <a href="LICENSE.html">CC-BY 4.0</a> by the authors</p>

        <p>Template licensed under <a href="https://creativecommons.org/licenses/by-sa/4.0/" class="external-link">CC-BY 4.0</a> by <a href="https://carpentries.org/" class="external-link">The Carpentries</a></p>
        <p>Built with <a href="https://github.com/carpentries/sandpaper/tree/0.16.12" class="external-link">sandpaper (0.16.12)</a>, <a href="https://github.com/carpentries/pegboard/tree/0.7.9" class="external-link">pegboard (0.7.9)</a>, and <a href="https://github.com/carpentries/varnish/tree/1.0.6" class="external-link">varnish (1.0.6)</a></p>
			</div>
		</footer>
</div> <!-- / div.container -->
	<div id="to-top">
		<a href="#top">
      <i class="search-icon" data-feather="arrow-up" role="img" aria-label="Back To Top"></i><br><!-- <span class="d-none d-sm-none d-md-none d-lg-none d-xl-block">Back</span> To Top --><span class="d-none d-sm-none d-md-none d-lg-none d-xl-block">Back</span> To Top
		</a>
	</div>
  <script type="application/ld+json">
    {
  "@context": "https://schema.org",
  "@type": "LearningResource",
  "@id": "https://carpentries-incubator.github.io/geospatial-python/aio.html",
  "inLanguage": "en",
  "dct:conformsTo": "https://bioschemas.org/profiles/LearningResource/1.0-RELEASE",
  "description": "A Carpentries Lesson teaching foundational data and coding skills to researchers worldwide",
  "keywords": "software, data, lesson, The Carpentries",
  "name": "All in One View",
  "creativeWorkStatus": "active",
  "url": "https://carpentries-incubator.github.io/geospatial-python/aio.html",
  "identifier": "https://carpentries-incubator.github.io/geospatial-python/aio.html",
  "dateCreated": "2025-05-20",
  "dateModified": "2025-07-15",
  "datePublished": "2025-07-15"
}

  </script><script>
		feather.replace();
	</script>
</body>
</html><!-- END:   inst/pkgdown/templates/layout.html-->

