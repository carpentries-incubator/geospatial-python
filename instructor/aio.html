<!DOCTYPE html>
<!-- START: inst/pkgdown/templates/layout.html --><!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<title>Introduction to Geospatial Raster and Vector Data with Python: All in One View</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" type="text/css" href="../assets/styles.css">
<script src="../assets/scripts.js" type="text/javascript"></script><!-- mathjax --><script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      config: ["MMLorHTML.js"],
      jax: ["input/TeX","input/MathML","output/HTML-CSS","output/NativeMML", "output/PreviewHTML"],
      extensions: ["tex2jax.js","mml2jax.js","MathMenu.js","MathZoom.js", "fast-preview.js", "AssistiveMML.js", "a11y/accessibility-menu.js"],
      TeX: {
        extensions: ["AMSmath.js","AMSsymbols.js","noErrors.js","noUndefined.js"]
      },
      tex2jax: {
        inlineMath: [['\\(', '\\)']],
        displayMath: [ ['$$','$$'], ['\\[', '\\]'] ],
        processEscapes: true
      }
    });
    </script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><!-- Responsive Favicon for The Carpentries --><link rel="apple-touch-icon" sizes="180x180" href="../apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png">
<link rel="manifest" href="../site.webmanifest">
<link rel="mask-icon" href="../safari-pinned-tab.svg" color="#5bbad5">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" content="#ffffff">
</head>
<body>
    <header id="top" class="navbar navbar-expand-md navbar-light bg-white top-nav incubator"><a class="visually-hidden-focusable skip-link" href="#main-content">Skip to main content</a>
  <div class="container-fluid top-nav-container">
    <div class="col-md-6">
      <div class="large-logo">
        <img alt="Carpentries Incubator" src="../assets/images/incubator-logo.svg"><abbr class="badge badge-light" title="This lesson is in the beta phase, which means that it is ready for teaching by instructors outside of the original author team." style="background-color: #001483; border-radius: 5px">
          <a href="https://cdh.carpentries.org/the-lesson-life-cycle.html#polishing-beta-stage" class="external-link alert-link" style="color: #FFF7F1">
            <i aria-hidden="true" class="icon" data-feather="alert-circle" style="border-radius: 5px"></i>
            Beta
          </a>
          <span class="visually-hidden">This lesson is in the beta phase, which means that it is ready for teaching by instructors outside of the original author team.</span>
        </abbr>
        
      </div>
    </div>
    <div class="selector-container">
      
      
      <div class="dropdown">
        <button class="btn btn-secondary dropdown-toggle bordered-button" type="button" id="dropdownMenu1" data-bs-toggle="dropdown" aria-expanded="false">
          <i aria-hidden="true" class="icon" data-feather="eye"></i> Instructor View <i data-feather="chevron-down"></i>
        </button>
        <ul class="dropdown-menu" aria-labelledby="dropdownMenu1">
<li><button class="dropdown-item" type="button" onclick="window.location.href='../aio.html';">Learner View</button></li>
        </ul>
</div>
    </div>
  </div>
  <hr></header><nav class="navbar navbar-expand-xl navbar-light bg-white bottom-nav incubator" aria-label="Main Navigation"><div class="container-fluid nav-container">
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle Navigation">
      <span class="navbar-toggler-icon"></span>
      <span class="menu-title">Menu</span>
    </button>
    <div class="nav-logo">
      <img class="small-logo" alt="Carpentries Incubator" src="../assets/images/incubator-logo-sm.svg">
</div>
    <div class="lesson-title-md">
      Introduction to Geospatial Raster and Vector Data with Python
    </div>
    <div class="search-icon-sm">
      <!-- TODO: do not show until we have search
        <i role="img" aria-label="Search the All In One page" data-feather="search"></i>
      -->
    </div>
    <div class="desktop-nav">
      <ul class="navbar-nav me-auto mb-2 mb-lg-0">
<li class="nav-item">
          <span class="lesson-title">
            Introduction to Geospatial Raster and Vector Data with Python
          </span>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="../instructor/key-points.html">Key Points</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="../instructor/instructor-notes.html">Instructor Notes</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="../instructor/images.html">Extract All Images</a>
        </li>
        <li class="nav-item dropdown">
          <button class="nav-link dropdown-toggle" id="navbarDropdown" data-bs-toggle="dropdown" aria-expanded="false">
            More <i data-feather="chevron-down"></i>
          </button>
          <ul class="dropdown-menu" aria-labelledby="navbarDropdown"><hr></ul>
</li>
      </ul>
</div>
    <!--
    <form class="d-flex col-md-2 search-form">
      <fieldset disabled>
      <input class="form-control me-2 searchbox" type="search" placeholder="" aria-label="">
        <button class="btn btn-outline-success tablet-search-button"  type="submit">
          <i class="search-icon" data-feather="search" role="img" aria-label="Search the All In One page"></i>
        </button>
      </fieldset>
    </form>
    -->
    <a class="btn btn-primary" href="../aio.html" role="button" aria-label="Search the All In One page">Search the All In One page</a>
  </div>
<!--/div.container-fluid -->
</nav><div class="col-md-12 mobile-title">
  Introduction to Geospatial Raster and Vector Data with Python
</div>

<aside class="col-md-12 lesson-progress"><div style="width: %" class="percentage">
    %
  </div>
  <div class="progress incubator">
    <div class="progress-bar incubator" role="progressbar" style="width: %" aria-valuenow="" aria-label="Lesson Progress" aria-valuemin="0" aria-valuemax="100">
    </div>
  </div>
</aside><div class="container">
      <div class="row">
        <!-- START: inst/pkgdown/templates/navbar.html -->
<div id="sidebar-col" class="col-lg-4">
  <div id="sidebar" class="sidebar">
      <nav aria-labelledby="flush-headingEleven"><button role="button" aria-label="close menu" alt="close menu" aria-expanded="true" aria-controls="sidebar" class="collapse-toggle" data-collapse="Collapse " data-episodes="Episodes ">
          <i class="search-icon" data-feather="x" role="img"></i>
        </button>
        <div class="sidebar-inner">
          <div class="row mobile-row">
            <div class="col">
              <div class="sidenav-view-selector">
                <div class="accordion accordion-flush" id="accordionFlush9">
                  <div class="accordion-item">
                    <h2 class="accordion-header" id="flush-headingNine">
                      <button class="accordion-button collapsed" id="instructor" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseNine" aria-expanded="false" aria-controls="flush-collapseNine">
                        <i id="eye" aria-hidden="true" class="icon" data-feather="eye"></i> Instructor View
                      </button>
                    </h2>
                    <div id="flush-collapseNine" class="accordion-collapse collapse" aria-labelledby="flush-headingNine" data-bs-parent="#accordionFlush2">
                      <div class="accordion-body">
                        <a href="../aio.html">Learner View</a>
                      </div>
                    </div>
                  </div>
<!--/div.accordion-item-->
                </div>
<!--/div.accordion-flush-->
              </div>
<!--div.sidenav-view-selector -->
            </div>
<!--/div.col -->
      
            <hr>
</div>
<!--/div.mobile-row -->

          <div class="accordion accordion-flush" id="accordionFlush11">
            <div class="accordion-item">

              <button id="chapters" class="accordion-button show" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseEleven" aria-expanded="false" aria-controls="flush-collapseEleven">
                <h2 class="accordion-header chapters" id="flush-headingEleven">
                  EPISODES
                </h2>
              </button>
              <div id="flush-collapseEleven" class="accordion-collapse show collapse" aria-labelledby="flush-headingEleven" data-bs-parent="#accordionFlush11">

                <div class="accordion-body">
                  <div class="accordion accordion-flush" id="accordionFlush1">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading1">
        <a href="index.html">Summary and Schedule</a>
    </div>
<!--/div.accordion-header-->
        
  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush2">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading2">
        <a href="01-intro-raster-data.html">1. Introduction to Raster Data</a>
    </div>
<!--/div.accordion-header-->
        
  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush3">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading3">
        <a href="02-intro-vector-data.html">2. Introduction to Vector Data</a>
    </div>
<!--/div.accordion-header-->
        
  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush4">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading4">
        <a href="03-crs.html">3. Coordinate Reference Systems</a>
    </div>
<!--/div.accordion-header-->
        
  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush5">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading5">
        <a href="04-geo-landscape.html">4. The Geospatial Landscape</a>
    </div>
<!--/div.accordion-header-->
        
  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush6">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading6">
        <a href="05-access-data.html">5. Access satellite imagery using Python</a>
    </div>
<!--/div.accordion-header-->
        
  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush7">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading7">
        <a href="06-raster-intro.html">6. Read and visualize raster data</a>
    </div>
<!--/div.accordion-header-->
        
  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush8">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading8">
        <a href="07-vector-data-in-python.html">7. Vector data in Python</a>
    </div>
<!--/div.accordion-header-->
        
  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush9">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading9">
        <a href="08-crop-raster-data.html">8. Crop raster data with rioxarray and geopandas</a>
    </div>
<!--/div.accordion-header-->
        
  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush10">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading10">
        <a href="09-raster-calculations.html">9. Raster Calculations in Python</a>
    </div>
<!--/div.accordion-header-->
        
  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush11">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading11">
        <a href="10-zonal-statistics.html">10. Calculating Zonal Statistics on Rasters</a>
    </div>
<!--/div.accordion-header-->
        
  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

<div class="accordion accordion-flush" id="accordionFlush12">
  <div class="accordion-item">
    <div class="accordion-header" id="flush-heading12">
        <a href="11-parallel-raster-computations.html">11. Parallel raster computations using Dask</a>
    </div>
<!--/div.accordion-header-->
        
  </div>
<!--/div.accordion-item-->
</div>
<!--/div.accordion-flush-->

                </div>
              </div>
            </div>

            <hr class="half-width">
<div class="accordion accordion-flush resources" id="accordionFlush12">
              <div class="accordion-item">
                <h2 class="accordion-header" id="flush-headingTwelve">
                  <button class="accordion-button collapsed" id="resources" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapseTwelve" aria-expanded="false" aria-controls="flush-collapseTwelve">
                    RESOURCES
                  </button>
                </h2>
                <div id="flush-collapseTwelve" class="accordion-collapse collapse" aria-labelledby="flush-headingTwelve" data-bs-parent="#accordionFlush12">
                  <div class="accordion-body">
                    <ul>
<li>
                        <a href="../instructor/key-points.html">Key Points</a>
                      </li>
                      <li>
                        <a href="../instructor/instructor-notes.html">Instructor Notes</a>
                      </li>
                      <li>
                        <a href="../instructor/images.html">Extract All Images</a>
                      </li>
                      <hr>
</ul>
</div>
                </div>
              </div>
            </div>
            <hr class="half-width resources">
<a href="../instructor/aio.html">See all in one page</a>
            

            <hr class="d-none d-sm-block d-md-none">
<div class="d-grid gap-1">
            
            </div>
          </div>
<!-- /div.accordion -->
        </div>
<!-- /div.sidebar-inner -->
      </nav>
</div>
<!-- /div.sidebar -->
  </div>
<!-- /div.sidebar-col -->
<!-- END:   inst/pkgdown/templates/navbar.html-->

        <!-- START: inst/pkgdown/templates/content-extra.html -->
  <div class="col-xl-8 col-lg-12 primary-content">
    <main id="main-content" class="main-content"><div class="container lesson-content">
        
        
<section id="aio-01-intro-raster-data"><p>Content from <a href="01-intro-raster-data.html">Introduction to Raster Data</a></p>
<hr>
<p>Last updated on 2023-08-14 |
        
        <a href="https://github.com/carpentries-incubator/geospatial-python/edit/main/episodes/01-intro-raster-data.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<p>Estimated time: <i aria-hidden="true" data-feather="clock"></i> 20 minutes</p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>What format should I use to represent my data?</li>
<li>What are the main data types used for representing geospatial
data?</li>
<li>What are the main attributes of raster data?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Describe the difference between raster and vector data.</li>
<li>Describe the strengths and weaknesses of storing data in raster
format.</li>
<li>Distinguish between continuous and categorical raster data and
identify types of datasets that would be stored in each format.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<section id="introduction"><h2 class="section-heading">Introduction<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h2>
<hr class="half-width">
<p>This episode introduces the two primary types of geospatial data:
rasters and vectors. After briefly introducing these data types, this
episode focuses on raster data, describing some major features and types
of raster data.</p>
</section><section id="data-structures-raster-and-vector"><h2 class="section-heading">Data Structures: Raster and Vector<a class="anchor" aria-label="anchor" href="#data-structures-raster-and-vector"></a>
</h2>
<hr class="half-width">
<p>The two primary types of geospatial data are raster and vector data.
Raster data is stored as a grid of values which are rendered on a map as
pixels. Each pixel value represents an area on the Earth’s surface.
Vector data structures represent specific features on the Earth’s
surface, and assign attributes to those features. Vector data structures
will be discussed in more detail in <a href="02-intro-vector-data.html">the next episode</a>.</p>
<p>This workshop will focus on how to work with both raster and vector
data sets, therefore it is essential that we understand the basic
structures of these types of data and the types of data that they can be
used to represent.</p>
<div class="section level3">
<h3 id="about-raster-data">About Raster Data<a class="anchor" aria-label="anchor" href="#about-raster-data"></a>
</h3>
<p>Raster data is any pixelated (or gridded) data where each pixel is
associated with a specific geographic location. The value of a pixel can
be continuous (e.g. elevation) or categorical (e.g. land use). If this
sounds familiar, it is because this data structure is very common: it’s
how we represent any digital image. A geospatial raster is only
different from a digital photo in that it is accompanied by spatial
information that connects the data to a particular location. This
includes the raster’s extent and cell size, the number of rows and
columns, and its coordinate reference system (or CRS).</p>
<figure><img src="../fig/E01/raster_concept.png" alt="raster concept" class="figure mx-auto d-block"><div class="figcaption">Raster Concept (Source: National Ecological
Observatory Network (NEON))</div>
</figure><p>Some examples of continuous rasters include:</p>
<ol style="list-style-type: decimal">
<li>Precipitation maps.</li>
<li>Maps of tree height derived from LiDAR data.</li>
<li>Elevation values for a region.</li>
</ol>
<p>A map of elevation for Harvard Forest derived from the <a href="https://www.neonscience.org/data-collection/airborne-remote-sensing" class="external-link">NEON
AOP LiDAR sensor</a> is below. Elevation is represented as a continuous
numeric variable in this map. The legend shows the continuous range of
values in the data from around 300 to 420 meters.</p>
<figure><img src="../fig/E01/continuous-elevation-HARV-plot-01.png" alt="elevation Harvard forest" class="figure mx-auto d-block"><div class="figcaption">Continuous Elevation Map: HARV Field Site</div>
</figure><p>Some rasters contain categorical data where each pixel represents a
discrete class such as a landcover type (e.g., “forest” or “grassland”)
rather than a continuous value such as elevation or temperature. Some
examples of classified maps include:</p>
<ol style="list-style-type: decimal">
<li>Landcover / land-use maps.</li>
<li>Tree height maps classified as short, medium, and tall trees.</li>
<li>Elevation maps classified as low, medium, and high elevation.</li>
</ol>
<figure><img src="../fig/E01/USA_landcover_classification.png" alt="USA landcover classification" class="figure mx-auto d-block"><div class="figcaption">USA landcover classification</div>
</figure><p>The map above shows the contiguous United States with landcover as
categorical data. Each color is a different landcover category. (Source:
Homer, C.G., et al., 2015, Completion of the 2011 National Land Cover
Database for the conterminous United States-Representing a decade of
land cover change information. Photogrammetric Engineering and Remote
Sensing, v. 81, no. 5, p. 345-354)</p>
<div id="advantages-and-disadvantages" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="advantages-and-disadvantages" class="callout-inner">
<h3 class="callout-title">Advantages and Disadvantages<a class="anchor" aria-label="anchor" href="#advantages-and-disadvantages"></a>
</h3>
<div class="callout-content">
<p>With your neighbor, brainstorm potential advantages and disadvantages
of storing data in raster format. Add your ideas to the Etherpad. The
Instructor will discuss and add any points that weren’t brought up in
the small group discussions.</p>
</div>
</div>
</div>
<div id="accordionSolution1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution1" aria-expanded="false" aria-controls="collapseSolution1">
  <h4 class="accordion-header" id="headingSolution1">Show me the solution</h4>
</button>
<div id="collapseSolution1" class="accordion-collapse collapse" data-bs-parent="#accordionSolution1" aria-labelledby="headingSolution1">
<div class="accordion-body">
<p>Raster data has some important advantages:</p>
<ul>
<li>representation of continuous surfaces</li>
<li>potentially very high levels of detail</li>
<li>data is ‘unweighted’ across its extent - the geometry doesn’t
implicitly highlight features</li>
<li>cell-by-cell calculations can be very fast and efficient</li>
</ul>
<p>The downsides of raster data are:</p>
<ul>
<li>very large file sizes as cell size gets smaller</li>
<li>currently popular formats don’t embed metadata well (more on this
later!)</li>
<li>can be difficult to represent complex information</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="section level3">
<h3 id="important-attributes-of-raster-data">Important Attributes of Raster Data<a class="anchor" aria-label="anchor" href="#important-attributes-of-raster-data"></a>
</h3>
<div class="section level4">
<h4 id="extent">Extent<a class="anchor" aria-label="anchor" href="#extent"></a>
</h4>
<p>The spatial extent is the geographic area that the raster data
covers. The spatial extent of an object represents the geographic edge
or location that is the furthest north, south, east and west. In other
words, extent represents the overall geographic coverage of the spatial
object.</p>
<figure><img src="../fig/E01/spatial_extent.png" alt="spatial extent objects" class="figure mx-auto d-block"><div class="figcaption">Spatial extent image (Image Source: National
Ecological Observatory Network (NEON))</div>
</figure><div id="extent-challenge" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="extent-challenge" class="callout-inner">
<h3 class="callout-title">Extent Challenge<a class="anchor" aria-label="anchor" href="#extent-challenge"></a>
</h3>
<div class="callout-content">
<p>In the image above, the dashed boxes around each set of objects seems
to imply that the three objects have the same extent. Is this accurate?
If not, which object(s) have a different extent?</p>
</div>
</div>
</div>
<div id="accordionSolution2" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution2" aria-expanded="false" aria-controls="collapseSolution2">
  <h4 class="accordion-header" id="headingSolution2">Show me the solution</h4>
</button>
<div id="collapseSolution2" class="accordion-collapse collapse" data-bs-parent="#accordionSolution2" aria-labelledby="headingSolution2">
<div class="accordion-body">
<p>The lines and polygon objects have the same extent. The extent for
the points object is smaller in the vertical direction than the other
two because there are no points on the line at y = 8.</p>
</div>
</div>
</div>
</div>
</div>
<div class="section level4">
<h4 id="resolution">Resolution<a class="anchor" aria-label="anchor" href="#resolution"></a>
</h4>
<p>A resolution of a raster represents the area on the ground that each
pixel of the raster covers. The image below illustrates the effect of
changes in resolution.</p>
<figure><img src="../fig/E01/raster_resolution.png" alt="resolution image" class="figure mx-auto d-block"><div class="figcaption">Resolution image (Source: National Ecological
Observatory Network (NEON))</div>
</figure>
</div>
</div>
<div class="section level3">
<h3 id="raster-data-format-for-this-workshop">Raster Data Format for this Workshop<a class="anchor" aria-label="anchor" href="#raster-data-format-for-this-workshop"></a>
</h3>
<p>Raster data can come in many different formats. For this workshop, we
will use the GeoTIFF format which has the extension <code>.tif</code>. A
<code>.tif</code> file stores metadata or attributes about the file as
embedded <code>tif tags</code>. For instance, your camera might store a
tag that describes the make and model of the camera or the date the
photo was taken when it saves a <code>.tif</code>. A GeoTIFF is a
standard <code>.tif</code> image format with additional spatial
(georeferencing) information embedded in the file as tags. These tags
should include the following raster metadata:</p>
<ol style="list-style-type: decimal">
<li>Extent</li>
<li>Resolution</li>
<li>Coordinate Reference System (CRS) - we will introduce this concept
in <a href="03-crs.html">a later episode</a>
</li>
<li>Values that represent missing data (<code>NoDataValue</code>) - we
will introduce this concept in <a href="06-raster-intro.html">a later
episode</a>.</li>
</ol>
<p>We will discuss these attributes in more detail in <a href="06-raster-intro.html">a later episode</a>. In that episode, we
will also learn how to use Python to extract raster attributes from a
GeoTIFF file.</p>
<div id="more-resources-on-the-.tif-format" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div id="more-resources-on-the-.tif-format" class="callout-inner">
<h3 class="callout-title">More Resources on the<code>.tif</code>format<a class="anchor" aria-label="anchor" href="#more-resources-on-the-.tif-format"></a>
</h3>
<div class="callout-content">
<ul>
<li><a href="https://en.wikipedia.org/wiki/GeoTIFF" class="external-link">GeoTIFF on
Wikipedia</a></li>
<li><a href="https://trac.osgeo.org/geotiff/" class="external-link">OSGEO TIFF
documentation</a></li>
</ul>
</div>
</div>
</div>
</div>
<div class="section level3">
<h3 id="multi-band-raster-data">Multi-band Raster Data<a class="anchor" aria-label="anchor" href="#multi-band-raster-data"></a>
</h3>
<p>A raster can contain one or more bands. One type of multi-band raster
dataset that is familiar to many of us is a color image. A basic color
image consists of three bands: red, green, and blue. Each band
represents light reflected from the red, green or blue portions of the
electromagnetic spectrum. The pixel brightness for each band, when
composited creates the colors that we see in an image.</p>
<figure><img src="../fig/E01/RGBSTack_1.jpg" alt="multi-band raster" class="figure mx-auto d-block"><div class="figcaption">RGB multi-band raster image (Source: National
Ecological Observatory Network (NEON).)</div>
</figure><p>We can plot each band of a multi-band image individually.</p>
<p>Or we can composite all three bands together to make a color
image.</p>
<p>In a multi-band dataset, the rasters will always have the same
extent, resolution, and CRS.</p>
<div id="other-types-of-multi-band-raster-data" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div id="other-types-of-multi-band-raster-data" class="callout-inner">
<h3 class="callout-title">Other Types of Multi-band Raster Data<a class="anchor" aria-label="anchor" href="#other-types-of-multi-band-raster-data"></a>
</h3>
<div class="callout-content">
<p>Multi-band raster data might also contain: 1. <strong>Time
series:</strong> the same variable, over the same area, over time. 2.
<strong>Multi or hyperspectral imagery:</strong> image rasters that have
4 or more (multi-spectral) or more than 10-15 (hyperspectral) bands. We
won’t be working with this type of data in this workshop, but you can
check out the NEON Data Skills <a href="https://www.neonscience.org/hsi-hdf5-r" class="external-link">Imaging Spectroscopy HDF5
in R</a> tutorial if you’re interested in working with hyperspectral
data cubes.</p>
</div>
</div>
</div>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Key Points<a class="anchor" aria-label="anchor" href="#keypoints1"></a>
</h3>
<div class="callout-content">
<ul>
<li>Raster data is pixelated data where each pixel is associated with a
specific location.</li>
<li>Raster data always has an extent and a resolution.</li>
<li>The extent is the geographical area covered by a raster.</li>
<li>The resolution is the area covered by each pixel of a raster.</li>
</ul>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</div>
</section></section><section id="aio-02-intro-vector-data"><p>Content from <a href="02-intro-vector-data.html">Introduction to Vector Data</a></p>
<hr>
<p>Last updated on 2023-08-14 |
        
        <a href="https://github.com/carpentries-incubator/geospatial-python/edit/main/episodes/02-intro-vector-data.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<p>Estimated time: <i aria-hidden="true" data-feather="clock"></i> 15 minutes</p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>What are the main attributes of vector data?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Describe the strengths and weaknesses of storing data in vector
format.</li>
<li>Describe the three types of vectors and identify types of data that
would be stored in each.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<section id="about-vector-data"><h2 class="section-heading">About Vector Data<a class="anchor" aria-label="anchor" href="#about-vector-data"></a>
</h2>
<hr class="half-width">
<p>Vector data structures represent specific features on the Earth’s
surface, and assign attributes to those features. Vectors are composed
of discrete geometric locations (x, y values) known as vertices that
define the shape of the spatial object. The organization of the vertices
determines the type of vector that we are working with: point, line or
polygon.</p>
<figure><img src="../fig/E02/pnt_line_poly.png" alt="vector data types" class="figure mx-auto d-block"><div class="figcaption">Types of vector objects (Image Source: National
Ecological Observatory Network (NEON))</div>
</figure><ul>
<li><p><strong>Points:</strong> Each point is defined by a single x, y
coordinate. There can be many points in a vector point file. Examples of
point data include: sampling locations, the location of individual
trees, or the location of survey plots.</p></li>
<li><p><strong>Lines:</strong> Lines are composed of many (at least 2)
points that are connected. For instance, a road or a stream may be
represented by a line. This line is composed of a series of segments,
each “bend” in the road or stream represents a vertex that has a defined
x, y location.</p></li>
<li><p><strong>Polygons:</strong> A polygon consists of 3 or more
vertices that are connected and closed. The outlines of survey plot
boundaries, lakes, oceans, and states or countries are often represented
by polygons.</p></li>
</ul>
<div id="data-tip" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div id="data-tip" class="callout-inner">
<h3 class="callout-title">Data Tip<a class="anchor" aria-label="anchor" href="#data-tip"></a>
</h3>
<div class="callout-content">
<p>Sometimes, boundary layers such as states and countries, are stored
as lines rather than polygons. However, these boundaries, when
represented as a line, will not create a closed object with a defined
area that can be filled.</p>
</div>
</div>
</div>
<div id="identify-vector-types" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="identify-vector-types" class="callout-inner">
<h3 class="callout-title">Identify Vector Types<a class="anchor" aria-label="anchor" href="#identify-vector-types"></a>
</h3>
<div class="callout-content">
<p>The plot below includes examples of two of the three types of vector
objects. Use the definitions above to identify which features are
represented by which vector type.</p>
<figure><img src="../fig/E02/vector_types_examples.png" alt="vector type examples" class="figure mx-auto d-block"><div class="figcaption">Vector Type Examples</div>
</figure>
</div>
</div>
</div>
<div id="accordionSolution1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution1" aria-expanded="false" aria-controls="collapseSolution1">
  <h4 class="accordion-header" id="headingSolution1">Show me the solution</h4>
</button>
<div id="collapseSolution1" class="accordion-collapse collapse" data-bs-parent="#accordionSolution1" aria-labelledby="headingSolution1">
<div class="accordion-body">
<p>State boundaries are polygons. The Fisher Tower location is a point.
There are no line features shown.</p>
</div>
</div>
</div>
</div>
<p>Vector data has some important advantages:</p>
<ul>
<li>The geometry itself contains information about what the dataset
creator thought was important</li>
<li>The geometry structures hold information in themselves - why choose
point over polygon, for instance?</li>
<li>Each geometry feature can carry multiple attributes instead of just
one, e.g. a database of cities can have attributes for name, country,
population, etc</li>
<li>Data storage can be very efficient compared to rasters</li>
</ul>
<p>The downsides of vector data include:</p>
<ul>
<li>Potential loss of detail compared to raster</li>
<li>Potential bias in datasets - what didn’t get recorded?</li>
<li>Calculations involving multiple vector layers need to do math on the
geometry as well as the attributes, so can be slow compared to raster
math.</li>
</ul>
<p>Vector datasets are in use in many industries besides geospatial
fields. For instance, computer graphics are largely vector-based,
although the data structures in use tend to join points using arcs and
complex curves rather than straight lines. Computer-aided design (CAD)
is also vector- based. The difference is that geospatial datasets are
accompanied by information tying their features to real-world
locations.</p>
</section><section id="vector-data-format-for-this-workshop"><h2 class="section-heading">Vector Data Format for this Workshop<a class="anchor" aria-label="anchor" href="#vector-data-format-for-this-workshop"></a>
</h2>
<hr class="half-width">
<p>Like raster data, vector data can also come in many different
formats. For this workshop, we will use the Shapefile format. A
Shapefile format consists of multiple files in the same directory, of
which <code>.shp</code>, <code>.shx</code>, and <code>.dbf</code> files
are mandatory. Other non-mandatory but very important files are
<code>.prj</code> and <code>shp.xml</code> files.</p>
<ul>
<li>The <code>.shp</code> file stores the feature geometry itself</li>
<li>
<code>.shx</code> is a positional index of the feature geometry to
allow quickly searching forwards and backwards the geographic
coordinates of each vertex in the vector</li>
<li>
<code>.dbf</code> contains the tabular attributes for each
shape.</li>
<li>
<code>.prj</code> file indicates the Coordinate reference system
(CRS)</li>
<li>
<code>.shp.xml</code> contains the Shapefile metadata.</li>
</ul>
<p>Together, the Shapefile includes the following information:</p>
<ul>
<li>
<strong>Extent</strong> - the spatial extent of the shapefile
(i.e. geographic area that the shapefile covers). The spatial extent for
a shapefile represents the combined extent for all spatial objects in
the shapefile.</li>
<li>
<strong>Object type</strong> - whether the shapefile includes
points, lines, or polygons.</li>
<li><strong>Coordinate reference system (CRS)</strong></li>
<li>
<strong>Other attributes</strong> - for example, a line shapefile
that contains the locations of streams, might contain the name of each
stream.</li>
</ul>
<p>Because the structure of points, lines, and polygons are different,
each individual shapefile can only contain one vector type (all points,
all lines or all polygons). You will not find a mixture of point, line
and polygon objects in a single shapefile.</p>
<div id="more-resources-on-shapefiles" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div id="more-resources-on-shapefiles" class="callout-inner">
<h3 class="callout-title">More Resources on Shapefiles<a class="anchor" aria-label="anchor" href="#more-resources-on-shapefiles"></a>
</h3>
<div class="callout-content">
<p>More about shapefiles can be found on <a href="https://en.wikipedia.org/wiki/Shapefile" class="external-link">Wikipedia.</a> Shapefiles
are often publicly available from government services, such as <a href="https://www.census.gov/geographies/mapping-files/time-series/geo/carto-boundary-file.html" class="external-link">this
page from the US Census Bureau</a> or <a href="https://data.gov.au/data/dataset?res_format=SHP" class="external-link">this one from
Australia’s Data.gov.au website</a>.</p>
</div>
</div>
</div>
<div id="why-not-both" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div id="why-not-both" class="callout-inner">
<h3 class="callout-title">Why not both?<a class="anchor" aria-label="anchor" href="#why-not-both"></a>
</h3>
<div class="callout-content">
<p>Very few formats can contain both raster and vector data - in fact,
most are even more restrictive than that. Vector datasets are usually
locked to one geometry type, e.g. points only. Raster datasets can
usually only encode one data type, for example you can’t have a
multiband GeoTIFF where one layer is integer data and another is
floating-point. There are sound reasons for this - format standards are
easier to define and maintain, and so is metadata. The effects of
particular data manipulations are more predictable if you are confident
that all of your input data has the same characteristics.</p>
</div>
</div>
</div>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Key Points<a class="anchor" aria-label="anchor" href="#keypoints1"></a>
</h3>
<div class="callout-content">
<ul>
<li>Vector data structures represent specific features on the Earth’s
surface along with attributes of those features.</li>
<li>Vector objects are either points, lines, or polygons.</li>
</ul>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</section></section><section id="aio-03-crs"><p>Content from <a href="03-crs.html">Coordinate Reference Systems</a></p>
<hr>
<p>Last updated on 2023-08-14 |
        
        <a href="https://github.com/carpentries-incubator/geospatial-python/edit/main/episodes/03-crs.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<p>Estimated time: <i aria-hidden="true" data-feather="clock"></i> 25 minutes</p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>What is a coordinate reference system and how do I interpret
one?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Name some common schemes for describing coordinate reference
systems.</li>
<li>Interpret a PROJ4 coordinate reference system description.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<section id="coordinate-reference-systems"><h2 class="section-heading">Coordinate Reference Systems<a class="anchor" aria-label="anchor" href="#coordinate-reference-systems"></a>
</h2>
<hr class="half-width">
<p>A data structure cannot be considered geospatial unless it is
accompanied by coordinate reference system (CRS) information, in a
format that geospatial applications can use to display and manipulate
the data correctly. CRS information connects data to the Earth’s surface
using a mathematical model.</p>
<div id="crs-vs-srs" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div id="crs-vs-srs" class="callout-inner">
<h3 class="callout-title">CRS vs SRS<a class="anchor" aria-label="anchor" href="#crs-vs-srs"></a>
</h3>
<div class="callout-content">
<p>CRS (coordinate reference system) and SRS (spatial reference system)
are synonyms and are commonly interchanged. We will use only CRS
throughout this workshop.</p>
</div>
</div>
</div>
<p>The CRS associated with a dataset tells your mapping software (for
example Python) where the raster is located in geographic space. It also
tells the mapping software what method should be used to flatten or
project the raster in geographic space.</p>
<figure><img src="https://media.opennews.org/cache/06/37/0637aa2541b31f526ad44f7cb2db7b6c.jpg" alt="US difference projections" class="figure mx-auto d-block"><div class="figcaption">Maps of the United States in different
projections (Source: opennews.org)</div>
</figure><p>The above image shows maps of the United States in different
projections. Notice the differences in shape associated with each
projection. These differences are a direct result of the calculations
used to flatten the data onto a 2-dimensional map.</p>
<p>There are lots of great resources that describe coordinate reference
systems and projections in greater detail. For the purposes of this
workshop, what is important to understand is that data from the same
location but saved in different projections will not line up in any GIS
or other program. Thus, it’s important when working with spatial data to
identify the coordinate reference system applied to the data and retain
it throughout data processing and analysis.</p>
</section><section id="components-of-a-crs"><h2 class="section-heading">Components of a CRS<a class="anchor" aria-label="anchor" href="#components-of-a-crs"></a>
</h2>
<hr class="half-width">
<p>CRS information has three components:</p>
<ul>
<li><p><strong>Datum:</strong> A model of the shape of the earth. It has
angular units (i.e. degrees) and defines the starting point (i.e. where
is [0,0]?) so the angles reference a meaningful spot on the earth.
Common global datums are WGS84 and NAD83. Datums can also be local - fit
to a particular area of the globe, but ill-fitting outside the area of
intended use. In this workshop, we will use the <a href="https://www.linz.govt.nz/data/geodetic-system/datums-projections-and-heights/geodetic-datums/world-geodetic-system-1984-wgs84" class="external-link">WGS84
datum</a>.</p></li>
<li><p><strong>Projection:</strong> A mathematical transformation of the
angular measurements on a round earth to a flat surface (i.e. paper or a
computer screen). The units associated with a given projection are
usually linear (feet, meters, etc.). In this workshop, we will see data
in two different projections.</p></li>
<li><p><strong>Additional Parameters:</strong> Additional parameters are
often necessary to create the full coordinate reference system. One
common additional parameter is a definition of the center of the map.
The number of required additional parameters depends on what is needed
by each specific projection.</p></li>
</ul>
<div id="orange-peel-analogy" class="callout discussion">
<div class="callout-square">
<i class="callout-icon" data-feather="message-circle"></i>
</div>
<div id="orange-peel-analogy" class="callout-inner">
<h3 class="callout-title">Orange Peel Analogy<a class="anchor" aria-label="anchor" href="#orange-peel-analogy"></a>
</h3>
<div class="callout-content">
<p>A common analogy employed to teach projections is the orange peel
analogy. If you imagine that the Earth is an orange, how you peel it and
then flatten the peel is similar to how projections get made.</p>
<ul>
<li>A datum is the choice of fruit to use. Is the Earth an orange, a
lemon, a lime, a grapefruit?</li>
</ul>
<figure><img src="../fig/E03/citrus.jpg" alt="datum fruit example" class="figure mx-auto d-block"><div class="figcaption">Datum Fruit Example (<a href="https://github.com/MicheleTobias/R-Projections-Workshop" class="external-link">Image
source</a>)</div>
</figure><p>A projection is how you peel your orange and then flatten the
peel.</p>
<figure><img src="../fig/E03/orange-peel-earth.jpg" alt="projection citrus peel" class="figure mx-auto d-block"><div class="figcaption">Projection Citrus Peel Example (Image from Prof
Drika Geografia, Projeções Cartográficas)</div>
</figure><ul>
<li>An additional parameter could include a definition of the location
of the stem of the fruit. What other parameters could be included in
this analogy?</li>
</ul>
</div>
</div>
</div>
</section><section id="which-projection-should-i-use"><h2 class="section-heading">Which projection should I use?<a class="anchor" aria-label="anchor" href="#which-projection-should-i-use"></a>
</h2>
<hr class="half-width">
<p>To decide if a projection is right for your data, answer these
questions:</p>
<ul>
<li>What is the area of minimal distortion?</li>
<li>What aspect of the data does it preserve?</li>
</ul>
<p><a href="https://foote.geography.uconn.edu/gcraft/notes/mapproj/mapproj_f.html" class="external-link">Peter
Dana from the University of Colorado at Boulder</a> and the <a href="https://kartoweb.itc.nl/geometrics/Map%20projections/mappro.html" class="external-link">Department
of Geo-Information Processing</a> have a good discussion of these
aspects of projections. Online tools like <a href="https://projectionwizard.org/" class="external-link">Projection Wizard</a> can also help
you discover projections that might be a good fit for your data.</p>
<div id="data-tip" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div id="data-tip" class="callout-inner">
<h3 class="callout-title">Data Tip<a class="anchor" aria-label="anchor" href="#data-tip"></a>
</h3>
<div class="callout-content">
<p>Take the time to identify a projection that is suited for your
project. You don’t have to stick to the ones that are popular.</p>
</div>
</div>
</div>
</section><section id="describing-coordinate-reference-systems"><h2 class="section-heading">Describing Coordinate Reference Systems<a class="anchor" aria-label="anchor" href="#describing-coordinate-reference-systems"></a>
</h2>
<hr class="half-width">
<p>There are several common systems in use for storing and transmitting
CRS information, as well as translating among different CRSs. These
systems generally comply with ISO 19111. Common systems for describing
CRSs include EPSG, OGC WKT, and PROJ strings.</p>
<div class="section level3">
<h3 id="epsg">EPSG<a class="anchor" aria-label="anchor" href="#epsg"></a>
</h3>
<p>The <a href="https://epsg.org/home.html" class="external-link">EPSG system</a> is a
database of CRS information maintained by the International Association
of Oil and Gas Producers. The dataset contains both CRS definitions and
information on how to safely convert data from one CRS to another. Using
EPSG is easy as every CRS has an integer identifier, e.g. WGS84 is
EPSG:4326. The downside is that you can only use the CRSs defined by
EPSG and cannot customise them (some datasets do not have EPSG codes).
<a href="https://epsg.io/" class="external-link">epsg.io</a> is an excellent website for
finding suitable projections by location or for finding information
about a particular EPSG code.</p>
</div>
<div class="section level3">
<h3 id="well-known-text">Well-Known Text<a class="anchor" aria-label="anchor" href="#well-known-text"></a>
</h3>
<p>The Open Geospatial Consortium WKT standard is used by a number of
important geospatial apps and software libraries. WKT is a nested list
of geodetic parameters. The structure of the information is <a href="https://www.opengeospatial.org/standards/wkt-crs" class="external-link">defined on their
website</a>. WKT is valuable in that the CRS information is more
transparent than in EPSG, but can be more difficult to read and compare
than PROJ since it is meant to necessarily represent more complex CRS
information. Additionally, the WKT standard is implemented
inconsistently across various software platforms, and the spec itself
has <a href="https://gdal.org/tutorials/wktproblems.html" class="external-link">some known
issues</a>.</p>
</div>
<div class="section level3">
<h3 id="proj">PROJ<a class="anchor" aria-label="anchor" href="#proj"></a>
</h3>
<p><a href="https://proj4.org/" class="external-link">PROJ</a> is an open-source library for
storing, representing and transforming CRS information. PROJ strings
continue to be used, but the format <a href="https://proj.org/faq.html#what-is-the-best-format-for-describing-coordinate-reference-systems" class="external-link">is
deprecated by the PROJ C maintainers</a> due to inaccuracies when
converting to the WKT format. The data and python libraries we will be
working with in this workshop use different underlying representations
of CRSs under the hood for reprojecting. CRS information can still be
represented with EPSG, WKT, or PROJ strings without consequence, but
<strong>it is best to only use PROJ strings as a format for viewing CRS
information, not for reprojecting data</strong>.</p>
<p>PROJ represents CRS information as a text string of key-value pairs,
which makes it easy to read and interpret.</p>
<p>A PROJ4 string includes the following information:</p>
<ul>
<li>
<strong>proj:</strong> the projection of the data</li>
<li>
<strong>zone:</strong> the zone of the data (this is specific to the
UTM projection)</li>
<li>
<strong>datum:</strong> the datum used</li>
<li>
<strong>units:</strong> the units for the coordinates of the
data</li>
<li>
<strong>ellps:</strong> the ellipsoid (how the earth’s roundness is
calculated) for the data</li>
</ul>
<p>Note that the zone is unique to the UTM projection. Not all CRSs will
have a zone.</p>
<figure><img src="../fig/E03/Utm-zones-USA.svg" alt="UTM zones across the CONUS" class="figure mx-auto d-block"><div class="figcaption">The UTM zones across the continental United
States (Chrismurf at English Wikipedia, via <a href="https://en.wikipedia.org/wiki/Universal_Transverse_Mercator_coordinate_system#/media/File:Utm-zones-USA.svg" class="external-link">Wikimedia
Commons</a> (CC-BY))</div>
</figure><div id="reading-a-proj4-string" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="reading-a-proj4-string" class="callout-inner">
<h3 class="callout-title">Reading a PROJ4 String<a class="anchor" aria-label="anchor" href="#reading-a-proj4-string"></a>
</h3>
<div class="callout-content">
<p>Here is a PROJ4 string for one of the datasets we will use in this
workshop:</p>
<p><code>+proj=utm +zone=18 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0</code></p>
<ul>
<li>What projection, zone, datum, and ellipsoid are used for this
data?</li>
<li>What are the units of the data?</li>
<li>Using the map above, what part of the United States was this data
collected from?</li>
</ul>
</div>
</div>
</div>
<div id="accordionSolution1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution1" aria-expanded="false" aria-controls="collapseSolution1">
  <h4 class="accordion-header" id="headingSolution1">Show me the solution</h4>
</button>
<div id="collapseSolution1" class="accordion-collapse collapse" data-bs-parent="#accordionSolution1" aria-labelledby="headingSolution1">
<div class="accordion-body">
<ul>
<li>Projection is UTM, zone 18, datum is WGS84, ellipsoid is WGS84.</li>
<li>The data is in meters.</li>
<li>The data comes from the eastern US seaboard.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
</section><section id="format-interoperability"><h2 class="section-heading">Format interoperability<a class="anchor" aria-label="anchor" href="#format-interoperability"></a>
</h2>
<hr class="half-width">
<p>Many existing file formats were invented by GIS software developers,
often in a closed-source environment. This led to the large number of
formats on offer today, and considerable problems transferring data
between software environments. The <a href="https://www.gdal.org/" class="external-link">Geospatial Data Abstraction Library</a>
(GDAL) is an open-source answer to this issue.</p>
<p>GDAL is a set of software tools that translate between almost any
geospatial format in common use today (and some not so common ones).
GDAL also contains tools for editing and manipulating both raster and
vector files, including reprojecting data to different CRSs. GDAL can be
used as a standalone command-line tool, or built in to other GIS
software. Several open-source GIS programs use GDAL for all file
import/export operations.</p>
</section><section id="metadata"><h2 class="section-heading">Metadata<a class="anchor" aria-label="anchor" href="#metadata"></a>
</h2>
<hr class="half-width">
<p>Spatial data is useless without metadata. Essential metadata includes
the CRS information, but proper spatial metadata encompasses more than
that. History and provenance of a dataset (how it was made), who is in
charge of maintaining it, and appropriate (and inappropriate!) use cases
should also be documented in metadata. This information should accompany
a spatial dataset wherever it goes. In practice this can be difficult,
as many spatial data formats don’t have a built-in place to hold this
kind of information. Metadata often has to be stored in a companion
file, and generated and maintained manually.</p>
<div id="more-resources-on-crs" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div id="more-resources-on-crs" class="callout-inner">
<h3 class="callout-title">More Resources on CRS<a class="anchor" aria-label="anchor" href="#more-resources-on-crs"></a>
</h3>
<div class="callout-content">
<ul>
<li>
<a href="https://spatialreference.org/ref/epsg/" class="external-link">spatialreference.org</a> -
A comprehensive online library of CRS information.</li>
<li><a href="https://docs.qgis.org/2.18/en/docs/gentle_gis_introduction/coordinate_reference_systems.html" class="external-link">QGIS
Documentation - CRS Overview.</a></li>
<li><a href="https://source.opennews.org/en-US/learning/choosing-right-map-projection/" class="external-link">Choosing
the Right Map Projection.</a></li>
<li>
<a href="https://www.youtube.com/embed/KUF_Ckv8HbE" class="external-link">Video</a>
highlighting how map projections can make continents seems
proportionally larger or smaller than they actually are.</li>
</ul>
</div>
</div>
</div>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Key Points<a class="anchor" aria-label="anchor" href="#keypoints1"></a>
</h3>
<div class="callout-content">
<ul>
<li>All geospatial datasets (raster and vector) are associated with a
specific coordinate reference system.</li>
<li>A coordinate reference system includes datum, projection, and
additional parameters specific to the dataset.</li>
</ul>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</section></section><section id="aio-04-geo-landscape"><p>Content from <a href="04-geo-landscape.html">The Geospatial Landscape</a></p>
<hr>
<p>Last updated on 2023-08-14 |
        
        <a href="https://github.com/carpentries-incubator/geospatial-python/edit/main/episodes/04-geo-landscape.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<p>Estimated time: <i aria-hidden="true" data-feather="clock"></i> 10 minutes</p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>What programs and applications are available for working with
geospatial data?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Describe the difference between various approaches to geospatial
computing, and their relative strengths and weaknesses.</li>
<li>Name some commonly used GIS applications.</li>
<li>Name some commonly used Python packages that can access and process
spatial data.</li>
<li>Describe pros and cons for working with geospatial data using a
command-line versus a graphical user interface.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<section id="standalone-software-packages"><h2 class="section-heading">Standalone Software Packages<a class="anchor" aria-label="anchor" href="#standalone-software-packages"></a>
</h2>
<hr class="half-width">
<p>Most traditional GIS work is carried out in standalone applications
that aim to provide end-to-end geospatial solutions. These applications
are available under a wide range of licenses and price points. Some of
the most common are listed below.</p>
<div class="section level3">
<h3 id="open-source-software">Open-source software<a class="anchor" aria-label="anchor" href="#open-source-software"></a>
</h3>
<p>The <a href="https://www.osgeo.org/" class="external-link">Open Source Geospatial
Foundation (OSGEO)</a> supports several actively managed GIS
platforms:</p>
<ul>
<li>
<a href="https://www.qgis.org/en/site/" class="external-link">QGIS</a> is a professional
GIS application that is built on top of and proud to be itself Free and
Open Source Software (FOSS). QGIS is written in Python, has a python
console interface, and has several interfaces written in R including <a href="https://cran.r-project.org/package=RQGIS" class="external-link">RQGIS</a>.</li>
<li>
<a href="https://grass.osgeo.org/" class="external-link">GRASS GIS</a>, commonly referred
to as GRASS (Geographic Resources Analysis Support System), is a
FOSS-GIS software suite used for geospatial data management and
analysis, image processing, graphics and maps production, spatial
modeling, and visualization. GRASS GIS is currently used in academic and
commercial settings around the world, as well as by many governmental
agencies and environmental consulting companies. It is a founding member
of the Open Source Geospatial Foundation (OSGeo). GRASS GIS can be
installed along with and made accessible within QGIS 3.</li>
<li>
<a href="https://www.gdal.org/" class="external-link">GDAL</a> is a multiplatform set of
tools for translating between geospatial data formats. It can also
handle reprojection and a variety of geoprocessing tasks. GDAL is built
in to many applications both FOSS and commercial, including GRASS and
QGIS.</li>
<li>
<a href="https://www.saga-gis.org/en/index.html" class="external-link">SAGA-GIS</a>, or
System for Automated Geoscientific Analyses, is a FOSS-GIS application
developed by a small team of researchers from the Dept. of Physical
Geography, Göttingen, and the Dept. of Physical Geography, Hamburg. SAGA
has been designed for an easy and effective implementation of spatial
algorithms, offers a comprehensive, growing set of geoscientific
methods, provides an easily approachable user interface with many
visualisation options, and runs under Windows and Linux operating
systems. Like GRASS GIS, it can also be installed and made accessible in
QGIS3.</li>
<li>
<a href="https://postgis.net/" class="external-link">PostGIS</a> is a geospatial extension
to the PostGreSQL relational database.</li>
</ul>
</div>
<div class="section level3">
<h3 id="commercial-software">Commercial software<a class="anchor" aria-label="anchor" href="#commercial-software"></a>
</h3>
<ul>
<li>
<a href="https://www.esri.com/en-us/home" class="external-link">ESRI (Environmental
Systems Research Institute)</a> is an international supplier of
geographic information system (GIS) software, web GIS and geodatabase
management applications. ESRI provides several licenced platforms for
performing GIS, including <a href="https://www.arcgis.com/home/index.html" class="external-link">ArcGIS</a>, <a href="https://www.esri.com/software/arcgis/arcgisonline" class="external-link">ArcGIS
Online</a>, and <a href="https://server.arcgis.com/en/portal/" class="external-link">Portal
for ArcGIS</a> a standalone version of ArGIS Online which you host
locally. ESRI welcomes development on their platforms through their <a href="https://developers.arcgis.com/" class="external-link">DevLabs</a>. ArcGIS software can
be installed using <a href="https://github.com/Esri/arcgis-cookbook" class="external-link">Chef Cookbooks from
Github</a>.</li>
<li>Pitney Bowes produce <a href="https://www.pitneybowes.com/us/location-intelligence/geographic-information-systems/mapinfo-pro.html" class="external-link">MapInfo
Professional</a>, which was one of the earliest desktop GIS programs on
the market.</li>
<li>
<a href="https://www.hexagongeospatial.com/products/products" class="external-link">Hexagon
Geospatial Power Portfolio</a> includes many geospatial tools including
ERDAS Imagine, powerful software for remote sensing.</li>
<li>
<a href="https://www.manifold.net/" class="external-link">Manifold</a> is a desktop GIS
that emphasizes speed through the use of parallel and GPU
processing.</li>
</ul>
</div>
<div class="section level3">
<h3 id="online-cloud-computing">Online + Cloud computing<a class="anchor" aria-label="anchor" href="#online-cloud-computing"></a>
</h3>
<ul>
<li>
<a href="https://pangeo.io/" class="external-link">PANGEO</a> is a community organization
dedicated to open and reproducible data science with python. They focus
on the Pangeo software ecosystem for working with big data in the
geosciences.</li>
<li>Google has created <a href="https://earthengine.google.com/" class="external-link">Google
Earth Engine</a> which combines a multi-petabyte catalog of satellite
imagery and geospatial datasets with planetary-scale analysis
capabilities and makes it available for scientists, researchers, and
developers to detect changes, map trends, and quantify differences on
the Earth’s surface. <a href="https://developers.google.com/earth-engine/" class="external-link">Earth Engine API</a>
runs in both Python and JavaScript.</li>
<li>
<a href="https://www.arcgis.com/features/features.html" class="external-link">ArcGIS
Online</a> provides access to thousands of maps and base layers.</li>
</ul>
<p>Private companies have released SDK platforms for large scale GIS
analysis:</p>
<ul>
<li>
<a href="https://kepler.gl/#/" class="external-link">Kepler.gl</a> is Uber’s toolkit for
handling large datasets (i.e. Uber’s data archive).</li>
<li>
<a href="https://boundlessgeo.com/" class="external-link">Boundless Geospatial</a> is
built upon OSGEO software for enterprise solutions.</li>
</ul>
<p>Publicly funded open-source platforms for large scale GIS
analysis:</p>
<ul>
<li>
<a href="https://pangeo.io/" class="external-link">PANGEO</a> for the Earth Sciences. This
community organization also supports python libraries like xarray, iris,
dask, jupyter, and many other packages.</li>
<li>
<a href="https://sepal.io/" class="external-link">Sepal.io</a> by <a href="https://www.openforis.org/" class="external-link">FAO Open Foris</a> utilizing EOS
satellite imagery and cloud resources for global forest monitoring.</li>
</ul>
</div>
</section><section id="gui-vs-cli"><h2 class="section-heading">GUI vs CLI<a class="anchor" aria-label="anchor" href="#gui-vs-cli"></a>
</h2>
<hr class="half-width">
<p>The earliest computer systems operated without a graphical user
interface (GUI), relying only on the command-line interface (CLI). Since
mapping and spatial analysis are strongly visual tasks, GIS applications
benefited greatly from the emergence of GUIs and quickly came to rely
heavily on them. Most modern GIS applications have very complex GUIs,
with all common tools and procedures accessed via buttons and menus.</p>
<p>Benefits of using a GUI include:</p>
<ul>
<li>Tools are all laid out in front of you</li>
<li>Complex commands are easy to build</li>
<li>Don’t need to learn a coding language</li>
<li>Cartography and visualisation is more intuitive and flexible</li>
</ul>
<p>Downsides of using a GUI include:</p>
<ul>
<li>Low reproducibility - you can’t record your actions and replay</li>
<li>Most are not designed for batch-processing files</li>
<li>Limited ability to customise functions or write your own</li>
<li>Intimidating interface for new users - so many buttons!</li>
</ul>
<p>In scientific computing, the lack of reproducibility in
point-and-click software has come to be viewed as a critical weakness.
As such, scripted CLI-style workflows are again becoming popular, which
leads us to another approach to doing GIS — via a programming language.
This is the approach we will be using throughout this workshop.</p>
</section><section id="gis-in-programming-languages"><h2 class="section-heading">GIS in programming languages<a class="anchor" aria-label="anchor" href="#gis-in-programming-languages"></a>
</h2>
<hr class="half-width">
<p>A number of powerful geospatial processing libraries exist for
general-purpose programming languages like Java and C++. However, the
learning curve for these languages is steep and the effort required is
excessive for users who only need a subset of their functionality.</p>
<p>Higher-level scripting languages like Python and R are easier to
learn and use. Both now have their own packages that wrap up those
geospatial processing libraries and make them easy to access and use
safely. A key example is the Java Topology Suite (JTS), which is
implemented in C++ as GEOS. GEOS is accessible in Python via the
<code>shapely</code> package (and <code>geopandas</code>, which makes
use of <code>shapely</code>) and in R via <code>sf</code>. R and Python
also have interface packages for GDAL, and for specific GIS apps.</p>
<p>This last point is a huge advantage for GIS-by-programming; these
interface packages give you the ability to access functions unique to
particular programs, but have your entire workflow recorded in a central
document - a document that can be re-run at will. Below are lists of
some of the key spatial packages for Python, which we will be using in
the remainder of this workshop.</p>
<ul>
<li>
<code>geopandas</code> and <code>geocube</code> for working with
vector data</li>
<li>
<code>rasterio</code> and <code>rioxarray</code> for working with
raster data</li>
</ul>
<p>These packages along with the <code>matplotlib</code> package are all
we need for spatial data visualisation. Python also has many fundamental
scientific packages that are relevant in the geospatial domain. Below is
a list of particularly fundamental packages. <code>numpy</code>,
<code>scipy</code>, and <code>scikit-image</code> are all excellent
options for working with rasters, as arrays.</p>
<p>An overview of these and other Python spatial packages can be <a href="https://medium.com/@chrieke/essential-geospatial-python-libraries-5d82fcc38731" class="external-link">accessed
here</a>.</p>
<p>As a programming language, Python can be a CLI tool. However, using
Python together with an <a href="https://www.codecademy.com/articles/what-is-an-ide" class="external-link">Integrated
Development Environment</a> (IDE) application allows some GUI features
to become part of your workflow. IDEs allow the best of both worlds.
They provide a place to visually examine data and other software
objects, interact with your file system, and draw plots and maps, but
your activities are still command-driven: recordable and reproducible.
There are several IDEs available for Python. <a href="https://jupyter.org/" class="external-link">JupyterLab</a> is well-developed and the
most widely used option for data science in Python. <a href="https://code.visualstudio.com/docs/python/python-tutorial" class="external-link">VSCode</a>
and <a href="https://www.spyder-ide.org/" class="external-link">Spyder</a> are other popular
options for data science.</p>
<p>Traditional GIS apps are also moving back towards providing a
scripting environment for users, further blurring the CLI/GUI divide.
ESRI have adopted Python into their software, and QGIS is both Python
and R-friendly.</p>
</section><section id="gis-file-types"><h2 class="section-heading">GIS File Types<a class="anchor" aria-label="anchor" href="#gis-file-types"></a>
</h2>
<hr class="half-width">
<p>There are a variety of file types that are used in GIS analysis.
Depending on the program you choose to use some file types can be used
while others are not readable. Below is a brief table describing some of
the most common vector and raster file types.</p>
<div class="section level3">
<h3 id="vector">Vector<a class="anchor" aria-label="anchor" href="#vector"></a>
</h3>
<table class="table">
<colgroup>
<col width="30%">
<col width="33%">
<col width="36%">
</colgroup>
<thead><tr class="header">
<th>File Type</th>
<th>Extensions</th>
<th>Description</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>Esri Shapefile</td>
<td>.SHP .DBF .SHX</td>
<td>The most common geospatial file type. This has become the industry
standard. The three required files are: SHP is the feature geometry. SHX
is the shape index position. DBF is the attribute data.</td>
</tr>
<tr class="even">
<td>Geographic JavaScript Object Notation (GeoJSON)</td>
<td>.GEOJSON .JSON</td>
<td>Used for web-based mapping and uses JavaScript Object Notation to
store the coordinates as text.</td>
</tr>
<tr class="odd">
<td>Google Keyhole Markup Language (KML)</td>
<td>.KML .KMZ</td>
<td>KML stands for Keyhole Markup Language. This GIS format is XML-based
and is primarily used for Google Earth.</td>
</tr>
<tr class="even">
<td>OpenStreetMap</td>
<td>.OSM</td>
<td>OSM files are the native file for OpenStreetMap which had become the
largest crowdsourcing GIS data project in the world. These files are a
collection of vector features from crowd-sourced contributions from the
open community.</td>
</tr>
</tbody>
</table>
</div>
<div class="section level3">
<h3 id="raster">Raster<a class="anchor" aria-label="anchor" href="#raster"></a>
</h3>
<table class="table">
<colgroup>
<col width="30%">
<col width="33%">
<col width="36%">
</colgroup>
<thead><tr class="header">
<th>File Type</th>
<th>Extensions</th>
<th>Description</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>ERDAS Imagine</td>
<td>.IMG</td>
<td>ERDAS Imagine IMG files is a proprietary file format developed by
Hexagon Geospatial. IMG files are commonly used for raster data to store
single and multiple bands of satellite data.Each raster layer as part of
an IMG file contains information about its data values. For example,
this includes projection, statistics, attributes, pyramids and whether
or not it’s a continuous or discrete type of raster.</td>
</tr>
<tr class="even">
<td>GeoTIFF</td>
<td>.TIF .TIFF .OVR</td>
<td>The GeoTIFF has become an industry image standard file for GIS and
satellite remote sensing applications. GeoTIFFs may be accompanied by
other files:TFW is the world file that is required to give your raster
geolocation.XML optionally accompany GeoTIFFs and are your metadata.AUX
auxiliary files store projections and other information.OVR pyramid
files improves performance for raster display.</td>
</tr>
<tr class="odd">
<td>Cloud Optimized GeoTIFF (COG)</td>
<td>.TIF .TIFF</td>
<td>Based on the GeoTIFF standard, COGs incorporate tiling and overviews
to support HTTP range requests where users can query and load subsets of
the image without having to transfer the entire file.</td>
</tr>
</tbody>
</table>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Key Points<a class="anchor" aria-label="anchor" href="#keypoints1"></a>
</h3>
<div class="callout-content">
<ul>
<li>Many software packages exist for working with geospatial data.</li>
<li>Command-line programs allow you to automate and reproduce your
work.</li>
<li>JupyterLab provides a user-friendly interface for working with
Python.</li>
</ul>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</div>
</section></section><section id="aio-05-access-data"><p>Content from <a href="05-access-data.html">Access satellite imagery using Python</a></p>
<hr>
<p>Last updated on 2023-08-29 |
        
        <a href="https://github.com/carpentries-incubator/geospatial-python/edit/main/episodes/05-access-data.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<p>Estimated time: <i aria-hidden="true" data-feather="clock"></i> 45 minutes</p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>Where can I find open-access satellite data?</li>
<li>How do I search for satellite imagery with the STAC API?</li>
<li>How do I fetch remote raster datasets using Python?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Search public STAC repositories of satellite imagery using
Python.</li>
<li>Inspect search result’s metadata.</li>
<li>Download (a subset of) the assets available for a satellite
scene.</li>
<li>Open satellite imagery as raster data and save it to disk.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<section id="introduction"><h2 class="section-heading">Introduction<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h2>
<hr class="half-width">
<p>A number of satellites take snapshots of the Earth’s surface from
space. The images recorded by these remote sensors represent a very
precious data source for any activity that involves monitoring changes
on Earth. Satellite imagery is typically provided in the form of
geospatial raster data, with the measurements in each grid cell
(“pixel”) being associated to accurate geographic coordinate
information.</p>
<p>In this episode we will explore how to access open satellite data
using Python. In particular, we will consider <a href="https://registry.opendata.aws/sentinel-2-l2a-cogs" class="external-link">the Sentinel-2
data collection that is hosted on AWS</a>. This dataset consists of
multi-band optical images acquired by the two satellites of <a href="https://sentinel.esa.int/web/sentinel/missions/sentinel-2" class="external-link">the
Sentinel-2 mission</a> and it is continuously updated with new
images.</p>
</section><section id="search-for-satellite-imagery"><h2 class="section-heading">Search for satellite imagery<a class="anchor" aria-label="anchor" href="#search-for-satellite-imagery"></a>
</h2>
<hr class="half-width">
<div class="section level3">
<h3 id="the-spatiotemporal-asset-catalog-stac-specification">The SpatioTemporal Asset Catalog (STAC) specification<a class="anchor" aria-label="anchor" href="#the-spatiotemporal-asset-catalog-stac-specification"></a>
</h3>
<p>Current sensor resolutions and satellite revisit periods are such
that terabytes of data products are added daily to the corresponding
collections. Such datasets cannot be made accessible to users via
full-catalog download. Space agencies and other data providers often
offer access to their data catalogs through interactive Graphical User
Interfaces (GUIs), see for instance the <a href="https://scihub.copernicus.eu/dhus/#/home" class="external-link">Copernicus Open Access
Hub portal</a> for the Sentinel missions. Accessing data via a GUI is a
nice way to explore a catalog and get familiar with its content, but it
represents a heavy and error-prone task that should be avoided if
carried out systematically to retrieve data.</p>
<p>A service that offers programmatic access to the data enables users
to reach the desired data in a more reliable, scalable and reproducible
manner. An important element in the software interface exposed to the
users, which is generally called the Application Programming Interface
(API), is the use of standards. Standards, in fact, can significantly
facilitate the reusability of tools and scripts across datasets and
applications.</p>
<p>The SpatioTemporal Asset Catalog (STAC) specification is an emerging
standard for describing geospatial data. By organizing metadata in a
form that adheres to the STAC specifications, data providers make it
possible for users to access data from different missions, instruments
and collections using the same set of tools.</p>
<figure><img src="../fig/E05/STAC-browser.jpg" alt="STAC browser screenshots" class="figure mx-auto d-block"><div class="figcaption">Views of the STAC browser</div>
</figure><div id="more-resources-on-stac" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div id="more-resources-on-stac" class="callout-inner">
<h3 class="callout-title">More Resources on STAC<a class="anchor" aria-label="anchor" href="#more-resources-on-stac"></a>
</h3>
<div class="callout-content">
<ul>
<li><a href="https://github.com/radiantearth/stac-spec#readme" class="external-link">STAC
specification</a></li>
<li><a href="https://stacindex.org/ecosystem" class="external-link">Tools based on
STAC</a></li>
<li><a href="https://stacindex.org/catalogs" class="external-link">STAC catalogs</a></li>
</ul>
</div>
</div>
</div>
</div>
</section><section id="search-a-stac-catalog"><h2 class="section-heading">Search a STAC catalog<a class="anchor" aria-label="anchor" href="#search-a-stac-catalog"></a>
</h2>
<hr class="half-width">
<p>The <a href="https://radiantearth.github.io/stac-browser/#/" class="external-link">STAC
browser</a> is a good starting point to discover available datasets, as
it provides an up-to-date list of existing STAC catalogs. From the list,
let’s click on the “Earth Search” catalog, i.e. the access point to
search the archive of Sentinel-2 images hosted on AWS.</p>
<div id="exercise-discover-a-stac-catalog" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="exercise-discover-a-stac-catalog" class="callout-inner">
<h3 class="callout-title">Exercise: Discover a STAC catalog<a class="anchor" aria-label="anchor" href="#exercise-discover-a-stac-catalog"></a>
</h3>
<div class="callout-content">
<p>Let’s take a moment to explore the Earth Search STAC catalog, which
is the catalog indexing the Sentinel-2 collection that is hosted on AWS.
We can interactively browse this catalog using the STAC browser at <a href="https://radiantearth.github.io/stac-browser/#/external/earth-search.aws.element84.com/v1" class="external-link">this
link</a>.</p>
<ol style="list-style-type: decimal">
<li>Open the link in your web browser. Which (sub-)catalogs are
available?</li>
<li>Open the Sentinel-2 Level 2A collection, and select one item from
the list. Each item corresponds to a satellite “scene”, i.e. a portion
of the footage recorded by the satellite at a given time. Have a look at
the metadata fields and the list of assets. What kind of data do the
assets represent?</li>
</ol>
</div>
</div>
</div>
<div id="accordionSolution1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution1" aria-expanded="false" aria-controls="collapseSolution1">
  <h4 class="accordion-header" id="headingSolution1">Show me the solution</h4>
</button>
<div id="collapseSolution1" class="accordion-collapse collapse" data-bs-parent="#accordionSolution1" aria-labelledby="headingSolution1">
<div class="accordion-body">
<figure><img src="../fig/E05/STAC-browser-exercise.jpg" alt="earth-search stac catalog views" class="figure mx-auto d-block"><div class="figcaption">Views of the Earth Search STAC endpoint</div>
</figure><ol style="list-style-type: decimal">
<li>7 subcatalogs are available, including a catalog for Landsat
Collection 2, Level-2 and Sentinel-2 Level 2A (see left screenshot in
the figure above).</li>
<li>When you select the Sentinel-2 Level 2A collection, and randomly
choose one of the items from the list, you should find yourself on a
page similar to the right screenshot in the figure above. On the left
side you will find a list of the available assets: overview images
(thumbnail and true color images), metadata files and the “real”
satellite images, one for each band captured by the Multispectral
Instrument on board Sentinel-2.</li>
</ol>
</div>
</div>
</div>
</div>
<p>When opening a catalog with the STAC browser, you can access the API
URL by clicking on the “Source” button on the top right of the page. By
using this URL, we have access to the catalog content and, if supported
by the catalog, to the functionality of searching its items. For the
Earth Search STAC catalog the API URL is:</p>
<div class="codewrapper sourceCode" id="cb1">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a>api_url <span class="op">=</span> <span class="st">"https://earth-search.aws.element84.com/v1"</span></span></code></pre>
</div>
<p>You can query a STAC API endpoint from Python using the
<code>pystac_client</code> library:</p>
<div class="codewrapper sourceCode" id="cb2">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a><span class="im">from</span> pystac_client <span class="im">import</span> Client</span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" tabindex="-1"></a>client <span class="op">=</span> Client.<span class="bu">open</span>(api_url)</span></code></pre>
</div>
<p>In the following, we ask for scenes belonging to the
<code>sentinel-2-l2a</code> collection. This dataset includes Sentinel-2
data products pre-processed at level 2A (bottom-of-atmosphere
reflectance) and saved in Cloud Optimized GeoTIFF (COG) format:</p>
<div class="codewrapper sourceCode" id="cb3">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a>collection <span class="op">=</span> <span class="st">"sentinel-2-l2a"</span>  <span class="co"># Sentinel-2, Level 2A, Cloud Optimized GeoTiffs (COGs)</span></span></code></pre>
</div>
<div id="cloud-optimized-geotiffs" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div id="cloud-optimized-geotiffs" class="callout-inner">
<h3 class="callout-title">Cloud Optimized GeoTIFFs<a class="anchor" aria-label="anchor" href="#cloud-optimized-geotiffs"></a>
</h3>
<div class="callout-content">
<p>Cloud Optimized GeoTIFFs (COGs) are regular GeoTIFF files with some
additional features that make them ideal to be employed in the context
of cloud computing and other web-based services. This format builds on
the widely-employed GeoTIFF format, already introduced in <a href="01-intro-raster-data.html">Episode 1: Introduction to Raster
Data</a>. In essence, COGs are regular GeoTIFF files with a special
internal structure. One of the features of COGs is that data is
organized in “blocks” that can be accessed remotely via independent HTTP
requests. Data users can thus access the only blocks of a GeoTIFF that
are relevant for their analysis, without having to download the full
file. In addition, COGs typically include multiple lower-resolution
versions of the original image, called “overviews”, which can also be
accessed independently. By providing this “pyramidal” structure, users
that are not interested in the details provided by a high-resolution
raster can directly access the lower-resolution versions of the same
image, significantly saving on the downloading time. More information on
the COG format can be found <a href="https://www.cogeo.org" class="external-link">here</a>.</p>
</div>
</div>
</div>
<p>We also ask for scenes intersecting a geometry defined using the
<code>shapely</code> library (in this case, a point):</p>
<div class="codewrapper sourceCode" id="cb4">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a><span class="im">from</span> shapely.geometry <span class="im">import</span> Point</span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a>point <span class="op">=</span> Point(<span class="fl">4.89</span>, <span class="fl">52.37</span>)  <span class="co"># AMS coordinates</span></span></code></pre>
</div>
<p>Note: at this stage, we are only dealing with metadata, so no image
is going to be downloaded yet. But even metadata can be quite bulky if a
large number of scenes match our search! For this reason, we limit the
search result to 10 items:</p>
<div class="codewrapper sourceCode" id="cb5">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a>search <span class="op">=</span> client.search(</span>
<span id="cb5-2"><a href="#cb5-2" tabindex="-1"></a>    collections<span class="op">=</span>[collection],</span>
<span id="cb5-3"><a href="#cb5-3" tabindex="-1"></a>    intersects<span class="op">=</span>point,</span>
<span id="cb5-4"><a href="#cb5-4" tabindex="-1"></a>    max_items<span class="op">=</span><span class="dv">10</span>,</span>
<span id="cb5-5"><a href="#cb5-5" tabindex="-1"></a>)</span></code></pre>
</div>
<p>We submit the query and find out how many scenes match our search
criteria (please note that this output can be different as more data is
added to the catalog):</p>
<div class="codewrapper sourceCode" id="cb6">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a><span class="bu">print</span>(search.matched())</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code><span><span class="fl">840</span></span></code></pre>
</div>
<p>Finally, we retrieve the metadata of the search results:</p>
<div class="codewrapper sourceCode" id="cb8">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a>items <span class="op">=</span> search.item_collection()</span></code></pre>
</div>
<p>The variable <code>items</code> is an <code>ItemCollection</code>
object. We can check its size by:</p>
<div class="codewrapper sourceCode" id="cb9">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a><span class="bu">print</span>(<span class="bu">len</span>(items))</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code><span><span class="fl">10</span></span></code></pre>
</div>
<p>which is consistent with the maximum number of items that we have set
in the search criteria. We can iterate over the returned items and print
these to show their IDs:</p>
<div class="codewrapper sourceCode" id="cb11">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a><span class="cf">for</span> item <span class="kw">in</span> items:</span>
<span id="cb11-2"><a href="#cb11-2" tabindex="-1"></a>    <span class="bu">print</span>(item)</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>&lt;Item id=S2A_31UFU_20230701_0_L2A&gt;
&lt;Item id=S2B_31UFU_20230629_0_L2A&gt;
&lt;Item id=S2B_31UFU_20230626_0_L2A&gt;
&lt;Item id=S2A_31UFU_20230624_0_L2A&gt;
&lt;Item id=S2A_31UFU_20230621_0_L2A&gt;
&lt;Item id=S2B_31UFU_20230616_0_L2A&gt;
&lt;Item id=S2A_31UFU_20230614_0_L2A&gt;
&lt;Item id=S2A_31UFU_20230611_0_L2A&gt;
&lt;Item id=S2B_31UFU_20230609_0_L2A&gt;
&lt;Item id=S2B_31UFU_20230606_0_L2A&gt;</code></pre>
</div>
<p>Each of the items contains information about the scene geometry, its
acquisition time, and other metadata that can be accessed as a
dictionary from the <code>properties</code> attribute.</p>
<p>Let’s inspect the metadata associated with the first item of the
search results:</p>
<div class="codewrapper sourceCode" id="cb13">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a>item <span class="op">=</span> items[<span class="dv">0</span>]</span>
<span id="cb13-2"><a href="#cb13-2" tabindex="-1"></a><span class="bu">print</span>(item.datetime)</span>
<span id="cb13-3"><a href="#cb13-3" tabindex="-1"></a><span class="bu">print</span>(item.geometry)</span>
<span id="cb13-4"><a href="#cb13-4" tabindex="-1"></a><span class="bu">print</span>(item.properties)</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>2023-07-01 10:46:30.262000+00:00
{'type': 'Polygon', 'coordinates': [[[5.233744523520149, 53.228684673408296], [6.141754296879459, 53.20819279121764], [6.071664488869862, 52.22257539160585], [4.80943323800081, 52.2486879358387], [5.233744523520149, 53.228684673408296]]]}
{'created': '2023-07-02T01:49:17.191Z', 'platform': 'sentinel-2a', 'constellation': 'sentinel-2', 'instruments': ['msi'], 'eo:cloud_cover': 99.952936, 'proj:epsg': 32631, 'mgrs:utm_zone': 31, 'mgrs:latitude_band': 'U', 'mgrs:grid_square': 'FU', 'grid:code': 'MGRS-31UFU', 'view:sun_azimuth': 154.716674921261, 'view:sun_elevation': 58.4960054056685, 's2:degraded_msi_data_percentage': 0.0346, 's2:nodata_pixel_percentage': 33.00232, 's2:saturated_defective_pixel_percentage': 0, 's2:dark_features_percentage': 0, 's2:cloud_shadow_percentage': 0.030847, 's2:vegetation_percentage': 0, 's2:not_vegetated_percentage': 0.004947, 's2:water_percentage': 0.011271, 's2:unclassified_percentage': 0, 's2:medium_proba_clouds_percentage': 5.838514, 's2:high_proba_clouds_percentage': 94.035202, 's2:thin_cirrus_percentage': 0.07922, 's2:snow_ice_percentage': 0, 's2:product_type': 'S2MSI2A', 's2:processing_baseline': '05.09', 's2:product_uri': 'S2A_MSIL2A_20230701T103631_N0509_R008_T31UFU_20230701T200058.SAFE', 's2:generation_time': '2023-07-01T20:00:58.000000Z', 's2:datatake_id': 'GS2A_20230701T103631_041904_N05.09', 's2:datatake_type': 'INS-NOBS', 's2:datastrip_id': 'S2A_OPER_MSI_L2A_DS_2APS_20230701T200058_S20230701T104159_N05.09', 's2:granule_id': 'S2A_OPER_MSI_L2A_TL_2APS_20230701T200058_A041904_T31UFU_N05.09', 's2:reflectance_conversion_factor': 0.967641353116838, 'datetime': '2023-07-01T10:46:30.262000Z', 's2:sequence': '0', 'earthsearch:s3_path': 's3://sentinel-cogs/sentinel-s2-l2a-cogs/31/U/FU/2023/7/S2A_31UFU_20230701_0_L2A', 'earthsearch:payload_id': 'roda-sentinel2/workflow-sentinel2-to-stac/7b1a81ed3fb8d763a0cecf8d9edd4d4a', 'earthsearch:boa_offset_applied': True, 'processing:software': {'sentinel2-to-stac': '0.1.0'}, 'updated': '2023-07-02T01:49:17.191Z'}</code></pre>
</div>
<div id="exercise-search-satellite-scenes-using-metadata-filters" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="exercise-search-satellite-scenes-using-metadata-filters" class="callout-inner">
<h3 class="callout-title">Exercise: Search satellite scenes using
metadata filters<a class="anchor" aria-label="anchor" href="#exercise-search-satellite-scenes-using-metadata-filters"></a>
</h3>
<div class="callout-content">
<p>Search for all the available Sentinel-2 scenes in the
<code>sentinel-2-l2a</code> collection that satisfy the following
criteria: - intersect a provided bounding box (use ±0.01 deg in lat/lon
from the previously defined point); - have been recorded between 20
March 2020 and 30 March 2020; - have a cloud coverage smaller than 10%
(hint: use the <code>query</code> input argument of
<code>client.search</code>).</p>
<p>How many scenes are available? Save the search results in GeoJSON
format.</p>
</div>
</div>
</div>
<div id="accordionSolution2" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution2" aria-expanded="false" aria-controls="collapseSolution2">
  <h4 class="accordion-header" id="headingSolution2">Show me the solution</h4>
</button>
<div id="collapseSolution2" class="accordion-collapse collapse" data-bs-parent="#accordionSolution2" aria-labelledby="headingSolution2">
<div class="accordion-body">
<div class="codewrapper sourceCode" id="cb15">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" tabindex="-1"></a>bbox <span class="op">=</span> point.<span class="bu">buffer</span>(<span class="fl">0.01</span>).bounds</span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb16">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" tabindex="-1"></a>search <span class="op">=</span> client.search(</span>
<span id="cb16-2"><a href="#cb16-2" tabindex="-1"></a>    collections<span class="op">=</span>[collection],</span>
<span id="cb16-3"><a href="#cb16-3" tabindex="-1"></a>    bbox<span class="op">=</span>bbox,</span>
<span id="cb16-4"><a href="#cb16-4" tabindex="-1"></a>    datetime<span class="op">=</span><span class="st">"2020-03-20/2020-03-30"</span>,</span>
<span id="cb16-5"><a href="#cb16-5" tabindex="-1"></a>    query<span class="op">=</span>[<span class="st">"eo:cloud_cover&lt;15"</span>]</span>
<span id="cb16-6"><a href="#cb16-6" tabindex="-1"></a>)</span>
<span id="cb16-7"><a href="#cb16-7" tabindex="-1"></a><span class="bu">print</span>(search.matched())</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code><span><span class="fl">4</span></span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb18">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" tabindex="-1"></a>items <span class="op">=</span> search.item_collection()</span>
<span id="cb18-2"><a href="#cb18-2" tabindex="-1"></a>items.save_object(<span class="st">"search.json"</span>)</span></code></pre>
</div>
</div>
</div>
</div>
</div>
</section><section id="access-the-assets"><h2 class="section-heading">Access the assets<a class="anchor" aria-label="anchor" href="#access-the-assets"></a>
</h2>
<hr class="half-width">
<p>So far we have only discussed metadata - but how can one get to the
actual images of a satellite scene (the “assets” in the STAC
nomenclature)? These can be reached via links that are made available
through the item’s attribute <code>assets</code>.</p>
<div class="codewrapper sourceCode" id="cb19">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" tabindex="-1"></a>assets <span class="op">=</span> items[<span class="dv">0</span>].assets  <span class="co"># first item's asset dictionary</span></span>
<span id="cb19-2"><a href="#cb19-2" tabindex="-1"></a><span class="bu">print</span>(assets.keys())</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>dict_keys(['aot', 'blue', 'coastal', 'granule_metadata', 'green', 'nir', 'nir08', 'nir09', 'red', 'rededge1', 'rededge2', 'rededge3', 'scl', 'swir16', 'swir22', 'thumbnail', 'tileinfo_metadata', 'visual', 'wvp', 'aot-jp2', 'blue-jp2', 'coastal-jp2', 'green-jp2', 'nir-jp2', 'nir08-jp2', 'nir09-jp2', 'red-jp2', 'rededge1-jp2', 'rededge2-jp2', 'rededge3-jp2', 'scl-jp2', 'swir16-jp2', 'swir22-jp2', 'visual-jp2', 'wvp-jp2'])</code></pre>
</div>
<p>We can print a minimal description of the available assets:</p>
<div class="codewrapper sourceCode" id="cb21">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" tabindex="-1"></a><span class="cf">for</span> key, asset <span class="kw">in</span> assets.items():</span>
<span id="cb21-2"><a href="#cb21-2" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>key<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>asset<span class="sc">.</span>title<span class="sc">}</span><span class="ss">"</span>)</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>aot: Aerosol optical thickness (AOT)
blue: Blue (band 2) - 10m
coastal: Coastal aerosol (band 1) - 60m
granule_metadata: None
green: Green (band 3) - 10m
nir: NIR 1 (band 8) - 10m
nir08: NIR 2 (band 8A) - 20m
nir09: NIR 3 (band 9) - 60m
red: Red (band 4) - 10m
rededge1: Red edge 1 (band 5) - 20m
rededge2: Red edge 2 (band 6) - 20m
rededge3: Red edge 3 (band 7) - 20m
scl: Scene classification map (SCL)
swir16: SWIR 1 (band 11) - 20m
swir22: SWIR 2 (band 12) - 20m
thumbnail: Thumbnail image
tileinfo_metadata: None
visual: True color image
wvp: Water vapour (WVP)
aot-jp2: Aerosol optical thickness (AOT)
blue-jp2: Blue (band 2) - 10m
coastal-jp2: Coastal aerosol (band 1) - 60m
green-jp2: Green (band 3) - 10m
nir-jp2: NIR 1 (band 8) - 10m
nir08-jp2: NIR 2 (band 8A) - 20m
nir09-jp2: NIR 3 (band 9) - 60m
red-jp2: Red (band 4) - 10m
rededge1-jp2: Red edge 1 (band 5) - 20m
rededge2-jp2: Red edge 2 (band 6) - 20m
rededge3-jp2: Red edge 3 (band 7) - 20m
scl-jp2: Scene classification map (SCL)
swir16-jp2: SWIR 1 (band 11) - 20m
swir22-jp2: SWIR 2 (band 12) - 20m
visual-jp2: True color image
wvp-jp2: Water vapour (WVP)</code></pre>
</div>
<p>Among the others, assets include multiple raster data files (one per
optical band, as acquired by the multi-spectral instrument), a
thumbnail, a true-color image (“visual”), instrument metadata and
scene-classification information (“SCL”). Let’s get the URL links to the
actual asset:</p>
<div class="codewrapper sourceCode" id="cb23">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" tabindex="-1"></a><span class="bu">print</span>(assets[<span class="st">"thumbnail"</span>].href)</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/31/U/FU/2020/3/S2A_31UFU_20200328_0_L2A/thumbnail.jpg</code></pre>
</div>
<p>This can be used to download the corresponding file:</p>
<figure><img src="../fig/E05/STAC-s2-preview.jpg" alt="thumbnail of the sentinel-2 scene" class="figure mx-auto d-block"><div class="figcaption">Overview of the true-color image
(“thumbnail”)</div>
</figure><p>Remote raster data can be directly opened via the
<code>rioxarray</code> library. We will learn more about this library in
the next episodes.</p>
<div class="codewrapper sourceCode" id="cb25">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" tabindex="-1"></a><span class="im">import</span> rioxarray</span>
<span id="cb25-2"><a href="#cb25-2" tabindex="-1"></a>nir_href <span class="op">=</span> assets[<span class="st">"nir"</span>].href</span>
<span id="cb25-3"><a href="#cb25-3" tabindex="-1"></a>nir <span class="op">=</span> rioxarray.open_rasterio(nir_href)</span>
<span id="cb25-4"><a href="#cb25-4" tabindex="-1"></a><span class="bu">print</span>(nir)</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>&lt;xarray.DataArray (band: 1, y: 10980, x: 10980)&gt;
[120560400 values with dtype=uint16]
Coordinates:
  * band         (band) int64 1
  * x            (x) float64 6e+05 6e+05 6e+05 ... 7.098e+05 7.098e+05 7.098e+05
  * y            (y) float64 5.9e+06 5.9e+06 5.9e+06 ... 5.79e+06 5.79e+06
    spatial_ref  int64 0
Attributes:
    AREA_OR_POINT:       Area
    OVR_RESAMPLING_ALG:  AVERAGE
    _FillValue:          0
    scale_factor:        1.0
    add_offset:          0.0</code></pre>
</div>
<p>We can then save the data to disk:</p>
<div class="codewrapper sourceCode" id="cb27">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" tabindex="-1"></a><span class="co"># save whole image to disk</span></span>
<span id="cb27-2"><a href="#cb27-2" tabindex="-1"></a>nir.rio.to_raster(<span class="st">"nir.tif"</span>)</span></code></pre>
</div>
<p>Since that might take a while, given there are over 10000 x 10000 = a
hundred million pixels in the 10 meter NIR band, you can take a smaller
subset before downloading it. Becuase the raster is a COG, we can
download just what we need!</p>
<p>Here, we specify that we want to download the first (and only) band
in the tif file, and a slice of the width and height dimensions.</p>
<div class="codewrapper sourceCode" id="cb28">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" tabindex="-1"></a><span class="co"># save portion of an image to disk</span></span>
<span id="cb28-2"><a href="#cb28-2" tabindex="-1"></a>nir[<span class="dv">0</span>,<span class="dv">1500</span>:<span class="dv">2200</span>,<span class="dv">1500</span>:<span class="dv">2200</span>].rio.to_raster(<span class="st">"nir_subset.tif"</span>)</span></code></pre>
</div>
<p>The difference is 155 Megabytes for the large image vs about 1
Megabyte for the subset.</p>
<div id="exercise-downloading-landsat-8-assets" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="exercise-downloading-landsat-8-assets" class="callout-inner">
<h3 class="callout-title">Exercise: Downloading Landsat 8 Assets<a class="anchor" aria-label="anchor" href="#exercise-downloading-landsat-8-assets"></a>
</h3>
<div class="callout-content">
<p>In this exercise we put in practice all the skills we have learned in
this episode to retrieve images from a different mission: <a href="https://www.usgs.gov/landsat-missions/landsat-8" class="external-link">Landsat 8</a>. In
particular, we browse images from the <a href="https://lpdaac.usgs.gov/products/hlsl30v002/" class="external-link">Harmonized Landsat
Sentinel-2 (HLS) project</a>, which provides images from NASA’s Landsat
8 and ESA’s Sentinel-2 that have been made consistent with each other.
The HLS catalog is indexed in the NASA Common Metadata Repository (CMR)
and it can be accessed from the STAC API endpoint at the following URL:
<code>https://cmr.earthdata.nasa.gov/stac/LPCLOUD</code>.</p>
<ul>
<li>Using <code>pystac_client</code>, search for all assets of the
Landsat 8 collection (<code>HLSL30.v2.0</code>) from February to March
2021, intersecting the point with longitude/latitute coordinates
(-73.97, 40.78) deg.</li>
<li>Visualize an item’s thumbnail (asset key <code>browse</code>).</li>
</ul>
</div>
</div>
</div>
<div id="accordionSolution3" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution3" aria-expanded="false" aria-controls="collapseSolution3">
  <h4 class="accordion-header" id="headingSolution3">Show me the solution</h4>
</button>
<div id="collapseSolution3" class="accordion-collapse collapse" data-bs-parent="#accordionSolution3" aria-labelledby="headingSolution3">
<div class="accordion-body">
<div class="codewrapper sourceCode" id="cb29">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" tabindex="-1"></a><span class="co"># connect to the STAC endpoint</span></span>
<span id="cb29-2"><a href="#cb29-2" tabindex="-1"></a>cmr_api_url <span class="op">=</span> <span class="st">"https://cmr.earthdata.nasa.gov/stac/LPCLOUD"</span></span>
<span id="cb29-3"><a href="#cb29-3" tabindex="-1"></a>client <span class="op">=</span> Client.<span class="bu">open</span>(cmr_api_url)</span>
<span id="cb29-4"><a href="#cb29-4" tabindex="-1"></a></span>
<span id="cb29-5"><a href="#cb29-5" tabindex="-1"></a><span class="co"># setup search</span></span>
<span id="cb29-6"><a href="#cb29-6" tabindex="-1"></a>search <span class="op">=</span> client.search(</span>
<span id="cb29-7"><a href="#cb29-7" tabindex="-1"></a>    collections<span class="op">=</span>[<span class="st">"HLSL30.v2.0"</span>],</span>
<span id="cb29-8"><a href="#cb29-8" tabindex="-1"></a>    intersects<span class="op">=</span>Point(<span class="op">-</span><span class="fl">73.97</span>, <span class="fl">40.78</span>),</span>
<span id="cb29-9"><a href="#cb29-9" tabindex="-1"></a>    datetime<span class="op">=</span><span class="st">"2021-02-01/2021-03-30"</span>,</span>
<span id="cb29-10"><a href="#cb29-10" tabindex="-1"></a>) <span class="co"># nasa cmr cloud cover filtering is currently broken: https://github.com/nasa/cmr-stac/issues/239</span></span>
<span id="cb29-11"><a href="#cb29-11" tabindex="-1"></a></span>
<span id="cb29-12"><a href="#cb29-12" tabindex="-1"></a><span class="co"># retrieve search results</span></span>
<span id="cb29-13"><a href="#cb29-13" tabindex="-1"></a>items <span class="op">=</span> search.item_collection()</span>
<span id="cb29-14"><a href="#cb29-14" tabindex="-1"></a><span class="bu">print</span>(<span class="bu">len</span>(items))</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code><span><span class="fl">5</span></span></code></pre>
</div>
<div class="codewrapper sourceCode" id="cb31">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" tabindex="-1"></a>items_sorted <span class="op">=</span> <span class="bu">sorted</span>(items, key<span class="op">=</span><span class="kw">lambda</span> x: x.properties[<span class="st">"eo:cloud_cover"</span>]) <span class="co"># sorting and then selecting by cloud cover</span></span>
<span id="cb31-2"><a href="#cb31-2" tabindex="-1"></a>item <span class="op">=</span> items_sorted[<span class="dv">0</span>]</span>
<span id="cb31-3"><a href="#cb31-3" tabindex="-1"></a><span class="bu">print</span>(item)</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>&lt;Item id=HLS.L30.T18TWL.2021039T153324.v2.0&gt;</code></pre>
</div>
<div class="codewrapper sourceCode" id="cb33">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" tabindex="-1"></a><span class="bu">print</span>(item.assets[<span class="st">"browse"</span>].href)</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code><span><span class="st">'https://data.lpdaac.earthdatacloud.nasa.gov/lp-prod-public/HLSL30.020/HLS.L30.T18TWL.2021039T153324.v2.0/HLS.L30.T18TWL.039T153324.v2.0.jpg'</span></span></code></pre>
</div>
<figure><img src="../fig/E05/STAC-l8-preview.jpg" alt="thumbnail of the landsat-8 scene" class="figure mx-auto d-block"><div class="figcaption">Thumbnail of the Landsat-8 scene</div>
</figure>
</div>
</div>
</div>
</div>
<div id="public-catalogs-protected-data" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div id="public-catalogs-protected-data" class="callout-inner">
<h3 class="callout-title">Public catalogs, protected data<a class="anchor" aria-label="anchor" href="#public-catalogs-protected-data"></a>
</h3>
<div class="callout-content">
<p>Publicly accessible catalogs and STAC endpoints do not necessarily
imply publicly accessible data. Data providers, in fact, may limit data
access to specific infrastructures and/or require authentication. For
instance, the NASA CMR STAC endpoint considered in the last exercise
offers publicly accessible metadata for the HLS collection, but most of
the linked assets are available only for registered users (the thumbnail
is publicly accessible).</p>
<p>The authentication procedure for dataset with restricted access might
differ depending on the data provider. For the NASA CMR, follow these
steps in order to access data using Python:</p>
<ul>
<li>Create a NASA Earthdata login account <a href="https://urs.earthdata.nasa.gov" class="external-link">here</a>;</li>
<li>Set up a netrc file with your credentials, e.g. by using <a href="https://git.earthdata.nasa.gov/projects/LPDUR/repos/daac_data_download_python/browse/EarthdataLoginSetup.py" class="external-link">this
script</a>;</li>
<li>Define the following environment variables:</li>
</ul>
<div class="codewrapper sourceCode" id="cb35">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" tabindex="-1"></a><span class="im">import</span> os</span>
<span id="cb35-2"><a href="#cb35-2" tabindex="-1"></a>os.environ[<span class="st">"GDAL_HTTP_COOKIEFILE"</span>] <span class="op">=</span> <span class="st">"./cookies.txt"</span></span>
<span id="cb35-3"><a href="#cb35-3" tabindex="-1"></a>os.environ[<span class="st">"GDAL_HTTP_COOKIEJAR"</span>] <span class="op">=</span> <span class="st">"./cookies.txt"</span></span></code></pre>
</div>
</div>
</div>
</div>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Key Points<a class="anchor" aria-label="anchor" href="#keypoints1"></a>
</h3>
<div class="callout-content">
<ul>
<li>Accessing satellite images via the providers’ API enables a more
reliable and scalable data retrieval.</li>
<li>STAC catalogs can be browsed and searched using the same tools and
scripts.</li>
<li>
<code>rioxarray</code> allows you to open and download remote raster
files.</li>
</ul>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</section></section><section id="aio-06-raster-intro"><p>Content from <a href="06-raster-intro.html">Read and visualize raster data</a></p>
<hr>
<p>Last updated on 2023-08-23 |
        
        <a href="https://github.com/carpentries-incubator/geospatial-python/edit/main/episodes/06-raster-intro.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<p>Estimated time: <i aria-hidden="true" data-feather="clock"></i> 100 minutes</p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>How is a raster represented by rioxarray?</li>
<li>How do I read and plot raster data in Python?</li>
<li>How can I handle missing data?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Describe the fundamental attributes of a raster dataset.</li>
<li>Explore raster attributes and metadata using Python.</li>
<li>Read rasters into Python using the <code>rioxarray</code>
package.</li>
<li>Visualize single/multi-band raster data.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<p>Raster datasets have been introduced in <a href="01-intro-raster-data.html">Episode 1: Introduction to Raster
Data</a>. Here, we introduce the fundamental principles, packages and
metadata/raster attributes for working with raster data in Python. We
will also explore how Python handles missing and bad data values.</p>
<p><a href="https://corteva.github.io/rioxarray/stable/" class="external-link"><code>rioxarray</code></a>
is the Python package we will use throughout this lesson to work with
raster data. It is based on the popular <a href="https://rasterio.readthedocs.io/en/latest/" class="external-link"><code>rasterio</code></a>
package for working with rasters and <a href="https://xarray.pydata.org/en/stable/" class="external-link"><code>xarray</code></a> for
working with multi-dimensional arrays. <code>rioxarray</code> extends
<code>xarray</code> by providing top-level functions (e.g. the
<code>open_rasterio</code> function to open raster datasets) and by
adding a set of methods to the main objects of the <code>xarray</code>
package (the <code>Dataset</code> and the <code>DataArray</code>). These
additional methods are made available via the <code>rio</code> accessor
and become available from <code>xarray</code> objects after importing
<code>rioxarray</code>.</p>
<p>We will also use the <a href="https://github.com/stac-utils/pystac" class="external-link"><code>pystac</code></a>
package to load rasters from the search results we created in the
previous episode.</p>
<div id="introduce-the-raster-data" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div id="introduce-the-raster-data" class="callout-inner">
<h3 class="callout-title">Introduce the Raster Data<a class="anchor" aria-label="anchor" href="#introduce-the-raster-data"></a>
</h3>
<div class="callout-content">
<p>We’ll continue from the results of the satellite image search that we
have carried out in an exercise from <a href="05-access-data.html">a
previous episode</a>. We will load data starting from the
<code>search.json</code> file, using one scene from the search results
as an example to demonstrate data loading and visualization.</p>
<p>If you would like to work with the data for this lesson without
downloading data on-the-fly, you can download the raster data ahead of
time using this <a href="https://figshare.com/ndownloader/files/36028100" class="external-link">link</a>. Save
the <code>geospatial-python-raster-dataset.tar.gz</code> file in your
current working directory, and extract the archive file by
double-clicking on it or by running the following command in your
terminal <code>tar -zxvf geospatial-python-raster-dataset.tar.gz</code>.
Use the file <code>geospatial-python-raster-dataset/search.json</code>
(instead of <code>search.json</code>) to get started with this
lesson.</p>
<p>This can be useful if you need to download the data ahead of time to
work through the lesson offline, or if you want to work with the data in
a different GIS.</p>
</div>
</div>
</div>
<section id="load-a-raster-and-view-attributes"><h2 class="section-heading">Load a Raster and View Attributes<a class="anchor" aria-label="anchor" href="#load-a-raster-and-view-attributes"></a>
</h2>
<hr class="half-width">
<p>In the previous episode, we searched for Sentinel-2 images, and then
saved the search results to a file: <code>search.json</code>. This
contains the information on where and how to access the target images
from a remote repository. We can use the function
<code>pystac.ItemCollection.from_file()</code> to load the search
results as an <code>Item</code> list.</p>
<div class="codewrapper sourceCode" id="cb1">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="im">import</span> pystac</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a>items <span class="op">=</span> pystac.ItemCollection.from_file(<span class="st">"search.json"</span>)</span></code></pre>
</div>
<p>In the search results, we have 2 <code>Item</code> type objects,
corresponding to 4 Sentinel-2 scenes from March 26th and 28th in 2020.
We will focus on the first scene <code>S2A_31UFU_20200328_0_L2A</code>,
and load band <code>nir09</code> (central wavelength 945 nm). We can
load this band using the function
<code>rioxarray.open_rasterio()</code>, via the Hypertext Reference
<code>href</code> (commonly referred to as a URL):</p>
<div class="codewrapper sourceCode" id="cb2">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a><span class="im">import</span> rioxarray</span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a>raster_ams_b9 <span class="op">=</span> rioxarray.open_rasterio(items[<span class="dv">0</span>].assets[<span class="st">"nir09"</span>].href)</span></code></pre>
</div>
<p>By calling the variable name in the jupyter notebook we can get a
quick look at the shape and attributes of the data.</p>
<div class="codewrapper sourceCode" id="cb3">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a>raster_ams_b9</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>&lt;xarray.DataArray (band: 1, y: 1830, x: 1830)&gt;
[3348900 values with dtype=uint16]
Coordinates:
  * band         (band) int64 1
  * x            (x) float64 6e+05 6.001e+05 6.002e+05 ... 7.097e+05 7.098e+05
  * y            (y) float64 5.9e+06 5.9e+06 5.9e+06 ... 5.79e+06 5.79e+06
    spatial_ref  int64 0
Attributes:
    _FillValue:    0.0
    scale_factor:  1.0
    add_offset:    0.0</code></pre>
</div>
<p>The first call to <code>rioxarray.open_rasterio()</code> opens the
file from remote or local storage, and then returns a
<code>xarray.DataArray</code> object. The object is stored in a
variable, i.e. <code>raster_ams_b9</code>. Reading in the data with
<code>xarray</code> instead of <code>rioxarray</code> also returns a
<code>xarray.DataArray</code>, but the output will not contain the
geospatial metadata (such as projection information). You can use numpy
functions or built-in Python math operators on a
<code>xarray.DataArray</code> just like a numpy array. Calling the
variable name of the <code>DataArray</code> also prints out all of its
metadata information.</p>
<p>The output tells us that we are looking at an
<code>xarray.DataArray</code>, with <code>1</code> band,
<code>1830</code> rows, and <code>1830</code> columns. We can also see
the number of pixel values in the <code>DataArray</code>, and the type
of those pixel values, which is unsigned integer (or
<code>uint16</code>). The <code>DataArray</code> also stores different
values for the coordinates of the <code>DataArray</code>. When using
<code>rioxarray</code>, the term coordinates refers to spatial
coordinates like <code>x</code> and <code>y</code> but also the
<code>band</code> coordinate. Each of these sequences of values has its
own data type, like <code>float64</code> for the spatial coordinates and
<code>int64</code> for the <code>band</code> coordinate.</p>
<p>This <code>DataArray</code> object also has a couple of attributes
that are accessed like <code>.rio.crs</code>, <code>.rio.nodata</code>,
and <code>.rio.bounds()</code>, which contain the metadata for the file
we opened. Note that many of the metadata are accessed as attributes
without <code>()</code>, but <code>bounds()</code> is a method (i.e. a
function in an object) and needs parentheses.</p>
<div class="codewrapper sourceCode" id="cb5">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a><span class="bu">print</span>(raster_ams_b9.rio.crs)</span>
<span id="cb5-2"><a href="#cb5-2" tabindex="-1"></a><span class="bu">print</span>(raster_ams_b9.rio.nodata)</span>
<span id="cb5-3"><a href="#cb5-3" tabindex="-1"></a><span class="bu">print</span>(raster_ams_b9.rio.bounds())</span>
<span id="cb5-4"><a href="#cb5-4" tabindex="-1"></a><span class="bu">print</span>(raster_ams_b9.rio.width)</span>
<span id="cb5-5"><a href="#cb5-5" tabindex="-1"></a><span class="bu">print</span>(raster_ams_b9.rio.height)</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>EPSG:32631
0
(600000.0, 5790240.0, 709800.0, 5900040.0)
1830
1830</code></pre>
</div>
<p>The Coordinate Reference System, or
<code>raster_ams_b9.rio.crs</code>, is reported as the string
<code>EPSG:32631</code>. The <code>nodata</code> value is encoded as 0
and the bounding box corners of our raster are represented by the output
of <code>.bounds()</code> as a <code>tuple</code> (like a list but you
can’t edit it). The height and width match what we saw when we printed
the <code>DataArray</code>, but by using <code>.rio.width</code> and
<code>.rio.height</code> we can access these values if we need them in
calculations.</p>
<p>We will be exploring this data throughout this episode. By the end of
this episode, you will be able to understand and explain the metadata
output.</p>
<div id="tip---variable-names" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div id="tip---variable-names" class="callout-inner">
<h3 class="callout-title">Tip - Variable names<a class="anchor" aria-label="anchor" href="#tip---variable-names"></a>
</h3>
<div class="callout-content">
<p>To improve code readability, file and object names should be used
that make it clear what is in the file. The data for this episode covers
Amsterdam, and is from Band 9, so we’ll use a naming convention of
<code>raster_ams_b9</code>.</p>
</div>
</div>
</div>
</section><section id="visualize-a-raster"><h2 class="section-heading">Visualize a Raster<a class="anchor" aria-label="anchor" href="#visualize-a-raster"></a>
</h2>
<hr class="half-width">
<p>After viewing the attributes of our raster, we can examine the raw
values of the array with <code>.values</code>:</p>
<div class="codewrapper sourceCode" id="cb7">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a>raster_ams_b9.values</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>array([[[    0,     0,     0, ...,  8888,  9075,  8139],
        [    0,     0,     0, ..., 10444, 10358,  8669],
        [    0,     0,     0, ..., 10346, 10659,  9168],
        ...,
        [    0,     0,     0, ...,  4295,  4289,  4320],
        [    0,     0,     0, ...,  4291,  4269,  4179],
        [    0,     0,     0, ...,  3944,  3503,  3862]]], dtype=uint16)</code></pre>
</div>
<p>This can give us a quick view of the values of our array, but only at
the corners. Since our raster is loaded in python as a
<code>DataArray</code> type, we can plot this in one line similar to a
pandas <code>DataFrame</code> with <code>DataArray.plot()</code>.</p>
<div class="codewrapper sourceCode" id="cb9">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a>raster_ams_b9.plot()</span></code></pre>
</div>
<figure><img src="../fig/E06/overview-plot-B09.png" alt="raster plot with defualt setting" class="figure mx-auto d-block"><div class="figcaption">Raster plot with rioxarray</div>
</figure><p>Nice plot! Notice that <code>rioxarray</code> helpfully allows us to
plot this raster with spatial coordinates on the x and y axis (this is
not the default in many cases with other functions or libraries).</p>
<p>This plot shows the satellite measurement of the spectral band
<code>nir09</code> for an area that covers part of the Netherlands.
According to the <a href="https://sentinels.copernicus.eu/web/sentinel/technical-guides/sentinel-2-msi/msi-instrument" class="external-link">Sentinel-2
documentaion</a>, this is a band with the central wavelength of 945nm,
which is sensitive to water vapor. It has a spatial resolution of 60m.
Note that the <code>band=1</code> in the image title refers to the
ordering of all the bands in the <code>DataArray</code>, not the
Sentinel-2 band number <code>09</code> that we saw in the pystac search
results.</p>
<p>With a quick view of the image, we notice that half of the image is
blank, no data is captured. We also see that the cloudy pixels at the
top have high reflectance values, while the contrast of everything else
is quite low. This is expected because this band is sensitive to the
water vapor. However if one would like to have a better color contrast,
one can add the option <code>robust=True</code>, which displays values
between the 2nd and 98th percentile:</p>
<div class="codewrapper sourceCode" id="cb10">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a>raster_ams_b9.plot(robust<span class="op">=</span><span class="va">True</span>)</span></code></pre>
</div>
<figure><img src="../fig/E06/overview-plot-B09-robust.png" alt="raster plot with robust setting" class="figure mx-auto d-block"><div class="figcaption">Raster plot using the “robust” setting</div>
</figure><p>Now the color limit is set in a way fitting most of the values in the
image. We have a better view of the ground pixels.</p>
<div id="tool-tip" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div id="tool-tip" class="callout-inner">
<h3 class="callout-title">Tool Tip<a class="anchor" aria-label="anchor" href="#tool-tip"></a>
</h3>
<div class="callout-content">
<p>The option <code>robust=True</code> always forces displaying values
between the 2nd and 98th percentile. Of course, this will not work for
every case. For a customized displaying range, you can also manually
specifying the keywords <code>vmin</code> and <code>vmax</code>. For
example ploting between <code>100</code> and <code>7000</code>:</p>
<div class="codewrapper sourceCode" id="cb11">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a>raster_ams_b9.plot(vmin<span class="op">=</span><span class="dv">100</span>, vmax<span class="op">=</span><span class="dv">7000</span>)</span></code></pre>
</div>
</div>
</div>
</div>
</section><section id="view-raster-coordinate-reference-system-crs-in-python"><h2 class="section-heading">View Raster Coordinate Reference System (CRS) in Python<a class="anchor" aria-label="anchor" href="#view-raster-coordinate-reference-system-crs-in-python"></a>
</h2>
<hr class="half-width">
<p>Another information that we’re interested in is the CRS, and it can
be accessed with <code>.rio.crs</code>. We introduced the concept of a
CRS in <a href="03-crs.html">an earlier episode</a>. Now we will see how
features of the CRS appear in our data file and what meanings they have.
We can view the CRS string associated with our DataArray’s
<code>rio</code> object using the <code>crs</code> attribute.</p>
<div class="codewrapper sourceCode" id="cb12">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a><span class="bu">print</span>(raster_ams_b9.rio.crs)</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code><span><span class="va">EPSG</span><span class="op">:</span><span class="fl">32631</span></span></code></pre>
</div>
<p>To print the EPSG code number as an <code>int</code>, we use the
<code>.to_epsg()</code> method:</p>
<div class="codewrapper sourceCode" id="cb14">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" tabindex="-1"></a>raster_ams_b9.rio.crs.to_epsg()</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code><span><span class="fl">32631</span></span></code></pre>
</div>
<p>EPSG codes are great for succinctly representing a particular
coordinate reference system. But what if we want to see more details
about the CRS, like the units? For that, we can use <code>pyproj</code>,
a library for representing and working with coordinate reference
systems.</p>
<div class="codewrapper sourceCode" id="cb16">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" tabindex="-1"></a><span class="im">from</span> pyproj <span class="im">import</span> CRS</span>
<span id="cb16-2"><a href="#cb16-2" tabindex="-1"></a>epsg <span class="op">=</span> raster_ams_b9.rio.crs.to_epsg()</span>
<span id="cb16-3"><a href="#cb16-3" tabindex="-1"></a>crs <span class="op">=</span> CRS(epsg)</span>
<span id="cb16-4"><a href="#cb16-4" tabindex="-1"></a>crs</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>&lt;Derived Projected CRS: EPSG:32631&gt;
Name: WGS 84 / UTM zone 31N
Axis Info [cartesian]:
- E[east]: Easting (metre)
- N[north]: Northing (metre)
Area of Use:
- name: Between 0°E and 6°E, northern hemisphere between equator and 84°N, onshore and offshore. Algeria. Andorra. Belgium. Benin. Burkina Faso. Denmark - North Sea. France. Germany - North Sea. Ghana. Luxembourg. Mali. Netherlands. Niger. Nigeria. Norway. Spain. Togo. United Kingdom (UK) - North Sea.
- bounds: (0.0, 0.0, 6.0, 84.0)
Coordinate Operation:
- name: UTM zone 31N
- method: Transverse Mercator
Datum: World Geodetic System 1984 ensemble
- Ellipsoid: WGS 84
- Prime Meridian: Greenwich</code></pre>
</div>
<p>The <code>CRS</code> class from the <code>pyproj</code> library
allows us to create a <code>CRS</code> object with methods and
attributes for accessing specific information about a CRS, or the
detailed summary shown above.</p>
<p>A particularly useful attribute is <code>area_of_use</code>, which
shows the geographic bounds that the CRS is intended to be used.</p>
<div class="codewrapper sourceCode" id="cb18">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" tabindex="-1"></a>crs.area_of_use</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code><span><span class="fu">AreaOfUse</span><span class="op">(</span>west<span class="op">=</span><span class="fl">0.0</span>, south<span class="op">=</span><span class="fl">0.0</span>, east<span class="op">=</span><span class="fl">6.0</span>, north<span class="op">=</span><span class="fl">84.0</span>, name<span class="op">=</span><span class="st">'Between 0°E and 6°E, northern hemisphere between equator and 84°N, onshore and offshore. Algeria. Andorra. Belgium. Benin. Burkina Faso. Denmark - North Sea. France. Germany - North Sea. Ghana. Luxembourg. Mali. Netherlands. Niger. Nigeria. Norway. Spain. Togo. United Kingdom (UK) - North Sea.'</span><span class="op">)</span></span></code></pre>
</div>
<div id="exercise-find-the-axes-units-of-the-crs" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="exercise-find-the-axes-units-of-the-crs" class="callout-inner">
<h3 class="callout-title">Exercise: find the axes units of the CRS<a class="anchor" aria-label="anchor" href="#exercise-find-the-axes-units-of-the-crs"></a>
</h3>
<div class="callout-content">
<p>What units are our data in? See if you can find a method to examine
this information using <code>help(crs)</code> or
<code>dir(crs)</code></p>
</div>
</div>
</div>
<div id="accordionSolution1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution1" aria-expanded="false" aria-controls="collapseSolution1">
  <h4 class="accordion-header" id="headingSolution1">Show me the solution</h4>
</button>
<div id="collapseSolution1" class="accordion-collapse collapse" aria-labelledby="headingSolution1" data-bs-parent="#accordionSolution1">
<div class="accordion-body">
<p><code>crs.axis_info</code> tells us that the CRS for our raster has
two axis and both are in meters. We could also get this information from
the attribute <code>raster_ams_b9.rio.crs.linear_units</code>.</p>
</div>
</div>
</div>
</div>
<div class="section level3">
<h3 id="understanding-pyproj-crs-summary">Understanding pyproj CRS Summary<a class="anchor" aria-label="anchor" href="#understanding-pyproj-crs-summary"></a>
</h3>
<p>Let’s break down the pieces of the <code>pyproj</code> CRS summary.
The string contains all of the individual CRS elements that Python or
another GIS might need, separated into distinct sections, and datum.</p>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>&lt;Derived Projected CRS: EPSG:32631&gt;
Name: WGS 84 / UTM zone 31N
Axis Info [cartesian]:
- E[east]: Easting (metre)
- N[north]: Northing (metre)
Area of Use:
- name: Between 0°E and 6°E, northern hemisphere between equator and 84°N, onshore and offshore. Algeria. Andorra. Belgium. Benin. Burkina Faso. Denmark - North Sea. France. Germany - North Sea. Ghana. Luxembourg. Mali. Netherlands. Niger. Nigeria. Norway. Spain. Togo. United Kingdom (UK) - North Sea.
- bounds: (0.0, 0.0, 6.0, 84.0)
Coordinate Operation:
- name: UTM zone 31N
- method: Transverse Mercator
Datum: World Geodetic System 1984 ensemble
- Ellipsoid: WGS 84
- Prime Meridian: Greenwich</code></pre>
</div>
<ul>
<li>
<strong>Name</strong> of the projection is UTM zone 31N (UTM has 60
zones, each 6-degrees of longitude in width). The underlying datum is
WGS84.</li>
<li>
<strong>Axis Info</strong>: the CRS shows a Cartesian system with
two axes, easting and northing, in meter units.</li>
<li>
<strong>Area of Use</strong>: the projection is used for a
particular range of longitudes <code>0°E to 6°E</code> in the northern
hemisphere (<code>0.0°N to 84.0°N</code>)</li>
<li>
<strong>Coordinate Operation</strong>: the operation to project the
coordinates (if it is projected) onto a cartesian (x, y) plane.
Transverse Mercator is accurate for areas with longitudinal widths of a
few degrees, hence the distinct UTM zones.</li>
<li>
<strong>Datum</strong>: Details about the datum, or the reference
point for coordinates. <code>WGS 84</code> and <code>NAD 1983</code> are
common datums. <code>NAD 1983</code> is <a href="https://en.wikipedia.org/wiki/Datum_of_2022" class="external-link">set to be replaced in
2022</a>.</li>
</ul>
<p>Note that the zone is unique to the UTM projection. Not all CRSs will
have a zone. Below is a simplified view of US UTM zones.</p>
<figure><img src="../fig/E03/Utm-zones-USA.svg" alt="UTM zones across the CONUS" class="figure mx-auto d-block"><div class="figcaption">The UTM zones across the continental United
States (Chrismurf at English Wikipedia, via <a href="https://en.wikipedia.org/wiki/Universal_Transverse_Mercator_coordinate_system#/media/File:Utm-zones-USA.svg" class="external-link">Wikimedia
Commons</a> (CC-BY))</div>
</figure>
</div>
</section><section id="calculate-raster-statistics"><h2 class="section-heading">Calculate Raster Statistics<a class="anchor" aria-label="anchor" href="#calculate-raster-statistics"></a>
</h2>
<hr class="half-width">
<p>It is useful to know the minimum or maximum values of a raster
dataset. We can compute these and other descriptive statistics with
<code>min</code>, <code>max</code>, <code>mean</code>, and
<code>std</code>.</p>
<div class="codewrapper sourceCode" id="cb21">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" tabindex="-1"></a><span class="bu">print</span>(raster_ams_b9.<span class="bu">min</span>())</span>
<span id="cb21-2"><a href="#cb21-2" tabindex="-1"></a><span class="bu">print</span>(raster_ams_b9.<span class="bu">max</span>())</span>
<span id="cb21-3"><a href="#cb21-3" tabindex="-1"></a><span class="bu">print</span>(raster_ams_b9.mean())</span>
<span id="cb21-4"><a href="#cb21-4" tabindex="-1"></a><span class="bu">print</span>(raster_ams_b9.std())</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>&lt;xarray.DataArray ()&gt;
array(0, dtype=uint16)
Coordinates:
    spatial_ref  int64 0
&lt;xarray.DataArray ()&gt;
array(15497, dtype=uint16)
Coordinates:
    spatial_ref  int64 0
&lt;xarray.DataArray ()&gt;
array(1652.44009944)
Coordinates:
    spatial_ref  int64 0
&lt;xarray.DataArray ()&gt;
array(2049.16447495)
Coordinates:
    spatial_ref  int64 0</code></pre>
</div>
<p>The information above includes a report of the min, max, mean, and
standard deviation values, along with the data type. If we want to see
specific quantiles, we can use xarray’s <code>.quantile()</code> method.
For example for the 25% and 75% quantiles:</p>
<div class="codewrapper sourceCode" id="cb23">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" tabindex="-1"></a><span class="bu">print</span>(raster_ams_b9.quantile([<span class="fl">0.25</span>, <span class="fl">0.75</span>]))</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>&lt;xarray.DataArray (quantile: 2)&gt;
array([   0., 2911.])
Coordinates:
  * quantile  (quantile) float64 0.25 0.75</code></pre>
</div>
<div id="data-tip---numpy-methods" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div id="data-tip---numpy-methods" class="callout-inner">
<h3 class="callout-title">Data Tip - NumPy methods<a class="anchor" aria-label="anchor" href="#data-tip---numpy-methods"></a>
</h3>
<div class="callout-content">
<p>You could also get each of these values one by one using
<code>numpy</code>.</p>
<div class="codewrapper sourceCode" id="cb25">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" tabindex="-1"></a><span class="im">import</span> numpy</span>
<span id="cb25-2"><a href="#cb25-2" tabindex="-1"></a><span class="bu">print</span>(numpy.percentile(raster_ams_b9, <span class="dv">25</span>))</span>
<span id="cb25-3"><a href="#cb25-3" tabindex="-1"></a><span class="bu">print</span>(numpy.percentile(raster_ams_b9, <span class="dv">75</span>))</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code><span><span class="fl">0.0</span></span>
<span><span class="fl">2911.0</span></span></code></pre>
</div>
<p>You may notice that <code>raster_ams_b9.quantile</code> and
<code>numpy.percentile</code> didn’t require an argument specifying the
axis or dimension along which to compute the quantile. This is because
<code>axis=None</code> is the default for most numpy functions, and
therefore <code>dim=None</code> is the default for most xarray methods.
It’s always good to check out the docs on a function to see what the
default arguments are, particularly when working with multi-dimensional
image data. To do so, we can
use<code>help(raster_ams_b9.quantile)</code> or
<code>?raster_ams_b9.percentile</code> if you are using jupyter notebook
or jupyter lab.</p>
</div>
</div>
</div>
</section><section id="dealing-with-missing-data"><h2 class="section-heading">Dealing with Missing Data<a class="anchor" aria-label="anchor" href="#dealing-with-missing-data"></a>
</h2>
<hr class="half-width">
<p>So far, we have visualized a band of a Sentinel-2 scene and
calculated its statistics. However, we need to take missing data into
account. Raster data often has a “no data value” associated with it and
for raster datasets read in by <code>rioxarray</code>. This value is
referred to as <code>nodata</code>. This is a value assigned to pixels
where data is missing or no data were collected. There can be different
cases that cause missing data, and it’s common for other values in a
raster to represent different cases. The most common example is missing
data at the edges of rasters.</p>
<p>By default the shape of a raster is always rectangular. So if we have
a dataset that has a shape that isn’t rectangular, some pixels at the
edge of the raster will have no data values. This often happens when the
data were collected by a sensor which only flew over some part of a
defined region.</p>
<p>As we have seen above, the <code>nodata</code> value of this dataset
(<code>raster_ams_b9.rio.nodata</code>) is 0. When we have plotted the
band data, or calculated statistics, the missing value was not
distinguished from other values. Missing data may cause some unexpected
results. For example, the 25th percentile we just calculated was 0,
probably reflecting the presence of a lot of missing data in the
raster.</p>
<p>To distinguish missing data from real data, one possible way is to
use <code>nan</code> to represent them. This can be done by specifying
<code>masked=True</code> when loading the raster:</p>
<div class="codewrapper sourceCode" id="cb27">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" tabindex="-1"></a>raster_ams_b9 <span class="op">=</span> rioxarray.open_rasterio(items[<span class="dv">0</span>].assets[<span class="st">"nir09"</span>].href, masked<span class="op">=</span><span class="va">True</span>)</span></code></pre>
</div>
<p>One can also use the <code>where</code> function to select all the
pixels which are different from the <code>nodata</code> value of the
raster:</p>
<div class="codewrapper sourceCode" id="cb28">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" tabindex="-1"></a>raster_ams_b9.where(raster_ams_b9<span class="op">!=</span>raster_ams_b9.rio.nodata)</span></code></pre>
</div>
<p>Either way will change the <code>nodata</code> value from 0 to
<code>nan</code>. Now if we compute the statistics again, the missing
data will not be considered:</p>
<pre><code>print(raster_ams_b9.min())
print(raster_ams_b9.max())
print(raster_ams_b9.mean())
print(raster_ams_b9.std())
```python

```output
&lt;xarray.DataArray ()&gt;
array(8., dtype=float32)
Coordinates:
    spatial_ref  int64 0
&lt;xarray.DataArray ()&gt;
array(15497., dtype=float32)
Coordinates:
    spatial_ref  int64 0
&lt;xarray.DataArray ()&gt;
array(2477.405, dtype=float32)
Coordinates:
    spatial_ref  int64 0
&lt;xarray.DataArray ()&gt;
array(2061.9539, dtype=float32)
Coordinates:
    spatial_ref  int64 0</code></pre>
<p>And if we plot the image, the <code>nodata</code> pixels are not
shown because they are not 0 anymore:</p>
<figure><img src="../fig/E06/overview-plot-B09-robust-with-nan.png" alt="raster plot masking missing values" class="figure mx-auto d-block"><div class="figcaption">Raster plot after masking out missing
values</div>
</figure><p>One should notice that there is a side effect of using
<code>nan</code> instead of <code>0</code> to represent the missing
data: the data type of the <code>DataArray</code> was changed from
integers to float. This need to be taken into consideration when the
data type matters in your application.</p>
</section><section id="raster-bands"><h2 class="section-heading">Raster Bands<a class="anchor" aria-label="anchor" href="#raster-bands"></a>
</h2>
<hr class="half-width">
<p>So far we looked into a single band raster, i.e. the
<code>nir09</code> band of a Sentinel-2 scene. However, to get a
smaller, non georeferenced version of the scene, one may also want to
visualize the true-color overview of the region. This is provided as a
multi-band raster – a raster dataset that contains more than one
band.</p>
<figure><img src="../fig/E06/single_multi_raster.png" alt="multi-band raster" class="figure mx-auto d-block"><div class="figcaption">Sketch of a multi-band raster image</div>
</figure><p>The <code>overview</code> asset in the Sentinel-2 scene is a
multiband asset. Similar to <code>nir09</code>, we can load it by:</p>
<div class="codewrapper sourceCode" id="cb30">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" tabindex="-1"></a>raster_ams_overview <span class="op">=</span> rioxarray.open_rasterio(items[<span class="dv">0</span>].assets[<span class="st">'visual'</span>].href, overview_level<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb30-2"><a href="#cb30-2" tabindex="-1"></a>raster_ams_overview</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>&lt;xarray.DataArray (band: 3, y: 687, x: 687)&gt;
[1415907 values with dtype=uint8]
Coordinates:
  * band         (band) int64 1 2 3
  * x            (x) float64 6.001e+05 6.002e+05 ... 7.096e+05 7.097e+05
  * y            (y) float64 5.9e+06 5.9e+06 5.9e+06 ... 5.79e+06 5.79e+06
    spatial_ref  int64 0
Attributes:
    AREA_OR_POINT:       Area
    OVR_RESAMPLING_ALG:  AVERAGE
    _FillValue:          0
    scale_factor:        1.0
    add_offset:          0.0</code></pre>
</div>
<p>The band number comes first when GeoTiffs are read with the
<code>.open_rasterio()</code> function. As we can see in the
<code>xarray.DataArray</code> object, the shape is now
<code>(band: 3, y: 687, x: 687)</code>, with three bands in the
<code>band</code> dimension. It’s always a good idea to examine the
shape of the raster array you are working with and make sure it’s what
you expect. Many functions, especially the ones that plot images, expect
a raster array to have a particular shape. One can also check the shape
using the <code>.shape</code> attribute:</p>
<div class="codewrapper sourceCode" id="cb32">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" tabindex="-1"></a>raster_ams_overview.shape</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>(3, 687, 687)</code></pre>
</div>
<p>One can visualize the multi-band data with the
<code>DataArray.plot.imshow()</code> function:</p>
<div class="codewrapper sourceCode" id="cb34">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" tabindex="-1"></a>raster_ams_overview.plot.imshow()</span></code></pre>
</div>
<figure><img src="../fig/E06/overview-plot-true-color.png" alt="true-color image overview" class="figure mx-auto d-block"><div class="figcaption">Overview of the true-color image (multi-band
raster)</div>
</figure><p>Note that the <code>DataArray.plot.imshow()</code> function makes
assumptions about the shape of the input DataArray, that since it has
three channels, the correct colormap for these channels is RGB. It does
not work directly on image arrays with more than 3 channels. One can
replace one of the RGB channels with another band, to make a false-color
image.</p>
<div id="exercise-set-the-plotting-aspect-ratio" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="exercise-set-the-plotting-aspect-ratio" class="callout-inner">
<h3 class="callout-title">Exercise: set the plotting aspect ratio<a class="anchor" aria-label="anchor" href="#exercise-set-the-plotting-aspect-ratio"></a>
</h3>
<div class="callout-content">
<p>As seen in the figure above, the true-color image is stretched. Let’s
visualize it with the right aspect ratio. You can use the <a href="https://xarray.pydata.org/en/stable/generated/xarray.DataArray.plot.imshow.html" class="external-link">documentation</a>
of <code>DataArray.plot.imshow()</code>.</p>
</div>
</div>
</div>
<div id="accordionSolution2" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution2" aria-expanded="false" aria-controls="collapseSolution2">
  <h4 class="accordion-header" id="headingSolution2">Show me the solution</h4>
</button>
<div id="collapseSolution2" class="accordion-collapse collapse" aria-labelledby="headingSolution2" data-bs-parent="#accordionSolution2">
<div class="accordion-body">
<p>Since we know the height/width ratio is 1:1 (check the
<code>rio.height</code> and <code>rio.width</code> attributes), we can
set the aspect ratio to be 1. For example, we can choose the size to be
5 inches, and set <code>aspect=1</code>. Note that according to the <a href="https://xarray.pydata.org/en/stable/generated/xarray.DataArray.plot.imshow.html" class="external-link">documentation</a>
of <code>DataArray.plot.imshow()</code>, when specifying the
<code>aspect</code> argument, <code>size</code> also needs to be
provided.</p>
<div class="codewrapper sourceCode" id="cb35">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" tabindex="-1"></a>raster_ams_overview.plot.imshow(size<span class="op">=</span><span class="dv">5</span>, aspect<span class="op">=</span><span class="dv">1</span>)</span></code></pre>
</div>
<figure><img src="../fig/E06/overview-plot-true-color-aspect-equal.png" alt="raster plot with correct aspect ratio" class="figure mx-auto d-block"><div class="figcaption">Overview of the true-color image with the
correct aspect ratio</div>
</figure>
</div>
</div>
</div>
</div>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Key Points<a class="anchor" aria-label="anchor" href="#keypoints1"></a>
</h3>
<div class="callout-content">
<ul>
<li>
<code>rioxarray</code> and <code>xarray</code> are for working with
multidimensional arrays like pandas is for working with tabular
data.</li>
<li>
<code>rioxarray</code> stores CRS information as a CRS object that
can be converted to an EPSG code or PROJ4 string.</li>
<li>Missing raster data are filled with nodata values, which should be
handled with care for statistics and visualization.</li>
</ul>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</section></section><section id="aio-07-vector-data-in-python"><p>Content from <a href="07-vector-data-in-python.html">Vector data in Python</a></p>
<hr>
<p>Last updated on 2023-08-14 |
        
        <a href="https://github.com/carpentries-incubator/geospatial-python/edit/main/episodes/07-vector-data-in-python.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<p>Estimated time: <i aria-hidden="true" data-feather="clock"></i> 50 minutes</p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>How can I read, inspect, and process spatial objects, such as
points, lines, and polygons?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Load spatial objects.</li>
<li>Select the spatial objects within a bounding box.</li>
<li>Perform a CRS conversion of spatial objects.</li>
<li>Select features of spatial objects.</li>
<li>Match objects in two datasets based on their spatial
relationships.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<section id="introduction"><h2 class="section-heading">Introduction<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h2>
<hr class="half-width">
<p>As discussed in <a href="02-intro-vector-data.html">Episode 2:
Introduction to Vector Data</a>, vector data represents specific
features on the Earth’s surface using points, lines, and polygons. These
geographic elements can then have one or more attributes assigned to
them, such as ‘name’ and ‘population’ for a city, or crop type for a
field. Vector data can be much smaller in (file) size than raster data,
while being very rich in terms of the information captured.</p>
<p>In this episode, we will be moving from working with raster data to
working with vector data. We will use Python to open and plot point,
line, and polygon vector data. In particular, we will make use of the <a href="https://geopandas.org/en/stable/" class="external-link"><code>geopandas</code></a>
package to open, manipulate and write vector datasets.</p>
<figure><img src="../fig/E07/pandas_geopandas_relation.png" alt="Pandas and Geopandas" class="figure mx-auto d-block"></figure><p><code>geopandas</code> extends the popular <code>pandas</code>
library for data analysis to geospatial applications. The main
<code>pandas</code> objects (the <code>Series</code> and the
<code>DataFrame</code>) are expanded to <code>geopandas</code> objects
(<code>GeoSeries</code> and <code>GeoDataFrame</code>). This extension
is implemented by including geometric types, represented in Python using
the <code>shapely</code> library, and by providing dedicated methods for
spatial operations (union, intersection, etc.). The relationship between
<code>Series</code>, <code>DataFrame</code>, <code>GeoSeries</code> and
<code>GeoDataFrame</code> can be briefly explained as follow:</p>
<ul>
<li>A <code>Series</code> is a one-dimensional array with axis, holding
any data type (integers, strings, floating-point numbers, Python
objects, etc.)</li>
<li>A <code>DataFrame</code> is a two-dimensional labeled data structure
with columns of potentially different types1.</li>
<li>A <code>GeoSeries</code> is a <code>Series</code> object designed to
store shapely geometry objects.</li>
<li>A <code>GeoDataFrame</code> is an extened
<code>pandas.DataFrame</code>, which has a column with geometry objects,
and this column is a <code>GeoSeries</code>.</li>
</ul>
<p>In later episodes, we will learn how to work with raster and vector
data together and combine them into a single plot.</p>
<div id="introduce-the-vector-data" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div id="introduce-the-vector-data" class="callout-inner">
<h3 class="callout-title">Introduce the Vector Data<a class="anchor" aria-label="anchor" href="#introduce-the-vector-data"></a>
</h3>
<div class="callout-content">
<p>In this episode, we will use the downloaded vector data in the
<code>data</code> directory. Please refer to the <a href="index.html#setup">setup page</a> on how to download the data.</p>
</div>
</div>
</div>
</section><section id="import-vector-datasets"><h2 class="section-heading">Import Vector Datasets<a class="anchor" aria-label="anchor" href="#import-vector-datasets"></a>
</h2>
<hr class="half-width">
<div class="codewrapper sourceCode" id="cb1">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="im">import</span> geopandas <span class="im">as</span> gpd</span></code></pre>
</div>
<p>We will use the <code>geopandas</code> package to load the crop field
vector data we downloaded at:
<code>data/brpgewaspercelen_definitief_2020_small.gpkg</code>.</p>
<div class="codewrapper sourceCode" id="cb2">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a>fields <span class="op">=</span> gpd.read_file(<span class="st">"data/brpgewaspercelen_definitief_2020_small.gpkg"</span>)</span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a>fields</span></code></pre>
</div>
<p>The data are read into the variable <code>fields</code> as a
<code>GeoDataFrame</code>. This is an extened data format of
<code>pandas.DataFrame</code>, with an extra column
<code>geometry</code>.</p>
<p>This file contains a relatively large number of crop field parcels.
Directly loading a large file to memory can be slow. If the Area of
Interest (AoI) is small, we can define a bounding box of the AoI, and
only read the data within the extent of the bounding box.</p>
<div class="codewrapper sourceCode" id="cb3">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a><span class="co"># Define bounding box</span></span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a>xmin, xmax <span class="op">=</span> (<span class="dv">110_000</span>, <span class="dv">140_000</span>)</span>
<span id="cb3-3"><a href="#cb3-3" tabindex="-1"></a>ymin, ymax <span class="op">=</span> (<span class="dv">470_000</span>, <span class="dv">510_000</span>)</span>
<span id="cb3-4"><a href="#cb3-4" tabindex="-1"></a>bbox <span class="op">=</span> (xmin, ymin, xmax, ymax)</span></code></pre>
</div>
<p>Using the <code>bbox</code> input argument, we can load only the
spatial features intersecting the provided bounding box.</p>
<div class="codewrapper sourceCode" id="cb4">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a><span class="co"># Partially load data within the bounding box</span></span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a>fields <span class="op">=</span> gpd.read_file(<span class="st">"data/brpgewaspercelen_definitief_2020_small.gpkg"</span>, bbox<span class="op">=</span>bbox)</span></code></pre>
</div>
<div id="how-should-i-define-my-bounding-box" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div id="how-should-i-define-my-bounding-box" class="callout-inner">
<h3 class="callout-title">How should I define my bounding box?<a class="anchor" aria-label="anchor" href="#how-should-i-define-my-bounding-box"></a>
</h3>
<div class="callout-content">
<p>For simplicity, here we assume the <strong>Coordinate Reference
System (CRS)</strong> and <strong>extent</strong> of the vector file are
known (for instance they are provided in the dataset documentation).</p>
<p>You can also define your bounding box with online coordinates
visualization tools. For example, we can use the “Draw Rectangular
Polygon” tool in <a href="https://geojson.io/#map=8.62/52.45/4.96" class="external-link">geojson.io</a>.</p>
<p>Some Python tools, e.g. <a href="https://fiona.readthedocs.io/en/latest/" class="external-link"><code>fiona</code></a>(which
is also the backend of <code>geopandas</code>), provide the file
inspection functionality without the need to read the full data set into
memory. An example can be found in <a href="https://fiona.readthedocs.io/en/latest/manual.html#format-drivers-crs-bounds-and-schema" class="external-link">the
documentation of fiona</a>.</p>
</div>
</div>
</div>
<p>And we can plot the overview by:</p>
<div class="codewrapper sourceCode" id="cb5">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a>fields.plot()</span></code></pre>
</div>
<figure><img src="../fig/E07/fields.png" alt="Crop fields inside the AOI" class="figure mx-auto d-block"></figure></section><section id="vector-metadata-attributes"><h2 class="section-heading">Vector Metadata &amp; Attributes<a class="anchor" aria-label="anchor" href="#vector-metadata-attributes"></a>
</h2>
<hr class="half-width">
<p>When we read the vector dataset with Python (as our
<code>fields</code> variable) it is loaded as a
<code>GeoDataFrame</code> object. The <code>read_file()</code> function
also automatically stores geospatial information about the data. We are
particularly interested in describing the format, CRS, extent, and other
components of the vector data, and the attributes which describe
properties associated with each vector object.</p>
<p>We will explore</p>
<ol style="list-style-type: decimal">
<li>
<strong>Object Type:</strong> the class of the imported object.</li>
<li>
<strong>Coordinate Reference System (CRS):</strong> the projection
of the data.</li>
<li>
<strong>Extent:</strong> the spatial extent (i.e. geographic area
that the data covers). Note that the spatial extent for a vector dataset
represents the combined extent for all spatial objects in the
dataset.</li>
</ol>
<p>Each <code>GeoDataFrame</code> has a <code>"geometry"</code> column
that contains geometries. In the case of our <code>fields</code> object,
this geometry is represented by a <code>shapely.geometry.Polygon</code>
object. <code>geopandas</code> uses the <code>shapely</code> library to
represent polygons, lines, and points, so the types are inherited from
<code>shapely</code>.</p>
<p>We can view the metadata using the <code>.crs</code>,
<code>.bounds</code> and <code>.type</code> attributes. First, let’s
view the geometry type for our crop field dataset. To view the geometry
type, we use the <code>pandas</code> method <code>.type</code> on the
<code>GeoDataFrame</code> object, <code>fields</code>.</p>
<div class="codewrapper sourceCode" id="cb6">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a>fields.<span class="bu">type</span></span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>0        Polygon
1        Polygon
2        Polygon
3        Polygon
4        Polygon
          ...
22026    Polygon
22027    Polygon
22028    Polygon
22029    Polygon
22030    Polygon
Length: 22031, dtype: object</code></pre>
</div>
<p>To view the CRS metadata:</p>
<div class="codewrapper sourceCode" id="cb8">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a>fields.crs</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>&lt;Derived Projected CRS: EPSG:28992&gt;
Name: Amersfoort / RD New
Axis Info [cartesian]:
- X[east]: Easting (metre)
- Y[north]: Northing (metre)
Area of Use:
- name: Netherlands - onshore, including Waddenzee, Dutch Wadden Islands and 12-mile offshore coastal zone.
- bounds: (3.2, 50.75, 7.22, 53.7)
Coordinate Operation:
- name: RD New
- method: Oblique Stereographic
Datum: Amersfoort
- Ellipsoid: Bessel 1841
- Prime Meridian: Greenwich</code></pre>
</div>
<p>Our data is in the CRS <strong>RD New</strong>. The CRS is critical
to interpreting the object’s extent values as it specifies units. To
find the extent of our dataset in the projected coordinates, we can use
the <code>.total_bounds</code> attribute:</p>
<div class="codewrapper sourceCode" id="cb10">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a>fields.total_bounds</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>array([109222.03325 , 469461.512625, 140295.122125, 510939.997875])</code></pre>
</div>
<p>This array contains, in order, the values for minx, miny, maxx and
maxy, for the overall dataset. The spatial extent of a GeoDataFrame
represents the geographic “edge” or location that is the furthest north,
south, east, and west. Thus, it represents the overall geographic
coverage of the spatial object.</p>
<p>We can convert these coordinates to a bounding box or acquire the
index of the Dataframe to access the geometry. Either of these polygons
can be used to clip rasters (more on that later).</p>
</section><section id="further-crop-the-dataset"><h2 class="section-heading">Further crop the dataset<a class="anchor" aria-label="anchor" href="#further-crop-the-dataset"></a>
</h2>
<hr class="half-width">
<p>We might realize that the loaded dataset is still too large. If we
want to refine our area of interest to an even smaller extent, without
reloading the data, we can use the <a href="https://geopandas.org/en/stable/docs/reference/api/geopandas.GeoDataFrame.cx.html" class="external-link"><code>cx</code></a>
indexer:</p>
<div class="codewrapper sourceCode" id="cb12">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a><span class="co"># A smaller bounding box in RD</span></span>
<span id="cb12-2"><a href="#cb12-2" tabindex="-1"></a>xmin, xmax <span class="op">=</span> (<span class="dv">120_000</span>, <span class="dv">135_000</span>)</span>
<span id="cb12-3"><a href="#cb12-3" tabindex="-1"></a>ymin, ymax <span class="op">=</span> (<span class="dv">485_000</span>, <span class="dv">500_000</span>)</span>
<span id="cb12-4"><a href="#cb12-4" tabindex="-1"></a></span>
<span id="cb12-5"><a href="#cb12-5" tabindex="-1"></a>fields_cx <span class="op">=</span> fields.cx[xmin:xmax, ymin:ymax]</span></code></pre>
</div>
</section><section id="export-data-to-file"><h2 class="section-heading">Export data to file<a class="anchor" aria-label="anchor" href="#export-data-to-file"></a>
</h2>
<hr class="half-width">
<p>We will save the cropped results to a shapefile (<code>.shp</code>)
and use it later. The <code>to_file</code> function can be used for
exportation:</p>
<div class="codewrapper sourceCode" id="cb13">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a>fields_cx.to_file(<span class="st">'fields_cropped.shp'</span>)</span></code></pre>
</div>
<p>This will write it to disk (in this case, in ‘shapefile’ format),
containing only the data from our cropped area. It can be read again at
a later time using the <code>read_file()</code> method we have been
using above. Note that this actually writes multiple files to disk
(<code>fields_cropped.cpg</code>, <code>fields_cropped.dbf</code>,
<code>fields_cropped.prj</code>, <code>fields_cropped.shp</code>,
<code>fields_cropped.shx</code>). All these files should ideally be
present in order to re-read the dataset later, although only the
<code>.shp</code>, <code>.shx</code>, and <code>.dbf</code> files are
mandatory (see the <a href="02-intro-vector-data.html">Introduction to
Vector Data</a> lesson for more information.)</p>
</section><section id="selecting-spatial-features"><h2 class="section-heading">Selecting spatial features<a class="anchor" aria-label="anchor" href="#selecting-spatial-features"></a>
</h2>
<hr class="half-width">
<p>From now on, we will take in a point dataset
<code>brogmwvolledigeset.zip</code>, which is the underground water
monitoring wells. We will perform vector processing on this dataset,
together with the cropped field polygons
<code>fields_cropped.shp</code>.</p>
<p>Let’s read the two datasets.</p>
<div class="codewrapper sourceCode" id="cb14">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" tabindex="-1"></a>fields <span class="op">=</span> gpd.read_file(<span class="st">"fields_cropped.shp"</span>)</span>
<span id="cb14-2"><a href="#cb14-2" tabindex="-1"></a>wells <span class="op">=</span> gpd.read_file(<span class="st">"data/brogmwvolledigeset.zip"</span>)</span></code></pre>
</div>
<p>And take a look at the wells:</p>
<div class="codewrapper sourceCode" id="cb15">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" tabindex="-1"></a>wells.plot(markersize<span class="op">=</span><span class="fl">0.1</span>)</span></code></pre>
</div>
<figure><img src="../fig/E07/wells-nl.png" alt="all wells in the NL" class="figure mx-auto d-block"></figure><p>The points represents all the wells over the Netherlands. Since the
wells are in the lat/lon coordinates. To make it comparable with fields,
we need to first transfer the CRS to the “RD New” projection:</p>
<div class="codewrapper sourceCode" id="cb16">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" tabindex="-1"></a>wells <span class="op">=</span> wells.to_crs(epsg<span class="op">=</span><span class="dv">28992</span>)</span></code></pre>
</div>
<p>Now we would like to compare the wells with the cropped fields. We
can select the wells within the fields using the <code>.clip</code>
function:</p>
<div class="codewrapper sourceCode" id="cb17">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" tabindex="-1"></a>wells_clip <span class="op">=</span> wells.clip(fields)</span>
<span id="cb17-2"><a href="#cb17-2" tabindex="-1"></a>wells_clip</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>bro_id delivery_accountable_party quality_regime  ...
40744  GMW000000043703  27364178    IMBRO/A    ...
38728  GMW000000045818  27364178    IMBRO/A    ...
...                ...       ...        ...    ...
40174  GMW000000043963  27364178    IMBRO/A    ...
19445  GMW000000024992  50200097    IMBRO/A    ...
[79 rows x 40 columns]</code></pre>
</div>
<p>After this selection, all the wells outside the fields are dropped.
This takes a while to execute, because we are clipping a relatively
large number of points with many polygons.</p>
<p>If we do not want a precise clipping, but rather have the points in
the neighborhood of the fields, we will need to create another polygon,
which is slightly bigger than the coverage of the field. To do this, we
can increase the size of the field polygons, to make them overlap with
each other, and then merge the overlapping polygons together.</p>
<p>We will first use the <code>buffer</code> function to increase field
size with a given <code>distance</code>. The unit of the
<code>distance</code> argument is the same as the CRS. Here we use a
50-meter buffer. Also notice that the <code>.buffer</code> function
produces a <code>GeoSeries</code>, so to keep the other columns, we
assign it to the <code>GeoDataFrame</code> as a geometry column.</p>
<div class="codewrapper sourceCode" id="cb19">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" tabindex="-1"></a><span class="bu">buffer</span> <span class="op">=</span> fields.<span class="bu">buffer</span>(<span class="dv">50</span>)</span>
<span id="cb19-2"><a href="#cb19-2" tabindex="-1"></a>fields_buffer <span class="op">=</span> fields.copy()</span>
<span id="cb19-3"><a href="#cb19-3" tabindex="-1"></a>fields_buffer[<span class="st">'geometry'</span>] <span class="op">=</span> <span class="bu">buffer</span></span>
<span id="cb19-4"><a href="#cb19-4" tabindex="-1"></a>fields_buffer.plot()</span></code></pre>
</div>
<figure><img src="../fig/E07/fields-buffer.png" alt="50m buffer around the fields" class="figure mx-auto d-block"></figure><p>To further simplify them, we can use the <code>dissolve</code>
function to dissolve the buffers into one:</p>
<div class="codewrapper sourceCode" id="cb20">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" tabindex="-1"></a>fields_buffer_dissolve <span class="op">=</span> fields_buffer.dissolve()</span>
<span id="cb20-2"><a href="#cb20-2" tabindex="-1"></a>fields_buffer_dissolve</span></code></pre>
</div>
<p>All the fields will be dissolved into one multi-polygon, which can be
used to <code>clip</code> the wells.</p>
<div class="codewrapper sourceCode" id="cb21">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" tabindex="-1"></a>wells_clip_buffer <span class="op">=</span> wells.clip(fields_buffer_dissolve)</span>
<span id="cb21-2"><a href="#cb21-2" tabindex="-1"></a>wells_clip_buffer.plot()</span></code></pre>
</div>
<figure><img src="../fig/E07/wells-in-buffer.png" alt="Wells within 50m buffer of fields" class="figure mx-auto d-block"></figure><p>In this way, we selected all wells within the 50m range of the
fields. It is also significantly faster than the previous
<code>clip</code> operation, since the number of polygons is much
smaller after <code>dissolve</code>.</p>
<div id="exercise-clip-fields-within-500m-from-the-wells" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="exercise-clip-fields-within-500m-from-the-wells" class="callout-inner">
<h3 class="callout-title">Exercise: clip fields within 500m from the
wells<a class="anchor" aria-label="anchor" href="#exercise-clip-fields-within-500m-from-the-wells"></a>
</h3>
<div class="callout-content">
<p>This time, we will do a selection the other way around. Can you clip
the field polygons (stored in fields_cropped.shp) with the 500m buffer
of the wells (stored in brogmwvolledigeset.zip)? Please visualize the
results.</p>
<ul>
<li><p>Hint 1: The file <code>brogmwvolledigeset.zip</code> is in CRS
4326. Don’t forget the CRS conversion.</p></li>
<li><p>Hint 2: <code>brogmwvolledigeset.zip</code> contains all the
wells in the Netherlands, which means it might be too big for the
<code>.buffer()</code> function. To improve the performance, first crop
it with the bounding box of the fields.</p></li>
</ul>
</div>
</div>
</div>
<div id="accordionSolution1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution1" aria-expanded="false" aria-controls="collapseSolution1">
  <h4 class="accordion-header" id="headingSolution1">Show me the solution</h4>
</button>
<div id="collapseSolution1" class="accordion-collapse collapse" data-bs-parent="#accordionSolution1" aria-labelledby="headingSolution1">
<div class="accordion-body">
<div class="codewrapper sourceCode" id="cb22">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" tabindex="-1"></a><span class="co"># Read in data</span></span>
<span id="cb22-2"><a href="#cb22-2" tabindex="-1"></a>fields <span class="op">=</span>  gpd.read_file(<span class="st">"fields_cropped.shp"</span>)</span>
<span id="cb22-3"><a href="#cb22-3" tabindex="-1"></a>wells <span class="op">=</span> gpd.read_file(<span class="st">"data/brogmwvolledigeset.zip"</span>)</span>
<span id="cb22-4"><a href="#cb22-4" tabindex="-1"></a></span>
<span id="cb22-5"><a href="#cb22-5" tabindex="-1"></a><span class="co"># Crop points with bounding box</span></span>
<span id="cb22-6"><a href="#cb22-6" tabindex="-1"></a>xmin, ymin, xmax, ymax <span class="op">=</span> fields.total_bounds</span>
<span id="cb22-7"><a href="#cb22-7" tabindex="-1"></a>wells <span class="op">=</span> wells.to_crs(<span class="dv">28992</span>)</span>
<span id="cb22-8"><a href="#cb22-8" tabindex="-1"></a>wells_cx <span class="op">=</span> wells.cx[xmin<span class="op">-</span><span class="dv">500</span>:xmax<span class="op">+</span><span class="dv">500</span>, ymin<span class="op">-</span><span class="dv">500</span>:ymax<span class="op">+</span><span class="dv">500</span>]</span>
<span id="cb22-9"><a href="#cb22-9" tabindex="-1"></a></span>
<span id="cb22-10"><a href="#cb22-10" tabindex="-1"></a><span class="co"># Create buffer</span></span>
<span id="cb22-11"><a href="#cb22-11" tabindex="-1"></a>wells_cx_500mbuffer <span class="op">=</span> wells_cx.copy()</span>
<span id="cb22-12"><a href="#cb22-12" tabindex="-1"></a>wells_cx_500mbuffer[<span class="st">'geometry'</span>] <span class="op">=</span> wells_cx.<span class="bu">buffer</span>(<span class="dv">500</span>)</span>
<span id="cb22-13"><a href="#cb22-13" tabindex="-1"></a></span>
<span id="cb22-14"><a href="#cb22-14" tabindex="-1"></a><span class="co"># Clip</span></span>
<span id="cb22-15"><a href="#cb22-15" tabindex="-1"></a>fields_clip_buffer <span class="op">=</span> fields.clip(wells_cx_500mbuffer)</span>
<span id="cb22-16"><a href="#cb22-16" tabindex="-1"></a>fields_clip_buffer.plot()</span></code></pre>
</div>
<figure><img src="../fig/E07/fields-in-buffer-clip.png" alt="fields within 50m buffer of the wells, truncated" class="figure mx-auto d-block"></figure>
</div>
</div>
</div>
</div>
</section><section id="spatially-join-the-features"><h2 class="section-heading">Spatially join the features<a class="anchor" aria-label="anchor" href="#spatially-join-the-features"></a>
</h2>
<hr class="half-width">
<p>In the exercise, we clipped the fields polygons with the 500m buffers
of wells. The results from this clipping changed the shape of the
polygons. If we would like to keep the original shape of the fields, one
way is to use the <code>sjoin</code> function, which join two
<code>GeoDataFrame</code>’s on the basis of their spatial
relationship:</p>
<div class="codewrapper sourceCode" id="cb23">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" tabindex="-1"></a><span class="co"># Join fields and wells_cx_500mbuffer</span></span>
<span id="cb23-2"><a href="#cb23-2" tabindex="-1"></a>fields_wells_buffer <span class="op">=</span> fields.sjoin(wells_cx_500mbuffer)</span>
<span id="cb23-3"><a href="#cb23-3" tabindex="-1"></a><span class="bu">print</span>(fields_wells_buffer.shape)</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>(11420, 46)</code></pre>
</div>
<p>This will result in a <code>GeodataFrame</code> of all possible
combinations of polygons and well buffers intersecting each other. Since
a polygon can fall into multiple buffers, there will be duplicated field
indexes in the results. To select the fields which intersects the well
buffers, we can first get the unique indexes, and use the
<code>iloc</code> indexer to select:</p>
<div class="codewrapper sourceCode" id="cb25">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" tabindex="-1"></a>idx <span class="op">=</span> fields_wells_buffer.index.unique()</span>
<span id="cb25-2"><a href="#cb25-2" tabindex="-1"></a>fiedls_in_buffer <span class="op">=</span> fields.iloc[idx]</span>
<span id="cb25-3"><a href="#cb25-3" tabindex="-1"></a></span>
<span id="cb25-4"><a href="#cb25-4" tabindex="-1"></a>fiedls_in_buffer.plot()</span></code></pre>
</div>
<figure><img src="../fig/E07/fields-in-buffer-sjoin.png" alt="Fields in 50m buffer of wells, not truncated" class="figure mx-auto d-block"></figure></section><section id="modify-the-geometry-of-a-geodataframe"><h2 class="section-heading">Modify the geometry of a GeoDataFrame<a class="anchor" aria-label="anchor" href="#modify-the-geometry-of-a-geodataframe"></a>
</h2>
<hr class="half-width">
<div id="exercise-investigate-the-waterway-lines" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="exercise-investigate-the-waterway-lines" class="callout-inner">
<h3 class="callout-title">Exercise: Investigate the waterway lines<a class="anchor" aria-label="anchor" href="#exercise-investigate-the-waterway-lines"></a>
</h3>
<div class="callout-content">
<p>Now we will take a deeper look at the Dutch waterway lines:
<code>waterways_nl</code>. Let’s load the file
<code>status_vaarweg.zip</code>, and visualize it with the
<code>plot()</code> function. Can you tell what is wrong with this
vector file?</p>
</div>
</div>
</div>
<div id="accordionSolution2" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution2" aria-expanded="false" aria-controls="collapseSolution2">
  <h4 class="accordion-header" id="headingSolution2">Show me the solution</h4>
</button>
<div id="collapseSolution2" class="accordion-collapse collapse" data-bs-parent="#accordionSolution2" aria-labelledby="headingSolution2">
<div class="accordion-body">
<p>By plotting out the vector file, we can tell that the latitude and
longitude of the file are flipped.</p>
<div class="codewrapper sourceCode" id="cb26">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" tabindex="-1"></a>waterways_nl <span class="op">=</span> gpd.read_file(<span class="st">'data/status_vaarweg.zip'</span>)</span>
<span id="cb26-2"><a href="#cb26-2" tabindex="-1"></a>waterways_nl.plot()</span></code></pre>
</div>
<figure><img src="../fig/E07/waterways-wrong.png" alt="waterways, rotated" class="figure mx-auto d-block"></figure>
</div>
</div>
</div>
</div>
<div id="axis-ordering" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div id="axis-ordering" class="callout-inner">
<h3 class="callout-title">Axis ordering<a class="anchor" aria-label="anchor" href="#axis-ordering"></a>
</h3>
<div class="callout-content">
<p>According to the standards, the axis ordering for a CRS should follow
the definition provided by the competent authority. For the commonly
used EPSG:4326 geographic coordinate system, the EPSG defines the
ordering as first latitude then longitude. However, in the GIS world, it
is custom to work with coordinate tuples where the first component is
aligned with the east/west direction and the second component is aligned
with the north/south direction. Multiple software packages thus
implement this convention also when dealing with EPSG:4326. As a result,
one can encounter vector files that implement either convention - keep
this in mind and always check your datasets!</p>
</div>
</div>
</div>
<p>Sometimes we need to modify the <code>geometry</code> of a
<code>GeoDataFrame</code>. For example, as we have seen in the previous
exercise <strong>Investigate the waterway lines</strong>, the latitude
and longitude are flipped in the vector data <code>waterways_nl</code>.
This error needs to be fixed before performing further analysis.</p>
<p>Let’s first take a look on what makes up the <code>geometry</code>
column of <code>waterways_nl</code>:</p>
<div class="codewrapper sourceCode" id="cb27">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" tabindex="-1"></a>waterways_nl[<span class="st">'geometry'</span>]</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>0     LINESTRING (52.41810 4.84060, 52.42070 4.84090...
1     LINESTRING (52.11910 4.67450, 52.11930 4.67340...
2     LINESTRING (52.10090 4.25730, 52.10390 4.25530...
3     LINESTRING (53.47250 6.84550, 53.47740 6.83840...
4     LINESTRING (52.32270 5.14300, 52.32100 5.14640...
                            ...
86    LINESTRING (51.49270 5.39100, 51.48050 5.39160...
87    LINESTRING (52.15900 5.38510, 52.16010 5.38340...
88    LINESTRING (51.97340 4.12420, 51.97110 4.12220...
89    LINESTRING (52.11910 4.67450, 52.11850 4.67430...
90    LINESTRING (51.88940 4.61900, 51.89040 4.61350...
Name: geometry, Length: 91, dtype: geometry</code></pre>
</div>
<p>Each row is a <code>LINESTRING</code> object. We can further zoom
into one of the rows, for example, the third row:</p>
<div class="codewrapper sourceCode" id="cb29">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" tabindex="-1"></a><span class="bu">print</span>(waterways_nl[<span class="st">'geometry'</span>][<span class="dv">2</span>])</span>
<span id="cb29-2"><a href="#cb29-2" tabindex="-1"></a><span class="bu">print</span>(<span class="bu">type</span>(waterways_nl[<span class="st">'geometry'</span>][<span class="dv">2</span>]))</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>LINESTRING (52.100900002 4.25730000099998, 52.1039 4.25529999999998, 52.111299999 4.24929999900002, 52.1274 4.23449999799999)
&lt;class 'shapely.geometry.linestring.LineString'&gt;</code></pre>
</div>
<p>As we can see in the output, the <code>LINESTRING</code> object
contains a list of coordinates of the vertices. In our situation, we
would like to find a way to flip the x and y of every coordinates set. A
good way to look for the solution is to use the <a href="https://shapely.readthedocs.io/en/stable/manual.html" class="external-link">documentation</a>
of the <code>shapely</code> package, since we are seeking to modify the
<code>LINESTRING</code> object. Here we are going to use the <a href="https://shapely.readthedocs.io/en/stable/manual.html?highlight=shapely.ops.transform#shapely.ops.transform" class="external-link"><code>shapely.ops.transform</code></a>
function, which applies a self-defined function to all coordinates of a
geometry.</p>
<div class="codewrapper sourceCode" id="cb31">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" tabindex="-1"></a><span class="im">import</span> shapely</span>
<span id="cb31-2"><a href="#cb31-2" tabindex="-1"></a></span>
<span id="cb31-3"><a href="#cb31-3" tabindex="-1"></a><span class="co"># Define a function flipping the x and y coordinate values</span></span>
<span id="cb31-4"><a href="#cb31-4" tabindex="-1"></a><span class="kw">def</span> flip(geometry):</span>
<span id="cb31-5"><a href="#cb31-5" tabindex="-1"></a>    <span class="cf">return</span> shapely.ops.transform(<span class="kw">lambda</span> x, y: (y, x), geometry)</span>
<span id="cb31-6"><a href="#cb31-6" tabindex="-1"></a></span>
<span id="cb31-7"><a href="#cb31-7" tabindex="-1"></a><span class="co"># Apply this function to all coordinates and all lines</span></span>
<span id="cb31-8"><a href="#cb31-8" tabindex="-1"></a>geom_corrected <span class="op">=</span> waterways_nl[<span class="st">'geometry'</span>].<span class="bu">apply</span>(flip)</span></code></pre>
</div>
<p>Then we can update the <code>geometry</code> column with the
corrected geometry <code>geom_corrected</code>, and visualize it to
check:</p>
<div class="codewrapper sourceCode" id="cb32">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" tabindex="-1"></a><span class="co"># Update geometry</span></span>
<span id="cb32-2"><a href="#cb32-2" tabindex="-1"></a>waterways_nl[<span class="st">'geometry'</span>] <span class="op">=</span> geom_corrected</span>
<span id="cb32-3"><a href="#cb32-3" tabindex="-1"></a></span>
<span id="cb32-4"><a href="#cb32-4" tabindex="-1"></a><span class="co"># Visualization</span></span>
<span id="cb32-5"><a href="#cb32-5" tabindex="-1"></a>waterways_nl.plot()</span></code></pre>
</div>
<figure><img src="../fig/E07/waterways-corrected.png" alt="waterways, corrected" class="figure mx-auto d-block"></figure><p>Now the waterways look good! We can save the vector data for later
usage:</p>
<div class="codewrapper sourceCode" id="cb33">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" tabindex="-1"></a><span class="co"># Update geometry</span></span>
<span id="cb33-2"><a href="#cb33-2" tabindex="-1"></a>waterways_nl.to_file(<span class="st">'waterways_nl_corrected.shp'</span>)</span></code></pre>
</div>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Key Points<a class="anchor" aria-label="anchor" href="#keypoints1"></a>
</h3>
<div class="callout-content">
<ul>
<li>Load spatial objects into Python with
<code>geopandas.read_file()</code> function.</li>
<li>Spatial objects can be plotted directly with
<code>GeoDataFrame</code>’s <code>.plot()</code> method.</li>
<li>Crop spatial objects with <code>.cx[]</code> indexer.</li>
<li>Convert CRS of spatial objects with <code>.to_crs()</code>.</li>
<li>Select spatial features with <code>.clip()</code>.</li>
<li>Create a buffer of spatial objects with <code>.buffer()</code>.</li>
<li>Merge overlapping spatial objects with
<code>.dissolve()</code>.</li>
<li>Join spatial features spatially with <code>.sjoin()</code>.</li>
</ul>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</section></section><section id="aio-08-crop-raster-data"><p>Content from <a href="08-crop-raster-data.html">Crop raster data with rioxarray and geopandas</a></p>
<hr>
<p>Last updated on 2023-08-14 |
        
        <a href="https://github.com/carpentries-incubator/geospatial-python/edit/main/episodes/08-crop-raster-data.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<p>Estimated time: <i aria-hidden="true" data-feather="clock"></i> 100 minutes</p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>How can I crop my raster data to the area of interest?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Crop raster data with a bounding box.</li>
<li>Crop raster data with a polygon.</li>
<li>Match two raster datasets in different CRS.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<p>It is quite common that the raster data you have in hand is too large
to process, or not all the pixels are relevant to your area of interest
(AoI). In both situations, you should consider cropping your raster data
before performing data analysis.</p>
<p>In this episode, we will introduce how to crop raster data into the
desired area. We will use one Sentinel-2 image over Amsterdam as the
example raster data, and introduce how to crop your data to different
types of AoIs.</p>
<div id="introduce-the-data" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div id="introduce-the-data" class="callout-inner">
<h3 class="callout-title">Introduce the Data<a class="anchor" aria-label="anchor" href="#introduce-the-data"></a>
</h3>
<div class="callout-content">
<p>We will use the results of the satellite image search:
<code>search.json</code>, which is generated in an exercise from <a href="05-access-data.html">Episode 5: Access satellite imagery using
Python</a>.</p>
<p>If you would like to work with the data for this lesson without
downloading data on-the-fly, you can download the raster data using this
<a href="https://figshare.com/ndownloader/files/36028100" class="external-link">link</a>. Save
the <code>geospatial-python-raster-dataset.tar.gz</code> file in your
current working directory, and extract the archive file by
double-clicking on it or by running the following command in your
terminal <code>tar -zxvf geospatial-python-raster-dataset.tar.gz</code>.
Use the file <code>geospatial-python-raster-dataset/search.json</code>
(instead of <code>search.json</code>) to get started with this
lesson.</p>
<p>We also use the cropped fields polygons
<code>fields_cropped.shp</code>, which was generated in an exercise from
<a href="07-vector-data-in-python.html">Episode 7: Vector data in
python</a>.</p>
</div>
</div>
</div>
<section id="align-the-crs-of-the-raster-and-the-vector-data"><h2 class="section-heading">Align the CRS of the raster and the vector data<a class="anchor" aria-label="anchor" href="#align-the-crs-of-the-raster-and-the-vector-data"></a>
</h2>
<hr class="half-width">
<p>We load a true color image using <code>pystac</code> and
<code>rioxarray</code> and check the shape of the raster:</p>
<div class="codewrapper sourceCode" id="cb1">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="im">import</span> pystac</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a><span class="im">import</span> rioxarray</span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a><span class="co"># Load image and inspect the shape</span></span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a>items <span class="op">=</span> pystac.ItemCollection.from_file(<span class="st">"search.json"</span>)</span>
<span id="cb1-6"><a href="#cb1-6" tabindex="-1"></a>raster <span class="op">=</span> rioxarray.open_rasterio(items[<span class="dv">1</span>].assets[<span class="st">"visual"</span>].href) <span class="co"># Select a true color image</span></span>
<span id="cb1-7"><a href="#cb1-7" tabindex="-1"></a><span class="bu">print</span>(raster.shape)</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>(3, 10980, 10980)</code></pre>
</div>
<p>This will perform a “lazy” loading of the image, i.e. the image will
not be loaded into the memory until necessary, but we can still access
some attributes, e.g. the shape of the image.</p>
<p>The large size of the raster data makes it time and memory consuming
to visualize in its entirety. Instead, we can fetch and plot the
overviews of the raster. “Overviews” are precomputed lower resolution
representations of a raster, stored in the same COG that contains the
original raster.</p>
<div class="codewrapper sourceCode" id="cb3">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a><span class="co"># Get the overview asset</span></span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a>raster_overview <span class="op">=</span> rioxarray.open_rasterio(items[<span class="dv">1</span>].assets[<span class="st">"visual"</span>].href, overview_level<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb3-3"><a href="#cb3-3" tabindex="-1"></a><span class="bu">print</span>(raster_overview.shape)</span>
<span id="cb3-4"><a href="#cb3-4" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" tabindex="-1"></a><span class="co"># Visualize it</span></span>
<span id="cb3-6"><a href="#cb3-6" tabindex="-1"></a>raster_overview.plot.imshow(figsize<span class="op">=</span>(<span class="dv">8</span>,<span class="dv">8</span>))</span></code></pre>
</div>
<figure><img src="../fig/E08/crop-raster-overview-raster-00.png" alt="Overview of the raster" class="figure mx-auto d-block"></figure><p>As we can see, the overview image is much smaller compared to the
original true color image.</p>
<p>To align the raster and vector data, we first check each coordinate
system. For raster data, we use <code>pyproj.CRS</code>:</p>
<div class="codewrapper sourceCode" id="cb4">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a><span class="im">from</span> pyproj <span class="im">import</span> CRS</span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" tabindex="-1"></a><span class="co"># Check the coordinate system</span></span>
<span id="cb4-4"><a href="#cb4-4" tabindex="-1"></a>CRS(raster.rio.crs)</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>&lt;Derived Projected CRS: EPSG:32631&gt;
Name: WGS 84 / UTM zone 31N
Axis Info [cartesian]:
- [east]: Easting (metre)
- [north]: Northing (metre)
Area of Use:
- undefined
Coordinate Operation:
- name: UTM zone 31N
- method: Transverse Mercator
Datum: World Geodetic System 1984
- Ellipsoid: WGS 84
- Prime Meridian: Greenwich</code></pre>
</div>
<p>To open and check the coordinate system of vector data, we use
<code>geopandas</code>:</p>
<div class="codewrapper sourceCode" id="cb6">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a><span class="im">import</span> geopandas <span class="im">as</span> gpd</span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" tabindex="-1"></a><span class="co"># Load the polygons of the crop fields</span></span>
<span id="cb6-4"><a href="#cb6-4" tabindex="-1"></a>fields <span class="op">=</span> gpd.read_file(<span class="st">"fields_cropped.shp"</span>)</span>
<span id="cb6-5"><a href="#cb6-5" tabindex="-1"></a></span>
<span id="cb6-6"><a href="#cb6-6" tabindex="-1"></a><span class="co"># Check the coordinate system</span></span>
<span id="cb6-7"><a href="#cb6-7" tabindex="-1"></a>fields.crs</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>&lt;Derived Projected CRS: EPSG:28992&gt;
Name: Amersfoort / RD New
Axis Info [cartesian]:
- X[east]: Easting (metre)
- Y[north]: Northing (metre)
Area of Use:
- name: Netherlands - onshore, including Waddenzee, Dutch Wadden Islands and 12-mile offshore coastal zone.
- bounds: (3.2, 50.75, 7.22, 53.7)
Coordinate Operation:
- name: RD New
- method: Oblique Stereographic
Datum: Amersfoort
- Ellipsoid: Bessel 1841
- Prime Meridian: Greenwich</code></pre>
</div>
<p>As seen, the coordinate systems differ. To crop the raster using the
shapefile, we first need to reproject one dataset to the other’s CRS.
Since <code>raster</code> is large, we will convert the CRS of
<code>fields</code> to the CRS of <code>raster</code> to avoid loading
the entire image:</p>
<div class="codewrapper sourceCode" id="cb8">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a>fields <span class="op">=</span> fields.to_crs(raster.rio.crs)</span></code></pre>
</div>
</section><section id="crop-raster-data-with-a-bounding-box"><h2 class="section-heading">Crop raster data with a bounding box<a class="anchor" aria-label="anchor" href="#crop-raster-data-with-a-bounding-box"></a>
</h2>
<hr class="half-width">
<p>The <code>clip_box</code> function allows one to crop a raster by the
min/max of the x and y coordinates. Note that we are cropping the
original image <code>raster</code> now, and not the overview image
<code>raster_overview</code>.</p>
<div class="codewrapper sourceCode" id="cb9">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a><span class="co"># Crop the raster with the bounding box</span></span>
<span id="cb9-2"><a href="#cb9-2" tabindex="-1"></a>raster_clip_box <span class="op">=</span> raster.rio.clip_box(<span class="op">*</span>fields.total_bounds)</span>
<span id="cb9-3"><a href="#cb9-3" tabindex="-1"></a><span class="bu">print</span>(raster_clip_box.shape)</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>(3, 1565, 1565)</code></pre>
</div>
<p>We successfully cropped the raster to a much smaller piece. We can
visualize it now:</p>
<div class="codewrapper sourceCode" id="cb11">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a>raster_clip_box.plot.imshow(figsize<span class="op">=</span>(<span class="dv">8</span>,<span class="dv">8</span>))</span></code></pre>
</div>
<figure><img src="../fig/E08/crop-raster-crop-by-bb-02.png" alt="Raster cropped by a bounding box" class="figure mx-auto d-block"></figure><p>This cropped image can be saved for later usage:</p>
<div class="codewrapper sourceCode" id="cb12">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a>raster_clip_box.rio.to_raster(<span class="st">"raster_clip.tif"</span>)</span></code></pre>
</div>
</section><section id="crop-raster-data-with-polygons"><h2 class="section-heading">Crop raster data with polygons<a class="anchor" aria-label="anchor" href="#crop-raster-data-with-polygons"></a>
</h2>
<hr class="half-width">
<p>We have a cropped image around the fields. To further analyze the
fields, one may want to crop the image to the exact field boundaries.
This can be done with the <code>clip</code> function:</p>
<div class="codewrapper sourceCode" id="cb13">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a>raster_clip_fields <span class="op">=</span> raster_clip_box.rio.clip(fields[<span class="st">'geometry'</span>])</span></code></pre>
</div>
<p>And we can visualize the results:</p>
<div class="codewrapper sourceCode" id="cb14">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" tabindex="-1"></a>raster_clip_fields.plot.imshow(figsize<span class="op">=</span>(<span class="dv">8</span>,<span class="dv">8</span>))</span></code></pre>
</div>
<figure><img src="../fig/E08/crop-raster-crop-fields.png" alt="Ratser cropped by field polygons" class="figure mx-auto d-block"></figure><div id="exercise-crop-raster-data-with-a-specific-code" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="exercise-crop-raster-data-with-a-specific-code" class="callout-inner">
<h3 class="callout-title">Exercise: crop raster data with a specific
code<a class="anchor" aria-label="anchor" href="#exercise-crop-raster-data-with-a-specific-code"></a>
</h3>
<div class="callout-content">
<p>In the column “gewascode” (translated as “crop code”) of
<code>fields</code>, you can find the code representing the types of
plants grown in each field. Can you:</p>
<ol style="list-style-type: decimal">
<li>Select the fields with “gewascode” equal to <code>257</code>;</li>
<li>Crop the raster <code>raster_clip_box</code> with the selected
fields;</li>
<li>Visualize the cropped image.</li>
</ol>
</div>
</div>
</div>
<div id="accordionSolution1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution1" aria-expanded="false" aria-controls="collapseSolution1">
  <h4 class="accordion-header" id="headingSolution1">Show me the solution</h4>
</button>
<div id="collapseSolution1" class="accordion-collapse collapse" aria-labelledby="headingSolution1" data-bs-parent="#accordionSolution1">
<div class="accordion-body">
<div class="codewrapper sourceCode" id="cb15">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" tabindex="-1"></a>mask <span class="op">=</span> fields[<span class="st">'gewascode'</span>]<span class="op">==</span><span class="dv">257</span></span>
<span id="cb15-2"><a href="#cb15-2" tabindex="-1"></a>fields_gwascode <span class="op">=</span> fields.where(mask)</span>
<span id="cb15-3"><a href="#cb15-3" tabindex="-1"></a>fields_gwascode <span class="op">=</span> fields_gwascode.dropna()</span>
<span id="cb15-4"><a href="#cb15-4" tabindex="-1"></a>raster_clip_fields_gwascode <span class="op">=</span> raster_clip_box.rio.clip(fields_gwascode[<span class="st">'geometry'</span>])</span>
<span id="cb15-5"><a href="#cb15-5" tabindex="-1"></a>raster_clip_fields_gwascode.plot.imshow(figsize<span class="op">=</span>(<span class="dv">8</span>,<span class="dv">8</span>))</span></code></pre>
</div>
<figure><img src="../fig/E08/crop-raster-fields-gewascode.png" alt="Raster croped by fields with gewascode 257" class="figure mx-auto d-block"></figure>
</div>
</div>
</div>
</div>
</section><section id="crop-raster-data-using-reproject_match-function"><h2 class="section-heading">Crop raster data using <code>reproject_match()</code> function<a class="anchor" aria-label="anchor" href="#crop-raster-data-using-reproject_match-function"></a>
</h2>
<hr class="half-width">
<p>So far we have learned how to crop raster images with vector data. We
can also crop a raster with another raster data. In this section, we
will demonstrate how to crop the <code>raster_clip_box</code> image
using the <code>raster_clip_fields_gwascode</code> image. We will use
the <code>reproject_match</code> function. As indicated by its name, it
performs reprojection and clipping in one go.</p>
<p>To demonstrate the reprojection, we will first reproject
<code>raster_clip_fields_gwascode</code> to the RD CRS system, so it
will be in a different CRS from <code>raster_clip_box</code>:</p>
<div class="codewrapper sourceCode" id="cb16">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" tabindex="-1"></a><span class="co"># Reproject to RD to make the CRS different from the "raster"</span></span>
<span id="cb16-2"><a href="#cb16-2" tabindex="-1"></a>raster_clip_fields_gwascode <span class="op">=</span> raster_clip_fields_gwascode.rio.reproject(<span class="st">"EPSG:28992"</span>)</span>
<span id="cb16-3"><a href="#cb16-3" tabindex="-1"></a>CRS(raster_clip_fields_gwascode.rio.crs)</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>&lt;Derived Projected CRS: EPSG:28992&gt;
Name: Amersfoort / RD New
Axis Info [cartesian]:
- [east]: Easting (metre)
- [north]: Northing (metre)
Area of Use:
- undefined
Coordinate Operation:
- name: unnamed
- method: Oblique Stereographic
Datum: Amersfoort
- Ellipsoid: Bessel 1841
- Prime Meridian: Greenwich</code></pre>
</div>
<p>And let’s check again the CRS of <code>raster_clip_box</code>:</p>
<div class="codewrapper sourceCode" id="cb18">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" tabindex="-1"></a>CRS(raster_clip_box.rio.crs)</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>&lt;Derived Projected CRS: EPSG:32631&gt;
Name: WGS 84 / UTM zone 31N
Axis Info [cartesian]:
- [east]: Easting (metre)
- [north]: Northing (metre)
Area of Use:
- undefined
Coordinate Operation:
- name: UTM zone 31N
- method: Transverse Mercator
Datum: World Geodetic System 1984
- Ellipsoid: WGS 84
- Prime Meridian: Greenwich</code></pre>
</div>
<p>Now the two images are in different coordinate systems. We can use
<code>rioxarray.reproject_match()</code> function to crop
<code>raster_clip_box</code> image.</p>
<div class="codewrapper sourceCode" id="cb20">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" tabindex="-1"></a>raster_reproject_match <span class="op">=</span> raster_clip_box.rio.reproject_match(raster_clip_fields_gwascode)</span>
<span id="cb20-2"><a href="#cb20-2" tabindex="-1"></a>raster_reproject_match.plot.imshow(figsize<span class="op">=</span>(<span class="dv">8</span>,<span class="dv">8</span>))</span></code></pre>
</div>
<figure><img src="../fig/E08/reprojectmatch-big-to-small.png" alt="Reproject match big to small" class="figure mx-auto d-block"></figure><p>We can also use it to expand <code>raster_clip_fields_gwascode</code>
to the extent of <code>raster_clip_box</code>:</p>
<div class="codewrapper sourceCode" id="cb21">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" tabindex="-1"></a>raster_reproject_match <span class="op">=</span> raster_clip_fields_gwascode.rio.reproject_match(raster_clip_box)</span>
<span id="cb21-2"><a href="#cb21-2" tabindex="-1"></a>raster_reproject_match.plot.imshow(figsize<span class="op">=</span>(<span class="dv">8</span>,<span class="dv">8</span>))</span></code></pre>
</div>
<figure><img src="../fig/E08/reprojectmatch-small-to-big.png" alt="Reproject match small to big" class="figure mx-auto d-block"></figure><p>In one line <code>reproject_match</code> does a lot of helpful
things:</p>
<ol style="list-style-type: decimal">
<li>It reprojects.</li>
<li>It matches the extent using <code>nodata</code> values or by
clipping the data.</li>
<li>It sets <code>nodata</code> values. This means we can run
calculations on those two images.</li>
</ol>
<div id="code-tip" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div id="code-tip" class="callout-inner">
<h3 class="callout-title">Code Tip<a class="anchor" aria-label="anchor" href="#code-tip"></a>
</h3>
<div class="callout-content">
<p>As we saw before, there also exists a method called
<code>reproject()</code>, which only reprojects one raster to another
projection. If you want more control over how rasters are resampled,
clipped, and/or reprojected, you can use the <code>reproject()</code>
method and other <code>rioxarray</code> methods individually.</p>
</div>
</div>
</div>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Key Points<a class="anchor" aria-label="anchor" href="#keypoints1"></a>
</h3>
<div class="callout-content">
<ul>
<li>Use <code>clip_box</code> to crop a raster with a bounding box.</li>
<li>Use <code>clip</code> to crop a raster with a given polygon.</li>
<li>Use <code>reproject_match</code> to match two raster datasets.</li>
</ul>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</section></section><section id="aio-09-raster-calculations"><p>Content from <a href="09-raster-calculations.html">Raster Calculations in Python</a></p>
<hr>
<p>Last updated on 2023-08-14 |
        
        <a href="https://github.com/carpentries-incubator/geospatial-python/edit/main/episodes/09-raster-calculations.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<p>Estimated time: <i aria-hidden="true" data-feather="clock"></i> 75 minutes</p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>How do I perform calculations on rasters and extract pixel values
for defined locations?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Carry out operations with two rasters using Python’s built-in math
operators.</li>
<li>Reclassify a continuous raster to a categorical raster.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<section id="introduction"><h2 class="section-heading">Introduction<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h2>
<hr class="half-width">
<p>We often want to combine values of and perform calculations on
rasters to create a new output raster. This episode covers how to
perform basic math operations using raster datasets. It also illustrates
how to match rasters with different resolutions so that they can be used
in the same calculation. As an example, we will calculate a vegetation
index over one of the satellite scenes.</p>
<div class="section level3">
<h3 id="normalized-difference-vegetation-index-ndvi">Normalized Difference Vegetation Index (NDVI)<a class="anchor" aria-label="anchor" href="#normalized-difference-vegetation-index-ndvi"></a>
</h3>
<p>Suppose we are interested in monitoring vegetation fluctuations using
satellite remote sensors. Scientists have defined a vegetation index to
quantify the amount of green leaf vegetation using the light reflected
in different wavelengths. This index, named Normalized Difference
Vegetation Index (NDVI), exploits the fact that healthy green leaves
strongly absorb red visible light while they mostly reflect light in the
near infrared (NIR). The NDVI is computed as:</p>
<p><span class="math display">\[ NDVI = \frac{NIR - red}{NIR + red}
\]</span></p>
<p>where <span class="math inline">\(NIR\)</span> and <span class="math inline">\(red\)</span> label the reflectance values of the
corresponding wavelengths. NDVI values range from -1 to +1. Values close
to one indicate high density of green leaves. Poorly vegetated areas
typically have NDVI values close to zero. Negative NDVI values often
indicate cloud and water bodies.</p>
<figure><img src="../fig/E09/PONE-NDVI.jpg" alt="PONE-NDVI image" class="figure mx-auto d-block"><div class="figcaption">Source: Wu C-D, McNeely E, Cedeño-Laurent JG,
Pan W-C, Adamkiewicz G, Dominici F, et al. (2014) Linking Student
Performance in Massachusetts Elementary Schools with the “Greenness” of
School Surroundings Using Remote Sensing. PLoS ONE 9(10): e108548. <a href="https://doi.org/10.1371/journal.pone.0108548" class="external-link uri">https://doi.org/10.1371/journal.pone.0108548</a>
</div>
</figure><div id="more-resources" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div id="more-resources" class="callout-inner">
<h3 class="callout-title">More Resources<a class="anchor" aria-label="anchor" href="#more-resources"></a>
</h3>
<div class="callout-content">
<p>Check out more on NDVI in the NASA Earth Observatory portal: <a href="https://earthobservatory.nasa.gov/features/MeasuringVegetation/measuring_vegetation_2.php" class="external-link">Measuring
Vegetation</a>.</p>
</div>
</div>
</div>
</div>
<div class="section level3">
<h3 id="load-and-crop-the-data">Load and crop the Data<a class="anchor" aria-label="anchor" href="#load-and-crop-the-data"></a>
</h3>
<p>For this episode, we will use one of the Sentinel-2 scenes that we
have already employed in the previous episodes.</p>
<div id="introduce-the-data" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div id="introduce-the-data" class="callout-inner">
<h3 class="callout-title">Introduce the Data<a class="anchor" aria-label="anchor" href="#introduce-the-data"></a>
</h3>
<div class="callout-content">
<p>We’ll continue from the results of the satellite image search that we
have carried out in an exercise from <a href="05-access-data.html">a
previous episode</a>. We will load data starting from the
<code>search.json</code> file.</p>
<p>If you would like to work with the data for this lesson without
downloading data on-the-fly, you can download the raster data using this
<a href="https://figshare.com/ndownloader/files/36028100" class="external-link">link</a>. Save
the <code>geospatial-python-raster-dataset.tar.gz</code> file in your
current working directory, and extract the archive file by
double-clicking on it or by running the following command in your
terminal <code>tar -zxvf geospatial-python-raster-dataset.tar.gz</code>.
Use the file <code>geospatial-python-raster-dataset/search.json</code>
(instead of <code>search.json</code>) to get started with this
lesson.</p>
</div>
</div>
</div>
<p>Let’s load the results of our initial imagery search using
<code>pystac</code>:</p>
<div class="codewrapper sourceCode" id="cb1">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="im">import</span> pystac</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a>items <span class="op">=</span> pystac.ItemCollection.from_file(<span class="st">"search.json"</span>)</span></code></pre>
</div>
<p>We then select the second item, and extract the URIs of the red and
NIR bands (“red” and “nir08”, respectively):</p>
<div class="codewrapper sourceCode" id="cb2">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a>red_uri <span class="op">=</span> items[<span class="dv">1</span>].assets[<span class="st">"red"</span>].href</span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a>nir_uri <span class="op">=</span> items[<span class="dv">1</span>].assets[<span class="st">"nir08"</span>].href</span></code></pre>
</div>
<p>Let’s load the rasters with <code>open_rasterio</code> using the
argument <code>masked=True</code>.</p>
<div class="codewrapper sourceCode" id="cb3">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a><span class="im">import</span> rioxarray</span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a>red <span class="op">=</span> rioxarray.open_rasterio(red_uri, masked<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb3-3"><a href="#cb3-3" tabindex="-1"></a>nir <span class="op">=</span> rioxarray.open_rasterio(nir_uri, masked<span class="op">=</span><span class="va">True</span>)</span></code></pre>
</div>
<p>Let’s also restrict our analysis to the same crop field area defined
in the previous episode by clipping the rasters using a bounding
box:</p>
<div class="codewrapper sourceCode" id="cb4">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a>bbox <span class="op">=</span> (<span class="dv">629_000</span>, <span class="dv">5_804_000</span>, <span class="dv">639_000</span>, <span class="dv">5_814_000</span>)</span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a>red_clip <span class="op">=</span> red.rio.clip_box(<span class="op">*</span>bbox)</span>
<span id="cb4-3"><a href="#cb4-3" tabindex="-1"></a>nir_clip <span class="op">=</span> nir.rio.clip_box(<span class="op">*</span>bbox)</span></code></pre>
</div>
<p>We can now plot the two rasters. Using <code>robust=True</code> color
values are stretched between the 2nd and 98th percentiles of the data,
which results in clearer distinctions between high and low
reflectances:</p>
<div class="codewrapper sourceCode" id="cb5">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a>red_clip.plot(robust<span class="op">=</span><span class="va">True</span>)</span></code></pre>
</div>
<figure><img src="../fig/E09/red-band.png" alt="red band image" class="figure mx-auto d-block"></figure><div class="codewrapper sourceCode" id="cb6">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a>nir_clip.plot(robust<span class="op">=</span><span class="va">True</span>)</span></code></pre>
</div>
<figure><img src="../fig/E09/NIR-band.png" alt="near infra-red band image" class="figure mx-auto d-block"></figure><p>It is immediately evident how crop fields (rectangular shapes in the
central part of the two figures) appear as dark and bright spots in the
red-visible and NIR wavelengths, respectively, suggesting the presence
of leafy crop at the time of observation (end of March). The same fields
would instead appear as dark spots in the off season.</p>
</div>
</section><section id="raster-math"><h2 class="section-heading">Raster Math<a class="anchor" aria-label="anchor" href="#raster-math"></a>
</h2>
<hr class="half-width">
<p>We can perform raster calculations by subtracting (or adding,
multiplying, etc.) two rasters. In the geospatial world, we call this
“raster math”, and typically it refers to operations on rasters that
have the same width and height (including <code>nodata</code> pixels).
We can check the shapes of the two rasters in the following way:</p>
<div class="codewrapper sourceCode" id="cb7">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a><span class="bu">print</span>(red_clip.shape, nir_clip.shape)</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>(1, 1000, 1000) (1, 500, 500)</code></pre>
</div>
<p>Both rasters include a single band, but their width and height do not
match. We can now use the <code>reproject_match</code> function, which
both reprojects and clips a raster to the CRS and extent of another
raster.</p>
<div class="codewrapper sourceCode" id="cb9">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a>red_clip_matched <span class="op">=</span> red_clip.rio.reproject_match(nir_clip)</span>
<span id="cb9-2"><a href="#cb9-2" tabindex="-1"></a><span class="bu">print</span>(red_clip_matched.shape)</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>(1, 500, 500)</code></pre>
</div>
<p>Let’s now compute the NDVI as a new raster using the formula
presented above. We’ll use <code>rioxarray</code> objects so that we can
easily plot our result and keep track of the metadata.</p>
<div class="codewrapper sourceCode" id="cb11">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a>ndvi <span class="op">=</span> (nir_clip <span class="op">-</span> red_clip_matched)<span class="op">/</span> (nir_clip <span class="op">+</span> red_clip_matched)</span>
<span id="cb11-2"><a href="#cb11-2" tabindex="-1"></a><span class="bu">print</span>(ndvi)</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>&lt;xarray.DataArray (band: 1, y: 500, x: 500)&gt;
array([[[ 0.7379576 ,  0.77153456,  0.54531944, ...,  0.39254385,
          0.49227372,  0.4465174 ],
        [ 0.7024894 ,  0.7074668 ,  0.3903298 , ...,  0.423283  ,
          0.4706971 ,  0.45964912],
        [ 0.6557818 ,  0.5610572 ,  0.46742022, ...,  0.4510345 ,
          0.43815723,  0.6005133 ],
        ...,
        [ 0.02391171,  0.21843003,  0.02479339, ..., -0.50923485,
         -0.53367877, -0.4955414 ],
        [ 0.11376493,  0.17681159, -0.1673566 , ..., -0.5221932 ,
         -0.5271318 , -0.4852753 ],
        [ 0.45398772, -0.00518135,  0.03346133, ..., -0.5019455 ,
         -0.4987013 , -0.49081364]]], dtype=float32)
Coordinates:
  * band         (band) int64 1
  * x            (x) float64 6.29e+05 6.29e+05 6.29e+05 ... 6.39e+05 6.39e+05
  * y            (y) float64 5.814e+06 5.814e+06 ... 5.804e+06 5.804e+06
    spatial_ref  int64 0</code></pre>
</div>
<p>We can now plot the output NDVI:</p>
<div class="codewrapper sourceCode" id="cb13">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a>ndvi.plot()</span></code></pre>
</div>
<figure><img src="../fig/E09/NDVI-map.png" alt="NDVI map" class="figure mx-auto d-block"></figure><p>Notice that the range of values for the output NDVI is between -1 and
1. Does this make sense for the selected region?</p>
<p>Maps are great, but it can also be informative to plot histograms of
values to better understand the distribution. We can accomplish this
using a built-in xarray method we have already been using:
<code>plot</code></p>
<div class="codewrapper sourceCode" id="cb14">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" tabindex="-1"></a>ndvi.plot.hist()</span></code></pre>
</div>
<figure><img src="../fig/E09/NDVI-hist.png" alt="NDVI histogram" class="figure mx-auto d-block"></figure><div id="exercise-explore-ndvi-raster-values" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="exercise-explore-ndvi-raster-values" class="callout-inner">
<h3 class="callout-title">Exercise: Explore NDVI Raster Values<a class="anchor" aria-label="anchor" href="#exercise-explore-ndvi-raster-values"></a>
</h3>
<div class="callout-content">
<p>It’s often a good idea to explore the range of values in a raster
dataset just like we might explore a dataset that we collected in the
field. The histogram we just made is a good start but there’s more we
can do to improve our understanding of the data.</p>
<ol style="list-style-type: decimal">
<li>What is the min and maximum value for the NDVI raster
(<code>ndvi</code>) that we just created? Are there missing values?</li>
<li>Plot a histogram with 50 bins instead of 8. What do you notice that
wasn’t clear before?</li>
<li>Plot the <code>ndvi</code> raster using breaks that make sense for
the data.</li>
</ol>
</div>
</div>
</div>
<div id="accordionSolution1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution1" aria-expanded="false" aria-controls="collapseSolution1">
  <h4 class="accordion-header" id="headingSolution1">Show me the solution</h4>
</button>
<div id="collapseSolution1" class="accordion-collapse collapse" aria-labelledby="headingSolution1" data-bs-parent="#accordionSolution1">
<div class="accordion-body">
<ol style="list-style-type: decimal">
<li>Recall, if there were nodata values in our raster, we would need to
filter them out with <code>.where()</code>. Since we have loaded the
rasters with <code>masked=True</code>, missing values are already
encoded as <code>np.nan</code>’s. The <code>ndvi</code> array actually
includes a single missing value.</li>
</ol>
<div class="codewrapper sourceCode" id="cb15">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" tabindex="-1"></a><span class="bu">print</span>(ndvi.<span class="bu">min</span>().values)</span>
<span id="cb15-2"><a href="#cb15-2" tabindex="-1"></a><span class="bu">print</span>(ndvi.<span class="bu">max</span>().values)</span>
<span id="cb15-3"><a href="#cb15-3" tabindex="-1"></a><span class="bu">print</span>(ndvi.isnull().<span class="bu">sum</span>().values)</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code><span><span class="op">-</span><span class="fl">0.99864775</span></span>
<span><span class="fl">0.9995788</span></span>
<span><span class="fl">1</span></span></code></pre>
</div>
<ol start="2" style="list-style-type: decimal">
<li>Increasing the number of bins gives us a much clearer view of the
distribution. Also, there seem to be very few NDVI values larger than
~0.9.</li>
</ol>
<div class="codewrapper sourceCode" id="cb17">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" tabindex="-1"></a>ndvi.plot.hist(bins<span class="op">=</span><span class="dv">50</span>)</span></code></pre>
</div>
<figure><img src="../fig/E09/NDVI-hist-bins.png" alt="NDVI histogram with 50 bins" class="figure mx-auto d-block"></figure><ol start="3" style="list-style-type: decimal">
<li>We can discretize the color bar by specifying the intervals via the
<code>levels</code> argument to <code>plot()</code>. Suppose we want to
bin our data in the following intervals:</li>
</ol>
<ul>
<li>
<span class="math inline">\(-1 \le NDVI \lt 0\)</span> for
water;</li>
<li>
<span class="math inline">\(0 \le NDVI \lt 0.2\)</span> for no
vegetation;</li>
<li>
<span class="math inline">\(0.2 \le NDVI \lt 0.7\)</span> for sparse
vegetation;</li>
<li>
<span class="math inline">\(0.7 \le NDVI \lt 1\)</span> for dense
vegetation.</li>
</ul>
<div class="codewrapper sourceCode" id="cb18">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" tabindex="-1"></a>class_bins <span class="op">=</span> (<span class="op">-</span><span class="dv">1</span>, <span class="fl">0.</span>, <span class="fl">0.2</span>, <span class="fl">0.7</span>, <span class="dv">1</span>)</span>
<span id="cb18-2"><a href="#cb18-2" tabindex="-1"></a>ndvi.plot(levels<span class="op">=</span>class_bins)</span></code></pre>
</div>
<figure><img src="../fig/E09/NDVI-map-binned.png" alt="binned NDVI map" class="figure mx-auto d-block"></figure>
</div>
</div>
</div>
</div>
<p>Missing values can be interpolated from the values of neighbouring
grid cells using the <code>.interpolate_na</code> method. We then save
<code>ndvi</code> as a GeoTiff file:</p>
<div class="codewrapper sourceCode" id="cb19">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" tabindex="-1"></a>ndvi_nonan <span class="op">=</span> ndvi.interpolate_na(dim<span class="op">=</span><span class="st">"x"</span>)</span>
<span id="cb19-2"><a href="#cb19-2" tabindex="-1"></a>ndvi_nonan.rio.to_raster(<span class="st">"NDVI.tif"</span>)</span></code></pre>
</div>
</section><section id="classifying-continuous-rasters-in-python"><h2 class="section-heading">Classifying Continuous Rasters in Python<a class="anchor" aria-label="anchor" href="#classifying-continuous-rasters-in-python"></a>
</h2>
<hr class="half-width">
<p>Now that we have a sense of the distribution of our NDVI raster, we
can reduce the complexity of our map by classifying it. Classification
involves assigning each pixel in the raster to a class based on its
value. In Python, we can accomplish this using the
<code>numpy.digitize</code> function.</p>
<p>First, we define NDVI classes based on a list of values, as defined
in the last exercise: <code>[-1, 0., 0.2, 0.7, 1]</code>. When bins are
ordered from low to high, as here, <code>numpy.digitize</code> assigns
classes like so:</p>
<figure><img src="../fig/E09/NDVI-classes.jpg" alt="NDVI classes" class="figure mx-auto d-block"><div class="figcaption">Source: Image created for this lesson (<a href="LICENSE.html">license</a>)</div>
</figure><p>Note that, by default, each class includes the left but not the right
bound. This is not an issue here, since the computed range of NDVI
values is fully contained in the open interval (-1; 1) (see exercise
above).</p>
<div class="codewrapper sourceCode" id="cb20">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb20-2"><a href="#cb20-2" tabindex="-1"></a><span class="im">import</span> xarray</span>
<span id="cb20-3"><a href="#cb20-3" tabindex="-1"></a></span>
<span id="cb20-4"><a href="#cb20-4" tabindex="-1"></a><span class="co"># Defines the bins for pixel values</span></span>
<span id="cb20-5"><a href="#cb20-5" tabindex="-1"></a>class_bins <span class="op">=</span> (<span class="op">-</span><span class="dv">1</span>, <span class="fl">0.</span>, <span class="fl">0.2</span>, <span class="fl">0.7</span>, <span class="dv">1</span>)</span>
<span id="cb20-6"><a href="#cb20-6" tabindex="-1"></a></span>
<span id="cb20-7"><a href="#cb20-7" tabindex="-1"></a><span class="co"># The numpy.digitize function returns an unlabeled array, in this case, a</span></span>
<span id="cb20-8"><a href="#cb20-8" tabindex="-1"></a><span class="co"># classified array without any metadata. That doesn't work--we need the</span></span>
<span id="cb20-9"><a href="#cb20-9" tabindex="-1"></a><span class="co"># coordinates and other spatial metadata. We can get around this using</span></span>
<span id="cb20-10"><a href="#cb20-10" tabindex="-1"></a><span class="co"># xarray.apply_ufunc, which can run the function across the data array while</span></span>
<span id="cb20-11"><a href="#cb20-11" tabindex="-1"></a><span class="co"># preserving metadata.</span></span>
<span id="cb20-12"><a href="#cb20-12" tabindex="-1"></a>ndvi_classified <span class="op">=</span> xarray.apply_ufunc(</span>
<span id="cb20-13"><a href="#cb20-13" tabindex="-1"></a>    np.digitize,</span>
<span id="cb20-14"><a href="#cb20-14" tabindex="-1"></a>    ndvi_nonan,</span>
<span id="cb20-15"><a href="#cb20-15" tabindex="-1"></a>    class_bins</span>
<span id="cb20-16"><a href="#cb20-16" tabindex="-1"></a>)</span></code></pre>
</div>
<p>Let’s now visualize the classified NDVI, customizing the plot with
proper title and legend. We then export the figure in PNG format:</p>
<div class="codewrapper sourceCode" id="cb21">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" tabindex="-1"></a><span class="im">import</span> earthpy.plot <span class="im">as</span> ep</span>
<span id="cb21-2"><a href="#cb21-2" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb21-3"><a href="#cb21-3" tabindex="-1"></a></span>
<span id="cb21-4"><a href="#cb21-4" tabindex="-1"></a><span class="im">from</span> matplotlib.colors <span class="im">import</span> ListedColormap</span>
<span id="cb21-5"><a href="#cb21-5" tabindex="-1"></a></span>
<span id="cb21-6"><a href="#cb21-6" tabindex="-1"></a><span class="co"># Define color map of the map legend</span></span>
<span id="cb21-7"><a href="#cb21-7" tabindex="-1"></a>ndvi_colors <span class="op">=</span> [<span class="st">"blue"</span>, <span class="st">"gray"</span>, <span class="st">"green"</span>, <span class="st">"darkgreen"</span>]</span>
<span id="cb21-8"><a href="#cb21-8" tabindex="-1"></a>ndvi_cmap <span class="op">=</span> ListedColormap(ndvi_colors)</span>
<span id="cb21-9"><a href="#cb21-9" tabindex="-1"></a></span>
<span id="cb21-10"><a href="#cb21-10" tabindex="-1"></a><span class="co"># Define class names for the legend</span></span>
<span id="cb21-11"><a href="#cb21-11" tabindex="-1"></a>category_names <span class="op">=</span> [</span>
<span id="cb21-12"><a href="#cb21-12" tabindex="-1"></a>    <span class="st">"Water"</span>,</span>
<span id="cb21-13"><a href="#cb21-13" tabindex="-1"></a>    <span class="st">"No Vegetation"</span>,</span>
<span id="cb21-14"><a href="#cb21-14" tabindex="-1"></a>    <span class="st">"Sparse Vegetation"</span>,</span>
<span id="cb21-15"><a href="#cb21-15" tabindex="-1"></a>    <span class="st">"Dense Vegetation"</span></span>
<span id="cb21-16"><a href="#cb21-16" tabindex="-1"></a>]</span>
<span id="cb21-17"><a href="#cb21-17" tabindex="-1"></a></span>
<span id="cb21-18"><a href="#cb21-18" tabindex="-1"></a><span class="co"># We need to know in what order the legend items should be arranged</span></span>
<span id="cb21-19"><a href="#cb21-19" tabindex="-1"></a>category_indices <span class="op">=</span> <span class="bu">list</span>(<span class="bu">range</span>(<span class="bu">len</span>(category_names)))</span>
<span id="cb21-20"><a href="#cb21-20" tabindex="-1"></a></span>
<span id="cb21-21"><a href="#cb21-21" tabindex="-1"></a><span class="co"># Make the plot</span></span>
<span id="cb21-22"><a href="#cb21-22" tabindex="-1"></a>im <span class="op">=</span> ndvi_classified.plot(cmap<span class="op">=</span>ndvi_cmap, add_colorbar<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb21-23"><a href="#cb21-23" tabindex="-1"></a>plt.title(<span class="st">"Classified NDVI"</span>)</span>
<span id="cb21-24"><a href="#cb21-24" tabindex="-1"></a><span class="co"># earthpy helps us by drawing a legend given an existing image plot and legend items, plus indices</span></span>
<span id="cb21-25"><a href="#cb21-25" tabindex="-1"></a>ep.draw_legend(im_ax<span class="op">=</span>im, classes<span class="op">=</span>category_indices, titles<span class="op">=</span>category_names)</span>
<span id="cb21-26"><a href="#cb21-26" tabindex="-1"></a></span>
<span id="cb21-27"><a href="#cb21-27" tabindex="-1"></a><span class="co"># Save the figure</span></span>
<span id="cb21-28"><a href="#cb21-28" tabindex="-1"></a>plt.savefig(<span class="st">"NDVI_classified.png"</span>, bbox_inches<span class="op">=</span><span class="st">"tight"</span>, dpi<span class="op">=</span><span class="dv">300</span>)</span></code></pre>
</div>
<figure><img src="../fig/E09/NDVI-classified.png" alt="classified NDVI map" class="figure mx-auto d-block"></figure><p>We can finally export the classified NDVI raster object to a GeoTiff
file. The <code>to_raster()</code> function by default writes the output
file to your working directory unless you specify a full file path.</p>
<div class="codewrapper sourceCode" id="cb22">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" tabindex="-1"></a>ndvi_classified.rio.to_raster(<span class="st">"NDVI_classified.tif"</span>, dtype<span class="op">=</span><span class="st">"int32"</span>)</span></code></pre>
</div>
<div id="exercise-compute-the-ndvi-for-the-texel-island" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="exercise-compute-the-ndvi-for-the-texel-island" class="callout-inner">
<h3 class="callout-title">Exercise: Compute the NDVI for the Texel
island<a class="anchor" aria-label="anchor" href="#exercise-compute-the-ndvi-for-the-texel-island"></a>
</h3>
<div class="callout-content">
<p>Data are often more interesting and powerful when we compare them
across various locations. Let’s compare the computed NDVI map with the
one of another region in the same Sentinel-2 scene: the <a href="https://en.wikipedia.org/wiki/Texel" class="external-link">Texel island</a>, located in
the North Sea.</p>
<ol start="0" style="list-style-type: decimal">
<li>You should have the red- and the NIR-band rasters already loaded
(<code>red</code> and <code>nir</code> variables, respectively).</li>
<li>Crop the two rasters using the following bounding box:
<code>(610000, 5870000, 630000, 5900000)</code>. Don’t forget to check
the shape of the data, and make sure the cropped areas have the same
CRSs, heights and widths.</li>
<li>Compute the NDVI from the two raster layers and check the max/min
values to make sure the data is what you expect.</li>
<li>Plot the NDVI map and export the NDVI as a GeoTiff.</li>
<li>Compare the distributions of NDVI values for the two regions
investigated.</li>
</ol>
</div>
</div>
</div>
<div id="accordionSolution2" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution2" aria-expanded="false" aria-controls="collapseSolution2">
  <h4 class="accordion-header" id="headingSolution2">Show me the solution</h4>
</button>
<div id="collapseSolution2" class="accordion-collapse collapse" aria-labelledby="headingSolution2" data-bs-parent="#accordionSolution2">
<div class="accordion-body">
<ol style="list-style-type: decimal">
<li>We crop the area of interest using <code>clip_box</code>:</li>
</ol>
<div class="codewrapper sourceCode" id="cb23">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" tabindex="-1"></a>bbox_texel <span class="op">=</span> (<span class="dv">610000</span>, <span class="dv">5870000</span>, <span class="dv">630000</span>, <span class="dv">5900000</span>)</span>
<span id="cb23-2"><a href="#cb23-2" tabindex="-1"></a>nir_texel <span class="op">=</span> nir.rio.clip_box(<span class="op">*</span>bbox_texel)</span>
<span id="cb23-3"><a href="#cb23-3" tabindex="-1"></a>red_texel <span class="op">=</span> red.rio.clip_box(<span class="op">*</span>bbox_texel)</span></code></pre>
</div>
<ol start="2" style="list-style-type: decimal">
<li>Reproject and clip one raster to the extent of the smaller raster
using <code>reproject_match</code>. The lines of code below assign a
variable to the reprojected raster and calculate the NDVI.</li>
</ol>
<div class="codewrapper sourceCode" id="cb24">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" tabindex="-1"></a>red_texel_matched <span class="op">=</span> red_texel.rio.reproject_match(nir_texel)</span>
<span id="cb24-2"><a href="#cb24-2" tabindex="-1"></a>ndvi_texel <span class="op">=</span> (nir_texel <span class="op">-</span> red_texel_matched)<span class="op">/</span> (nir_texel <span class="op">+</span> red_texel_matched)</span></code></pre>
</div>
<ol start="3" style="list-style-type: decimal">
<li>Plot the NDVI and save the raster data as a GeoTIFF file.</li>
</ol>
<div class="codewrapper sourceCode" id="cb25">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" tabindex="-1"></a>ndvi_texel.plot()</span>
<span id="cb25-2"><a href="#cb25-2" tabindex="-1"></a>ndvi_texel.rio.to_raster(<span class="st">"NDVI_Texel.tif"</span>)</span></code></pre>
</div>
<figure><img src="../fig/E09/NDVI-map-Texel.png" alt="NDVI map Texel" class="figure mx-auto d-block"></figure><ol start="4" style="list-style-type: decimal">
<li>Compute the NDVI histogram and compare it with the region that we
have previously investigated. Many more grid cells have negative NDVI
values, since the area of interest includes much more water. Also, NDVI
values close to zero are more abundant, indicating the presence of bare
ground (sand) regions.</li>
</ol>
<div class="codewrapper sourceCode" id="cb26">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" tabindex="-1"></a>ndvi_texel.plot.hist(bins<span class="op">=</span><span class="dv">50</span>)</span></code></pre>
</div>
<figure><img src="../fig/E09/NDVI-hist-Texel.png" alt="NDVI histogram Texel" class="figure mx-auto d-block"></figure>
</div>
</div>
</div>
</div>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Key Points<a class="anchor" aria-label="anchor" href="#keypoints1"></a>
</h3>
<div class="callout-content">
<ul>
<li>Python’s built-in math operators are fast and simple options for
raster math.</li>
<li>numpy.digitize can be used to classify raster values in order to
generate a less complicated map.</li>
</ul>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</section></section><section id="aio-10-zonal-statistics"><p>Content from <a href="10-zonal-statistics.html">Calculating Zonal Statistics on Rasters</a></p>
<hr>
<p>Last updated on 2023-08-14 |
        
        <a href="https://github.com/carpentries-incubator/geospatial-python/edit/main/episodes/10-zonal-statistics.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<p>Estimated time: <i aria-hidden="true" data-feather="clock"></i> 60 minutes</p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>How to compute raster statistics on different zones delineated by
vector data?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Extract zones from the vector dataset</li>
<li>Convert vector data to raster</li>
<li>Calculate raster statistics over zones</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="section level1">
<h1 id="introduction">Introduction<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h1>
<p>Statistics on predefined zones of the raster data are commonly used
for analysis and to better understand the data. These zones are often
provided within a single vector dataset, identified by certain vector
attributes. For example, in the previous episodes, we used the crop
field polygon dataset. The fields with the same crop type can be
identified as a “zone”, resulting in multiple zones in one vector
dataset. One may be interested in performing statistical analysis over
these crop zones.</p>
<p>In this episode, we will explore how to calculate zonal statistics
based on the types of crops in <code>fields_cropped.shp</code>. To do
this, we will first identify zones from the vector data, then rasterize
these vector zones. Finally the zonal statistics for <code>ndvi</code>
will be calculated over the rasterized zones.</p>
</div>
<div class="section level1">
<h1 id="making-vector-and-raster-data-compatible">Making vector and raster data compatible<a class="anchor" aria-label="anchor" href="#making-vector-and-raster-data-compatible"></a>
</h1>
<p>First, let’s load the <code>NDVI.tif</code> file saved in the
previous episode to obtained our calculated raster <code>ndvi</code>
data. We also use the <code>squeeze()</code> function in order to reduce
our raster data <code>ndvi</code> dimension to 2D by removing the
singular <code>band</code> dimension - this is necessary for use with
the <code>rasterize</code> and <code>zonal_stats</code> functions:</p>
<div class="codewrapper sourceCode" id="cb1">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="im">import</span> rioxarray</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a>ndvi <span class="op">=</span> rioxarray.open_rasterio(<span class="st">"NDVI.tif"</span>).squeeze()</span></code></pre>
</div>
<p>Let’s also read the crop fields vector data from our saved
<code>fields_cropped.shp</code> file.</p>
<div class="codewrapper sourceCode" id="cb2">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a><span class="im">import</span> geopandas <span class="im">as</span> gpd</span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a>fields <span class="op">=</span> gpd.read_file(<span class="st">'fields_cropped.shp'</span>)</span></code></pre>
</div>
<p>In order to use the vector data as a classifier for our raster, we
need to convert the vector data to the appropriate CRS. We can perform
the CRS conversion from the vector CRS (EPSG:28992) to our raster
<code>ndvi</code> CRS (EPSG:32631) with:</p>
<div class="codewrapper sourceCode" id="cb3">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a><span class="co"># Uniform CRS</span></span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a>fields_utm <span class="op">=</span> fields.to_crs(ndvi.rio.crs)</span></code></pre>
</div>
</div>
<div class="section level1">
<h1 id="rasterizing-the-vector-data">Rasterizing the vector data<a class="anchor" aria-label="anchor" href="#rasterizing-the-vector-data"></a>
</h1>
<p>Before calculating zonal statistics, we first need to rasterize our
<code>fields_utm</code> vector geodataframe with the
<code>rasterio.features.rasterize</code> function. With this function,
we aim to produce a grid with numerical values representing the types of
crops as defined by the column <code>gewascode</code> from
<code>field_cropped</code> - <code>gewascode</code> stands for the crop
codes as defined by the Netherlands Enterprise Agency (RVO) for
different types of crop or <code>gewas</code> (Grassland, permanent;
Grassland, temporary; corn fields; etc.). This grid of values thus
defines the zones for the <code>xrspatial.zonal_stats</code> function,
where each pixel in the zone grid overlaps with a corresponding pixel in
our NDVI raster.</p>
<p>We can generate the <code>geometry, gewascode</code> pairs for each
vector feature to be used as the first argument to
<code>rasterio.features.rasterize</code> as:</p>
<div class="codewrapper sourceCode" id="cb4">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a>geom <span class="op">=</span> fields_utm[[<span class="st">'geometry'</span>, <span class="st">'gewascode'</span>]].values.tolist()</span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a>geom</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>[[&lt;shapely.geometry.polygon.Polygon at 0x7ff88666f670&gt;, 265],
 [&lt;shapely.geometry.polygon.Polygon at 0x7ff86bf39280&gt;, 265],
 [&lt;shapely.geometry.polygon.Polygon at 0x7ff86ba1db80&gt;, 265],
 [&lt;shapely.geometry.polygon.Polygon at 0x7ff86ba1d730&gt;, 265],
 [&lt;shapely.geometry.polygon.Polygon at 0x7ff86ba1d400&gt;, 265],
 [&lt;shapely.geometry.polygon.Polygon at 0x7ff86ba1d130&gt;, 265],
...
 [&lt;shapely.geometry.polygon.Polygon at 0x7ff88685c970&gt;, 265],
 [&lt;shapely.geometry.polygon.Polygon at 0x7ff88685c9a0&gt;, 265],
 [&lt;shapely.geometry.polygon.Polygon at 0x7ff88685c9d0&gt;, 265],
 [&lt;shapely.geometry.polygon.Polygon at 0x7ff88685ca00&gt;, 331],
 ...]</code></pre>
</div>
<p>This generates a list of the shapely geometries from the
<code>geometry</code> column, and the unique field ID from the
<code>gewascode</code> column in the <code>fields_utm</code>
geodataframe.</p>
<p>We can now rasterize our vector data using
<code>rasterio.features.rasterize</code>:</p>
<div class="codewrapper sourceCode" id="cb6">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a><span class="im">from</span> rasterio <span class="im">import</span> features</span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a>fields_rasterized <span class="op">=</span> features.rasterize(geom, out_shape<span class="op">=</span>ndvi.shape, transform<span class="op">=</span>ndvi.rio.transform())</span></code></pre>
</div>
<p>The argument <code>out_shape</code> specifies the shape of the output
grid in pixel units, while <code>transform</code> represents the
projection from pixel space to the projected coordinate space. By
default, the pixels that are not contained within a polygon in our
shapefile will be filled with 0. It’s important to pick a fill value
that is not the same as any value already defined in
<code>gewascode</code> or else we won’t distinguish between this zone
and the background.</p>
<p>Let’s inspect the results of rasterization:</p>
<div class="codewrapper sourceCode" id="cb7">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a><span class="bu">print</span>(fields_rasterized.shape)</span>
<span id="cb7-3"><a href="#cb7-3" tabindex="-1"></a><span class="bu">print</span>(np.unique(fields_rasterized))</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>(500, 500)
[  0 259 265 266 331 332 335 863]</code></pre>
</div>
<p>The output <code>fields_rasterized</code> is an
<code>np.ndarray</code> with the same shape as <code>ndvi</code>. It
contains <code>gewascode</code> values at the location of fields, and 0
outside the fields. Let’s visualize it:</p>
<div class="codewrapper sourceCode" id="cb9">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a><span class="im">from</span> matplotlib <span class="im">import</span> pyplot <span class="im">as</span> plt</span>
<span id="cb9-2"><a href="#cb9-2" tabindex="-1"></a>plt.imshow(fields_rasterized)</span>
<span id="cb9-3"><a href="#cb9-3" tabindex="-1"></a>plt.colorbar()</span></code></pre>
</div>
<figure><img src="../fig/E10/rasterization-results.png" alt="rasterization results" class="figure mx-auto d-block"></figure><p>We will convert the output to <code>xarray.DataArray</code> which
will be used further. To do this, we will “borrow” the coordinates from
<code>ndvi</code>, and fill in the rasterization data:</p>
<div class="codewrapper sourceCode" id="cb10">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a><span class="im">import</span> xarray <span class="im">as</span> xr</span>
<span id="cb10-2"><a href="#cb10-2" tabindex="-1"></a>fields_rasterized_xarr <span class="op">=</span> ndvi.copy()</span>
<span id="cb10-3"><a href="#cb10-3" tabindex="-1"></a>fields_rasterized_xarr.data <span class="op">=</span> fields_rasterized</span>
<span id="cb10-4"><a href="#cb10-4" tabindex="-1"></a></span>
<span id="cb10-5"><a href="#cb10-5" tabindex="-1"></a><span class="co"># visualize</span></span>
<span id="cb10-6"><a href="#cb10-6" tabindex="-1"></a>fields_rasterized_xarr.plot(robust<span class="op">=</span><span class="va">True</span>)</span></code></pre>
</div>
<figure><img src="../fig/E10/rasterization-results-xr.png" alt="Rasterization results Xarray" class="figure mx-auto d-block"></figure>
</div>
<div class="section level1">
<h1 id="calculate-zonal-statistics">Calculate zonal statistics<a class="anchor" aria-label="anchor" href="#calculate-zonal-statistics"></a>
</h1>
<p>In order to calculate the statistics for each crop zone, we call the
function, <code>xrspatial.zonal_stats</code>. The
<code>xrspatial.zonal_stats</code> function takes as input
<code>zones</code>, a 2D <code>xarray.DataArray</code>, that defines
different zones, and <code>values</code>, a 2D
<code>xarray.DataArray</code> providing input values for calculating
statistics.</p>
<p>We call the <code>zonal_stats</code> function with
<code>fields_rasterized_xarr</code> as our classifier and the 2D raster
with our values of interest <code>ndvi</code> to obtain the NDVI
statistics for each crop type:</p>
<div class="codewrapper sourceCode" id="cb11">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a><span class="im">from</span> xrspatial <span class="im">import</span> zonal_stats</span>
<span id="cb11-2"><a href="#cb11-2" tabindex="-1"></a>zonal_stats(fields_rasterized_xarr, ndvi)</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>	zone	mean	max	min	sum	std	var	count
0	0	0.266531	0.999579	-0.998648	38887.648438	0.409970	0.168075	145903.0
1	259	0.520282	0.885242	0.289196	449.003052	0.111205	0.012366	863.0
2	265	0.775609	0.925955	0.060755	66478.976562	0.091089	0.008297	85712.0
3	266	0.794128	0.918048	0.544686	1037.925781	0.074009	0.005477	1307.0
4	331	0.703056	0.905304	0.142226	10725.819336	0.102255	0.010456	15256.0
5	332	0.681699	0.849158	0.178113	321.080261	0.123633	0.015285	471.0
6	335	0.648063	0.865804	0.239661	313.662598	0.146582	0.021486	484.0
7	863	0.388575	0.510572	0.185987	1.165724	0.144245	0.020807	3.0</code></pre>
</div>
<p>The <code>zonal_stats</code> function calculates the minimum,
maximum, and sum for each zone along with statistical measures such as
the mean, variance and standard deviation for each rasterized vector
zone. In our raster dataset <code>zone = 0</code>, corresponding to
non-crop areas, has the highest count followed by
<code>zone = 265</code> which corresponds to ‘Grasland, blijvend’ or
‘Grassland, permanent’. The highest mean NDVI is observed for
<code>zone = 266</code> for ‘Grasslands, temporary’ with the lowest
mean, aside from non-crop area, going to <code>zone = 863</code>
representing ‘Forest without replanting obligation’. Thus, the
<code>zonal_stats</code> function can be used to analyze and understand
different sections of our raster data. The definition of the zones can
be derived from vector data or from classified raster data as presented
in the challenge below:</p>
<div id="exercise-calculate-zonal-statistics-for-zones-defined-by-ndvi_classified" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="exercise-calculate-zonal-statistics-for-zones-defined-by-ndvi_classified" class="callout-inner">
<h3 class="callout-title">Exercise: Calculate zonal statistics for zones
defined by<code>ndvi_classified</code><a class="anchor" aria-label="anchor" href="#exercise-calculate-zonal-statistics-for-zones-defined-by-ndvi_classified"></a>
</h3>
<div class="callout-content">
<p>Let’s calculate NDVI zonal statistics for the different zones as
classified by <code>ndvi_classified</code> in the previous episode.</p>
<p>Load both raster datasets: <code>NDVI.tif</code> and
<code>NDVI_classified.tif</code>. Then, calculate zonal statistics for
each <code>class_bins</code>. Inspect the output of the
<code>zonal_stats</code> function.</p>
</div>
</div>
</div>
<div id="accordionSolution1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution1" aria-expanded="false" aria-controls="collapseSolution1">
  <h4 class="accordion-header" id="headingSolution1">Show me the solution</h4>
</button>
<div id="collapseSolution1" class="accordion-collapse collapse" data-bs-parent="#accordionSolution1" aria-labelledby="headingSolution1">
<div class="accordion-body">
<ol style="list-style-type: decimal">
<li>Load and convert raster data into suitable inputs for
<code>zonal_stats</code>:</li>
</ol>
<div class="codewrapper sourceCode" id="cb13">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a>ndvi <span class="op">=</span> rioxarray.open_rasterio(<span class="st">"NDVI.tif"</span>).squeeze()</span>
<span id="cb13-2"><a href="#cb13-2" tabindex="-1"></a>ndvi_classified <span class="op">=</span> rioxarray.open_rasterio(<span class="st">"NDVI_classified.tif"</span>).squeeze()</span></code></pre>
</div>
<ol start="2" style="list-style-type: decimal">
<li>Create and display the zonal statistics table.</li>
</ol>
<div class="codewrapper sourceCode" id="cb14">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" tabindex="-1"></a>zonal_stats(ndvi_classified, ndvi)</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>	zone    mean       max        min           sum         std      var	  count  
0     1  -0.355660  -0.000257  -0.998648  -12838.253906  0.145916  0.021291  36097.0  
1     2   0.110731   0.199839   0.000000    1754.752441  0.055864  0.003121  15847.0  
2     3   0.507998   0.700000   0.200000   50410.167969  0.140193  0.019654  99233.0  
3     4   0.798281   0.999579   0.700025   78888.523438  0.051730  0.002676  98823.0</code></pre>
</div>
</div>
</div>
</div>
</div>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Key Points<a class="anchor" aria-label="anchor" href="#keypoints1"></a>
</h3>
<div class="callout-content">
<ul>
<li>Zones can be extracted by attribute columns of a vector dataset</li>
<li>Zones can be rasterized using
<code>rasterio.features.rasterize</code>
</li>
<li>Calculate zonal statistics with <code>xrspatial.zonal_stats</code>
over the rasterized zones.</li>
</ul>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</div></section><section id="aio-11-parallel-raster-computations"><p>Content from <a href="11-parallel-raster-computations.html">Parallel raster computations using Dask</a></p>
<hr>
<p>Last updated on 2023-08-14 |
        
        <a href="https://github.com/carpentries-incubator/geospatial-python/edit/main/episodes/11-parallel-raster-computations.md" class="external-link">Edit this page <i aria-hidden="true" data-feather="edit"></i></a></p>
<p>Estimated time: <i aria-hidden="true" data-feather="clock"></i> 70 minutes</p>
<div class="text-end">
          <button role="button" aria-pressed="false" tabindex="0" id="expand-code" class="pull-right" data-expand="Expand All Solutions " data-collapse="Collapse All Solutions "> Expand All Solutions <i aria-hidden="true" data-feather="plus"></i></button>
        </div>
<div class="overview card">
<h2 class="card-header">Overview</h2>
<div class="row g-0">
<div class="col-md-4">
<div class="card-body">
<div class="inner">
<h3 class="card-title">Questions</h3>
<ul>
<li>How can I parallelize computations on rasters with Dask?</li>
<li>How can I determine if parallelization improves calculation
speed?</li>
<li>What are good practices in applying parallelization to my raster
calculations?</li>
</ul>
</div>
</div>
</div>
<div class="col-md-8">
<div class="card-body">
<div class="inner bordered">
<h3 class="card-title">Objectives</h3>
<ul>
<li>Profile the timing of the raster calculations.</li>
<li>Open raster data as a chunked array.</li>
<li>Recognize good practices in selecting proper chunk sizes.</li>
<li>Setup raster calculations that take advantage of
parallelization.</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<section id="introduction"><h2 class="section-heading">Introduction<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h2>
<hr class="half-width">
<p>Very often raster computations involve applying the same operation to
different pieces of data. Think, for instance, to the “pixel”-wise sum
of two raster datasets, where the same sum operation is applied to all
the matching grid-cells of the two rasters. This class of tasks can
benefit from chunking the input raster(s) into smaller pieces:
operations on different pieces can be run in parallel using multiple
computing units (e.g., multi-core CPUs), thus potentially speeding up
calculations. In addition, working on chunked data can lead to smaller
memory footprints, since one may bypass the need to store the full
dataset in memory by processing it chunk by chunk.</p>
<p>In this episode, we will introduce the use of Dask in the context of
raster calculations. Dask is a Python library for parallel and
distributed computing. It provides a framework to work with different
data structures, including chunked arrays (Dask Arrays). Dask is well
integrated with (<code>rio</code>)<code>xarray</code>, which can use
Dask arrays as underlying data structures.</p>
<div id="dask" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div id="dask" class="callout-inner">
<h3 class="callout-title">Dask<a class="anchor" aria-label="anchor" href="#dask"></a>
</h3>
<div class="callout-content">
<p>This episode shows how Dask can be used to parallelize operations on
local CPUs. However, the same library can be configured to run tasks on
large compute clusters.</p>
<p>More resources on Dask: - <a href="https://dask.org" class="external-link">Dask</a> and <a href="https://docs.dask.org/en/stable/array.html" class="external-link">Dask Array</a>. - <a href="https://xarray.pydata.org/en/stable/user-guide/dask.html" class="external-link">Xarray
with Dask</a>.</p>
</div>
</div>
</div>
<p>It is important to realize, however, that many details determine the
extent to which using Dask’s chunked arrays instead of regular Numpy
arrays leads to faster calculations (and lower memory requirements). The
actual operations to carry out, the size of the dataset, and parameters
such as the chunks’ shape and size, all affects the performance of our
computations. Depending on the specifics of the calculations, serial
calculations might actually turn out to be faster! Being able to profile
the computational time is thus essential, and we will see how to do that
in a Jupyter environment in the next section.</p>
<p>The example that we consider here is the application of a median
filter to a satellite image. <a href="https://en.wikipedia.org/wiki/Median_filter" class="external-link">Median filtering</a>
is a common noise removal technique which replaces a pixel’s value with
the median value computed from its surrounding pixels.</p>
</section><section id="time-profiling-in-jupyter"><h2 class="section-heading">Time profiling in Jupyter<a class="anchor" aria-label="anchor" href="#time-profiling-in-jupyter"></a>
</h2>
<hr class="half-width">
<div id="introduce-the-data" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div id="introduce-the-data" class="callout-inner">
<h3 class="callout-title">Introduce the Data<a class="anchor" aria-label="anchor" href="#introduce-the-data"></a>
</h3>
<div class="callout-content">
<p>We’ll continue from the results of the satellite image search that we
have carried out in an exercise from <a href="./05-access-data.html">a
previous episode</a>. We will load data starting from the
<code>search.json</code> file.</p>
<p>If you would like to work with the data for this lesson without
downloading data on-the-fly, you can download the raster data using this
<a href="https://figshare.com/ndownloader/files/36028100" class="external-link">link</a>. Save
the <code>geospatial-python-raster-dataset.tar.gz</code> file in your
current working directory, and extract the archive file by
double-clicking on it or by running the following command in your
terminal <code>tar -zxvf geospatial-python-raster-dataset.tar.gz</code>.
Use the file <code>geospatial-python-raster-dataset/search.json</code>
(instead of <code>search.json</code>) to get started with this
lesson.</p>
</div>
</div>
</div>
<p>Let’s set up a raster calculation using assets from our previous
search of satellite scenes. We first load the item collection using the
<code>pystac</code> library:</p>
<div class="codewrapper sourceCode" id="cb1">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="im">import</span> pystac</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a>items <span class="op">=</span> pystac.ItemCollection.from_file(<span class="st">"search.json"</span>)</span></code></pre>
</div>
<p>We select the last scene, and extract the URL of the true-color image
(“visual”):</p>
<div class="codewrapper sourceCode" id="cb2">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a>assets <span class="op">=</span> items[<span class="op">-</span><span class="dv">1</span>].assets  <span class="co"># last item's assets</span></span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a>visual_href <span class="op">=</span> assets[<span class="st">"visual"</span>].href  <span class="co"># true color image</span></span></code></pre>
</div>
<p>The true-color image is available as a raster file with 10 m
resolution and 3 bands (you can verify this by opening the file with
<code>rioxarray</code>), which makes it a relatively large file (few
hundreds MBs). In order to keep calculations “manageable” (reasonable
execution time and memory usage) we select here a lower resolution
version of the image, taking advantage of the so-called “pyramidal”
structure of cloud-optimized GeoTIFFs (COGs). COGs, in fact, typically
include multiple lower-resolution versions of the original image, called
“overviews”, in the same file. This allows us to avoid downloading
high-resolution images when only quick previews are required.</p>
<p>Overviews are often computed using powers of 2 as down-sampling (or
zoom) factors. So, typically, the first level overview (index 0)
corresponds to a zoom factor of 2, the second level overview (index 1)
corresponds to a zoom factor of 4, and so on. Here, we open the third
level overview (zoom factor 8) and check that the resolution is about 80
m:</p>
<div class="codewrapper sourceCode" id="cb3">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a><span class="im">import</span> rioxarray</span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a>visual <span class="op">=</span> rioxarray.open_rasterio(visual_href, overview_level<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb3-3"><a href="#cb3-3" tabindex="-1"></a><span class="bu">print</span>(visual.rio.resolution())</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>(79.97086671522214, -79.97086671522214)</code></pre>
</div>
<p>Let’s make sure the data has been loaded into memory before
proceeding to time profile our raster calculation. Calling the
<code>.load()</code> method of a DataArray object triggers data
loading:</p>
<div class="codewrapper sourceCode" id="cb5">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a>visual <span class="op">=</span> visual.load()</span></code></pre>
</div>
<p>Note that by default data is loaded using Numpy arrays as underlying
data structure. We can visualize the raster:</p>
<div class="codewrapper sourceCode" id="cb6">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a>visual.plot.imshow(figsize<span class="op">=</span>(<span class="dv">10</span>,<span class="dv">10</span>))</span></code></pre>
</div>
<figure><img src="../fig/E11/true-color-image.png" alt="true color image scene" class="figure mx-auto d-block"><div class="figcaption">Scene’s true-color image</div>
</figure><p>Let’s now apply a median filter to the image while keeping track of
the execution time of this task. The filter is carried out in two steps:
first, we define the size and centering of the region around each pixel
that will be considered for the median calculation (the so-called
“windows”), using the <code>.rolling()</code> method. We choose here
windows that are 7 pixel wide in both x and y dimensions, and, for each
window, consider the central pixel as the window target. We then call
the <code>.median()</code> method, which initiates the construction of
the windows and the actual calculation.</p>
<p>For the time profiling, we make use of the Jupyter magic
<code>%%time</code>, which returns the time required to run the content
of a cell (note that commands starting with <code>%%</code> needs to be
on the first line of the cell!):</p>
<div class="codewrapper sourceCode" id="cb7">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a><span class="op">%%</span>time</span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a>median <span class="op">=</span> visual.rolling(x<span class="op">=</span><span class="dv">7</span>, y<span class="op">=</span><span class="dv">7</span>, center<span class="op">=</span><span class="va">True</span>).median()</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>CPU times: user 15.6 s, sys: 3.2 s, total: 18.8 s
Wall time: 19.6 s</code></pre>
</div>
<p>Let’s note down the calculation’s “Wall time” (actual time to perform
the task). We can inspect the image resulting after the application of
median filtering:</p>
<div class="codewrapper sourceCode" id="cb9">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a>median.plot.imshow(robust<span class="op">=</span><span class="va">True</span>, figsize<span class="op">=</span>(<span class="dv">10</span>,<span class="dv">10</span>))</span></code></pre>
</div>
<figure><img src="../fig/E11/true-color-image_median-filter.png" alt="median filter true color image" class="figure mx-auto d-block"><div class="figcaption">True-color image after median filtering</div>
</figure><div id="handling-edges" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div id="handling-edges" class="callout-inner">
<h3 class="callout-title">Handling edges<a class="anchor" aria-label="anchor" href="#handling-edges"></a>
</h3>
<div class="callout-content">
<p>By looking closely, you might notice a tiny white edge at the plot
boundaries. These are the pixels that are less than 3 pixels away from
the border of the image. These pixels cannot be surrounded by a 7 pixel
wide window. The default behaviour is to assign these with nodata
values.</p>
</div>
</div>
</div>
<p>Finally, let’s write the data to disk:</p>
<div class="codewrapper sourceCode" id="cb10">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a>median.rio.to_raster(<span class="st">"visual_median-filter.tif"</span>)</span></code></pre>
</div>
<p>In the following section we will see how to parallelize these raster
calculations, and we will compare timings to the serial calculations
that we have just run.</p>
</section><section id="dask-powered-rasters"><h2 class="section-heading">Dask-powered rasters<a class="anchor" aria-label="anchor" href="#dask-powered-rasters"></a>
</h2>
<hr class="half-width">
<div class="section level3">
<h3 id="chunked-arrays">Chunked arrays<a class="anchor" aria-label="anchor" href="#chunked-arrays"></a>
</h3>
<p>As we have mentioned, <code>rioxarray</code> supports the use of
Dask’s chunked arrays as underlying data structure. When opening a
raster file with <code>open_rasterio</code> and providing the
<code>chunks</code> argument, Dask arrays are employed instead of
regular Numpy arrays. <code>chunks</code> describes the shape of the
blocks which the data will be split in. As an example, we open the blue
band raster using a chunk shape of <code>(1, 4000, 4000)</code> (block
size of <code>1</code> in the first dimension and of <code>4000</code>
in the second and third dimensions):</p>
<div class="codewrapper sourceCode" id="cb11">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a>blue_band_href <span class="op">=</span> assets[<span class="st">"blue"</span>].href</span>
<span id="cb11-2"><a href="#cb11-2" tabindex="-1"></a>blue_band <span class="op">=</span> rioxarray.open_rasterio(blue_band_href, chunks<span class="op">=</span>(<span class="dv">1</span>, <span class="dv">4000</span>, <span class="dv">4000</span>))</span></code></pre>
</div>
<p>Xarray and Dask also provide a graphical representation of the raster
data array and of its blocked structure.</p>
<figure><img src="../fig/E11/xarray-with-dask.png" alt="DataArray with Dask" class="figure mx-auto d-block"><div class="figcaption">Xarray Dask-backed DataArray</div>
</figure><div id="exercise-chunk-sizes-matter" class="callout challenge">
<div class="callout-square">
<i class="callout-icon" data-feather="zap"></i>
</div>
<div id="exercise-chunk-sizes-matter" class="callout-inner">
<h3 class="callout-title">Exercise: Chunk sizes matter<a class="anchor" aria-label="anchor" href="#exercise-chunk-sizes-matter"></a>
</h3>
<div class="callout-content">
<p>We have already seen how COGs are regular GeoTIFF files with a
special internal structure. other feature of COGs is that data is
organized in “blocks” that can be accessed remotely via independent HTTP
requests, abling partial file readings. This is useful if you want to
access only a portion of your raster file, but it also lows for
efficient parallel reading. You can check the blocksize employed in a
COG file with the following code ippet:</p>
<div class="codewrapper sourceCode" id="cb12">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a><span class="im">import</span> rasterio</span>
<span id="cb12-2"><a href="#cb12-2" tabindex="-1"></a><span class="cf">with</span> rasterio.<span class="bu">open</span>(visual_href) <span class="im">as</span> r:</span>
<span id="cb12-3"><a href="#cb12-3" tabindex="-1"></a>    <span class="cf">if</span> r.is_tiled:</span>
<span id="cb12-4"><a href="#cb12-4" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Chunk size: </span><span class="sc">{</span>r<span class="sc">.</span>block_shapes<span class="sc">}</span><span class="ss">"</span>)</span></code></pre>
</div>
<p>In order to optimally access COGs it is best to align the blocksize
of the file with the chunks ployed when loading the file. Open the
blue-band asset (the “blue” asset) of a Sentinel-2 scene as a chunked
<code>DataArray</code> object using a suitable chunk size. Which
elements do you think should be considered when choosing the chunk
size?</p>
</div>
</div>
</div>
<div id="accordionSolution1" class="accordion challenge-accordion accordion-flush">
<div class="accordion-item">
<button class="accordion-button solution-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSolution1" aria-expanded="false" aria-controls="collapseSolution1">
  <h4 class="accordion-header" id="headingSolution1">Show me the solution</h4>
</button>
<div id="collapseSolution1" class="accordion-collapse collapse" aria-labelledby="headingSolution1" data-bs-parent="#accordionSolution1">
<div class="accordion-body">
<div class="codewrapper sourceCode" id="cb13">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a><span class="im">import</span> rasterio</span>
<span id="cb13-2"><a href="#cb13-2" tabindex="-1"></a><span class="cf">with</span> rasterio.<span class="bu">open</span>(blue_band_href) <span class="im">as</span> r:</span>
<span id="cb13-3"><a href="#cb13-3" tabindex="-1"></a>    <span class="cf">if</span> r.is_tiled:</span>
<span id="cb13-4"><a href="#cb13-4" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Chunk size: </span><span class="sc">{</span>r<span class="sc">.</span>block_shapes<span class="sc">}</span><span class="ss">"</span>)</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>Chunk size: [(1024, 1024)]</code></pre>
</div>
<p>Ideal chunk size values for this raster are thus multiples of 1024.
An element to consider is number of resulting chunks and their size.
While the optimal chunk size strongly depends on the specific
application, chunks should in general not be too big nor too small
(i.e. too many). As a rule of thumb, chunk sizes of 100 MB typically
work well with Dask (see, e.g., this <a href="https://blog.dask.org/2021/11/02/choosing-dask-chunk-sizes" class="external-link">blog
post</a>). Also, the shape might be relevant, depending on the
application! Here, we might select a chunks shape of
<code>(1, 6144, 6144)</code>::</p>
<div class="codewrapper sourceCode" id="cb15">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" tabindex="-1"></a>band <span class="op">=</span> rioxarray.open_rasterio(blue_band_href, chunks<span class="op">=</span>(<span class="dv">1</span>, <span class="dv">6144</span>, <span class="dv">6144</span>))</span></code></pre>
</div>
<p>which leads to chunks 72 MB large: ((1 x 6144 x 6144) x 2 bytes /
2^20 = 72 MB). Also, we can t
ioxarray<code>and Dask figure out appropriate chunk shapes by setting</code>chunks=“auto”`:</p>
<div class="codewrapper sourceCode" id="cb16">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" tabindex="-1"></a>band <span class="op">=</span> rioxarray.open_rasterio(blue_band_href, chunks<span class="op">=</span><span class="st">"auto"</span>)</span></code></pre>
</div>
<p>which leads to <code>(1, 8192, 8192)</code> chunks (128 MB).</p>
</div>
</div>
</div>
</div>
</div>
<div class="section level3">
<h3 id="parallel-computations">Parallel computations<a class="anchor" aria-label="anchor" href="#parallel-computations"></a>
</h3>
<p>Operations performed on a <code>DataArray</code> that has been opened
as a chunked Dask array are executed using Dask. Dask coordinates how
the operations should be executed on the individual chunks of data, and
runs these tasks in parallel as much as possible.</p>
<p>Let’s now repeat the raster calculations that we have carried out in
the previous section, but running calculations in parallel over a
multi-core CPU. We first open the relevant rasters as chunked
arrays:</p>
<div class="codewrapper sourceCode" id="cb17">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" tabindex="-1"></a>visual_dask <span class="op">=</span> rioxarray.open_rasterio(visual_href, overview_level<span class="op">=</span><span class="dv">2</span>, lock<span class="op">=</span><span class="va">False</span>, chunks<span class="op">=</span>(<span class="dv">3</span>, <span class="dv">500</span>, <span class="dv">500</span>))</span></code></pre>
</div>
<p>Setting <code>lock=False</code> tells <code>rioxarray</code> that the
individual data chunks can be loaded simultaneously from the source by
the Dask workers.</p>
<p>As the next step, we trigger the download of the data using the
<code>.persist()</code> method, see below. This makes sure that the
downloaded chunks are stored in the form of a chunked Dask array
(calling <code>.load()</code> would instead merge the chunks in a single
Numpy array).</p>
<p>We explicitly tell Dask to parallelize the required workload over 4
threads:</p>
<div class="codewrapper sourceCode" id="cb18">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" tabindex="-1"></a>visual_dask <span class="op">=</span> visual_dask.persist(scheduler<span class="op">=</span><span class="st">"threads"</span>, num_workers<span class="op">=</span><span class="dv">4</span>)</span></code></pre>
</div>
<p>Let’s now continue to the actual calculation. Note how the same
syntax as for its serial version is employed for applying the median
filter. Don’t forget to add the Jupyter magic to record the timing!</p>
<div class="codewrapper sourceCode" id="cb19">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" tabindex="-1"></a><span class="op">%%</span>time</span>
<span id="cb19-2"><a href="#cb19-2" tabindex="-1"></a>median_dask <span class="op">=</span> visual_dask.rolling(x<span class="op">=</span><span class="dv">7</span>, y<span class="op">=</span><span class="dv">7</span>, center<span class="op">=</span><span class="va">True</span>).median()</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>CPU times: user 20.6 ms, sys: 3.71 ms, total: 24.3 ms
Wall time: 25.2 ms</code></pre>
</div>
<p>Did we just observe a 700x speed-up when comparing to the serial
calculation (19.6 s vs 25.2 ms)? Actually, no calculation has run yet.
This is because operations performed on Dask arrays are executed
“lazily”, i.e. they are not immediately run.</p>
<div id="dask-graph" class="callout">
<div class="callout-square">
<i class="callout-icon" data-feather="bell"></i>
</div>
<div id="dask-graph" class="callout-inner">
<h3 class="callout-title">Dask graph<a class="anchor" aria-label="anchor" href="#dask-graph"></a>
</h3>
<div class="callout-content">
<p>The sequence of operations to carry out is stored in a task graph,
which can be visualized with:</p>
<div class="codewrapper sourceCode" id="cb21">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" tabindex="-1"></a><span class="im">import</span> dask</span>
<span id="cb21-2"><a href="#cb21-2" tabindex="-1"></a>dask.visualize(median_dask)</span></code></pre>
</div>
<figure><img src="../fig/E11/dask-graph.png" alt="dask graph" class="figure mx-auto d-block"><div class="figcaption">Dask graph</div>
</figure><p>The task graph gives Dask the complete “overview” of the calculation,
thus enabling a better nagement of tasks and resources when dispatching
calculations to be run in parallel.</p>
</div>
</div>
</div>
<p>Most methods of <code>DataArray</code>’s run operations lazily when
Dask arrays are employed. In order to trigger calculations, we can use
either <code>.persist()</code> or <code>.compute()</code>. The former
keeps data in the form of chunked Dask arrays, and it should thus be
used to run intermediate steps that will be followed by additional
calculations. The latter merges instead the chunks in a single Numpy
array, and it should be used at the very end of a sequence of
calculations. Both methods accept the same parameters (here, we again
explicitly tell Dask to run tasks on 4 threads). Let’s again time the
cell execution:</p>
<div class="codewrapper sourceCode" id="cb22">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" tabindex="-1"></a><span class="op">%%</span>time</span>
<span id="cb22-2"><a href="#cb22-2" tabindex="-1"></a>median_dask <span class="op">=</span> median_dask.persist(scheduler<span class="op">=</span><span class="st">"threads"</span>, num_workers<span class="op">=</span><span class="dv">4</span>)</span></code></pre>
</div>
<div class="codewrapper">
<h3 class="code-label">OUTPUT<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="output" tabindex="0"><code>CPU times: user 19.1 s, sys: 3.2 s, total: 22.3 s
Wall time: 6.61 s</code></pre>
</div>
<p>The timing that we have recorded makes much more sense now. When
running the task on a 4-core CPU laptop, we observe a x3 speed-up when
comparing to the analogous serial calculation (19.6 s vs 6.61 s).</p>
<p>Once again, we stress that one does not always obtain similar
performance gains by exploiting the Dask-based parallelization. Even if
the algorithm employed is well suited for parallelization, Dask
introduces some overhead time to manage the tasks in the Dask graph.
This overhead, which is typically of the order of few milliseconds per
task, can be larger than the parallelization gain. This is the typical
situation with calculations with many small chunks.</p>
<p>Finally, let’s have a look at how Dask can be used to save raster
files. When calling <code>.to_raster()</code>, we provide the following
additional arguments: * <code>tiled=True</code>: write raster as a
chunked GeoTIFF. * <code>lock=threading.Lock()</code>: the threads which
are splitting the workload must “synchronise” when writing to the same
file (they might otherwise overwrite each other’s output).</p>
<div class="codewrapper sourceCode" id="cb24">
<h3 class="code-label">PYTHON<i aria-hidden="true" data-feather="chevron-left"></i><i aria-hidden="true" data-feather="chevron-right"></i>
</h3>
<pre class="sourceCode python" tabindex="0"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" tabindex="-1"></a><span class="im">from</span> threading <span class="im">import</span> Lock</span>
<span id="cb24-2"><a href="#cb24-2" tabindex="-1"></a>median_dask.rio.to_raster(<span class="st">"visual_median-filter_dask.tif"</span>, tiled<span class="op">=</span><span class="va">True</span>, lock<span class="op">=</span>Lock())</span></code></pre>
</div>
<p>Note that <code>.to_raster()</code> is among the methods that trigger
immediate calculations (one can change this behaviour by specifying
<code>compute=False</code>)</p>
<div id="keypoints1" class="callout keypoints">
<div class="callout-square">
<i class="callout-icon" data-feather="key"></i>
</div>
<div class="callout-inner">
<h3 class="callout-title">Key Points<a class="anchor" aria-label="anchor" href="#keypoints1"></a>
</h3>
<div class="callout-content">
<ul>
<li>The <code>%%time</code> Jupyter magic command can be used to profile
calculations.</li>
<li>Data ‘chunks’ are the unit of parallelization in raster
calculations.</li>
<li>(<code>rio</code>)<code>xarray</code> can open raster files as
chunked arrays.</li>
<li>The chunk shape and size can significantly affect the calculation
performance.</li>
<li>Cloud-optimized GeoTIFFs have an internal structure that enables
performant parallel read.</li>
</ul>
</div>
</div>
</div>
<!--
Place links that you need to refer to multiple times across pages here. Delete
any links that you are not going to use.
 -->
</div>
</section></section>
</div>
    </main>
</div>
<!-- END  : inst/pkgdown/templates/content-extra.html -->

      </div>
<!--/div.row-->
      		<footer class="row footer mx-md-3"><hr>
<div class="col-md-6">
        <p>This lesson is subject to the <a href="CODE_OF_CONDUCT.html">Code of Conduct</a></p>
        <p>
        
        <a href="https://github.com/carpentries-incubator/geospatial-python/edit/main/README.md" class="external-link">Edit on GitHub</a>
        
	
        | <a href="https://github.com/carpentries-incubator/geospatial-python/blob/main/CONTRIBUTING.md" class="external-link">Contributing</a>
        | <a href="https://github.com/carpentries-incubator/geospatial-python/" class="external-link">Source</a></p>
				<p><a href="https://github.com/carpentries-incubator/geospatial-python/blob/main/CITATION" class="external-link">Cite</a> | <a href="mailto:team@carpentries.org">Contact</a> | <a href="https://carpentries.org/about/" class="external-link">About</a></p>
			</div>
			<div class="col-md-6">
        
        <p>Materials licensed under <a href="LICENSE.html">CC-BY 4.0</a> by the authors</p>
        
        <p>Template licensed under <a href="https://creativecommons.org/licenses/by-sa/4.0/" class="external-link">CC-BY 4.0</a> by <a href="https://carpentries.org/" class="external-link">The Carpentries</a></p>
        <p>Built with <a href="https://github.com/carpentries/sandpaper/tree/0.16.4" class="external-link">sandpaper (0.16.4)</a>, <a href="https://github.com/carpentries/pegboard/tree/0.7.5" class="external-link">pegboard (0.7.5)</a>, and <a href="https://github.com/carpentries/varnish/tree/1.0.2" class="external-link">varnish (1.0.2)</a></p>
			</div>
		</footer>
</div> <!-- / div.container -->
	<div id="to-top">
		<a href="#top">
      <i class="search-icon" data-feather="arrow-up" role="img" aria-label="Back To Top"></i><br><!-- <span class="d-none d-sm-none d-md-none d-lg-none d-xl-block">Back</span> To Top --><span class="d-none d-sm-none d-md-none d-lg-none d-xl-block">Back</span> To Top
		</a>
	</div>
  <script type="application/ld+json">
    {
  "@context": "https://schema.org",
  "@type": "TrainingMaterial",
  "@id": "https://carpentries-incubator.github.io/geospatial-python/instructor/aio.html",
  "inLanguage": "en",
  "dct:conformsTo": "https://bioschemas.org/profiles/TrainingMaterial/1.0-RELEASE",
  "description": "A Carpentries Lesson teaching foundational data and coding skills to researchers worldwide",
  "keywords": "software, data, lesson, The Carpentries",
  "name": "All in One View",
  "creativeWorkStatus": "active",
  "url": "https://carpentries-incubator.github.io/geospatial-python/instructor/aio.html",
  "identifier": "https://carpentries-incubator.github.io/geospatial-python/instructor/aio.html",
  "dateCreated": "2024-03-05",
  "dateModified": "2024-06-04",
  "datePublished": "2024-06-04"
}

  </script><script>
		feather.replace();
	</script><!-- Matomo
    2022-11-07: we have gotten a notification that we have an overage for our
    tracking and I'm pretty sure this has to do with Workbench usage.
    Considering that I am not _currently_ using this tracking because I do not
    yet know how to access the data, I am turning this off for now.
  <script>
    var _paq = window._paq = window._paq || [];
    /* tracker methods like "setCustomDimension" should be called before "trackPageView" */
    _paq.push(["setDocumentTitle", document.domain + "/" + document.title]);
    _paq.push(["setDomains", ["*.preview.carpentries.org","*.datacarpentry.github.io","*.datacarpentry.org","*.librarycarpentry.github.io","*.librarycarpentry.org","*.swcarpentry.github.io", "*.carpentries.github.io"]]);
    _paq.push(["setDoNotTrack", true]);
    _paq.push(["disableCookies"]);
    _paq.push(['trackPageView']);
    _paq.push(['enableLinkTracking']);
    (function() {
          var u="https://carpentries.matomo.cloud/";
          _paq.push(['setTrackerUrl', u+'matomo.php']);
          _paq.push(['setSiteId', '1']);
          var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
          g.async=true; g.src='https://cdn.matomo.cloud/carpentries.matomo.cloud/matomo.js'; s.parentNode.insertBefore(g,s);
        })();
  </script>
  End Matomo Code -->
</body>
</html><!-- END:   inst/pkgdown/templates/layout.html-->

